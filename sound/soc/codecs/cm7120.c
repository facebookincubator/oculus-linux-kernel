/*
 * cm7120.c  --  CM7120 ALSA SoC audio component driver
 *
 * Author: Support <sales@cmedia.com.tw>
 *		Copyright 2019
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#include <linux/acpi.h>
#include <linux/fs.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/regmap.h>
#include <linux/i2c.h>
#include <linux/spi/spi.h>
#include <linux/platform_device.h>
#include <linux/firmware.h>
#include <linux/of_device.h>
#include <linux/gpio.h>
#include <linux/of_gpio.h>
#include <linux/clk.h>
#include <linux/regulator/consumer.h>
#include <linux/pinctrl/consumer.h>
#include <linux/suspend.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/soc-dapm.h>
#include <sound/tlv.h>
#include <sound/jack.h>

#include "cm7120.h"
#include "cm7120-spi.h"

//#define DSP_MODE_USE_SPI

#define VERSION "1.0.2"
#define FW_DOWNLOAD_TIMEOUT (1 * HZ)

static u32 DspAddr = 0x5ffc001C;
static u32 CodecAddr = 0x3C;
static const char hextext[] = "0123456789abcdefxABCDEFX";

/* declare */
static int cm7120_download_firmware(struct cm7120_priv *cm7120_codec);
static void cm7120_firmware_download_work(struct work_struct *work);
static int cm7120_firmware_parsing(struct cm7120_priv *cm7120,
				   void *FirmwareData, size_t len);
static int cm7120_write_firmware_codec_cmd(struct cm7120_priv *cm7120,
					   u8 *I2CCommand, int count);
static int cm7120_write_firmware_romcode(struct cm7120_priv *cm7120,
					 u8 *RomCodeData, int count);

static int cm7120_dsp_mode_i2c_read_mem(struct regmap *regmap, u32 uAddr,
					u32 *Data);
static int cm7120_dsp_mode_i2c_write_mem(struct regmap *regmap, u32 uAddr,
					 u8 *Data, int len);
static void cm7120_update_eq_pregain_enable(struct cm7120_priv *cm7120_codec);
static int cm7120_get_vu(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_put_vu(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm710x_get_dsp_param(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm710x_put_dsp_param(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_get_eq_gain(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_put_eq_gain(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_set_mic_mute(struct cm7120_priv *cm7120_codec,
		char mute);
static int cm7120_get_hp_impedance(struct cm7120_priv *cm7120_codec);
static int cm7120_hw_params(struct snd_pcm_substream *substream,
		struct snd_pcm_hw_params *params,
		struct snd_soc_dai *dai);

static const struct reg_default cm7120_reg[] = {
	{ CM7120_RESET, 0x0000 },
	{ CM7120_LOUT, 0x8080 },
	{ CM7120_HP_OUT, 0x0000 },
	{ CM7120_MONO_OUT, 0x0000 },
	{ CM7120_BST12_CTRL, 0x0000 },
	{ CM7120_BST34_CTRL, 0x0000 },
	{ CM7120_VAD_INBUF_CTRL, 0x0005 },
	{ CM7120_CAL_ADC_MIXER_CTRL, 0x5455 },
	{ CM7120_MICBIAS1_CTRL1, 0x0091 },
	{ CM7120_MICBIAS1_CTRL2, 0x0000 },
	{ CM7120_DAC1_POST_DIG_VOL, 0x5757 },
	{ CM7120_DAC1_DIG_VOL, 0xafaf },
	{ CM7120_DAC2_DIG_VOL, 0xafaf },
	{ CM7120_DAC3_DIG_VOL, 0xafaf },
	{ CM7120_STO1_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_MONO_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_STO2_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_STO3_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_ADC_BST_GAIN_CTRL1, 0x0000 },
	{ CM7120_ADC_BST_GAIN_CTRL2, 0x0000 },
	{ CM7120_ADC_BST_GAIN_CTRL3, 0x0000 },
	{ CM7120_SPDIF_IN_CTRL, 0x6000 },
	{ CM7120_IF3_DATA_CTRL, 0x0000 },
	{ CM7120_IF4_DATA_CTRL, 0x0000 },
	{ CM7120_IF5_DATA_CTRL, 0x0000 },
	{ CM7120_TDM1_CTRL1, 0x00f0 },
	{ CM7120_TDM1_CTRL2, 0x0000 },
	{ CM7120_TDM1_CTRL3, 0x0000 },
	{ CM7120_TDM1_CTRL4, 0x0000 },
	{ CM7120_TDM1_CTRL5, 0x0123 },
	{ CM7120_TDM1_CTRL6, 0x4567 },
	{ CM7120_TDM1_CTRL7, 0x8003 },
	{ CM7120_TDM2_CTRL1, 0x00f0 },
	{ CM7120_TDM2_CTRL2, 0x0000 },
	/* CM7120_TDM2_CTRL3 set to 0xc as the same with config */
	{ CM7120_TDM2_CTRL3, 0x000c },
	{ CM7120_TDM2_CTRL4, 0x0000 },
	{ CM7120_TDM2_CTRL5, 0x0123 },
	{ CM7120_TDM2_CTRL6, 0x4567 },
	{ CM7120_TDM2_CTRL7, 0x8003 },
	{ CM7120_STO1_DAC_MIXER_CTRL1, 0xcaaa },
	{ CM7120_STO1_DAC_MIXER_CTRL2, 0xaa00 },
	{ CM7120_MONO_DAC_MIXER_CTRL1, 0xcaaa },
	{ CM7120_MONO_DAC_MIXER_CTRL2, 0xaa00 },
	{ CM7120_DD_MIXER_CTRL1, 0xaaaa },
	{ CM7120_DD_MIXER_CTRL2, 0xaa00 },
	{ CM7120_DAC1_MIXER_CTRL, 0xb080 },
	{ CM7120_DAC2_MIXER_CTRL, 0x0000 },
	{ CM7120_DAC3_MIXER_CTRL, 0x0000 },
	{ CM7120_DAC_SOURCE_CTRL, 0x0000 },
	{ CM7120_STO1_ADC_MIXER_CTRL, 0xc0c0 },
	{ CM7120_MONO_ADC_MIXER_CTRL1, 0xc0c0 },
	{ CM7120_MONO_ADC_MIXER_CTRL2, 0x0000 },
	{ CM7120_STO2_ADC_MIXER_CTRL, 0xc0c0 },
	{ CM7120_STO3_ADC_MIXER_CTRL, 0xc0c0 },
	{ CM7120_DMIC_CTRL1, 0x0550 },
	{ CM7120_DMIC_CTRL2, 0x0055 },
	{ CM7120_HPF_CTRL1, 0x1e00 },
	{ CM7120_SV_ZCD_CTRL1, 0x0009 },
	{ CM7120_PWR_ADC, 0x0000 },
	{ CM7120_PWR_DIG1, 0x0000 },
	{ CM7120_PWR_DIG2, 0x0000 },
	{ CM7120_PWR_ANA1, 0x0040 },
	{ CM7120_PWR_ANA2, 0x0000 },
	{ CM7120_PWR_DSP, 0x0181 },
	{ CM7120_PWR_LDO1, 0x0000 },
	{ CM7120_PWR_LDO2, 0x0002 },
	{ CM7120_PWR_LDO3, 0x3703 },
	{ CM7120_PWR_LDO4, 0x0100 },
	{ CM7120_PWR_LDO5, 0x0000 },
	{ CM7120_I2S1_SDP, 0x8000 },
	{ CM7120_I2S2_SDP, 0x8000 },
	{ CM7120_I2S3_SDP, 0x8000 },
	{ CM7120_I2S4_SDP, 0x8000 },
	{ CM7120_I2S5_SDP, 0x8000 },
	{ CM7120_I2S_LRCK_BCLK_SOURCE, 0x0000 },
	{ CM7120_CLK_TREE_CTRL1, 0x7777 },
	{ CM7120_CLK_TREE_CTRL2, 0x7777 },
	{ CM7120_CLK_TREE_CTRL3, 0x7000 },
	{ CM7120_CLK_TREE_CTRL4, 0x3000 },
	{ CM7120_PLL1_CTRL1, 0x0000 },
	{ CM7120_PLL1_CTRL2, 0x0000 },
	{ CM7120_PLL2_CTRL1, 0x0000 },
	{ CM7120_PLL2_CTRL2, 0x0000 },
	{ CM7120_DSP_CLK_SOURCE1, 0x0111 },
	{ CM7120_DSP_CLK_SOURCE2, 0x0333 },
	{ CM7120_GLB_CLK1, 0x0000 },
	{ CM7120_GLB_CLK2, 0x0000 },
	{ CM7120_ASRC1, 0x0000 },
	{ CM7120_ASRC2, 0x0000 },
	{ CM7120_ASRC3, 0x0000 },
	{ CM7120_ASRC4, 0x0000 },
	{ CM7120_ASRC5, 0x0000 },
	{ CM7120_ASRC6, 0x0000 },
	{ CM7120_ASRC7, 0x0000 },
	{ CM7120_ASRC8, 0x0000 },
	{ CM7120_ASRC9, 0x0000 },
	{ CM7120_ASRC10, 0x0000 },
	{ CM7120_ASRC11, 0x0000 },
	{ CM7120_ASRC12, 0x0008 },
	{ CM7120_ASRC13, 0x0000 },
	{ CM7120_ASRC14, 0x0000 },
	{ CM7120_ASRC15, 0x0000 },
	{ CM7120_ASRC16, 0x0000 },
	{ CM7120_ASRC17, 0x0000 },
	{ CM7120_ASRC18, 0x0000 },
	{ CM7120_ASRC19, 0x0000 },
	{ CM7120_ASRC20, 0x0000 },
	{ CM7120_ASRC21, 0x0000 },
	{ CM7120_ASRC22, 0x0000 },
	{ CM7120_ASRC23, 0x0000 },
	{ CM7120_ASRC24, 0x0000 },
	{ CM7120_ASRC25, 0x000c },
	{ CM7120_FRAC_DIV_CTRL1, 0x0002 },
	{ CM7120_FRAC_DIV_CTRL2, 0x0001 },
	{ CM7120_JACK_MIC_DET_CTRL1, 0x7080 },
	{ CM7120_JACK_MIC_DET_CTRL2, 0x4a00 },
	{ CM7120_JACK_MIC_DET_CTRL3, 0x4e01 },
	{ CM7120_JACK_MIC_DET_CTRL4, 0xa000 },
	{ CM7120_JACK_DET_CTRL1, 0x0000 },
	{ CM7120_JACK_DET_CTRL2, 0x0000 },
	{ CM7120_JACK_DET_CTRL3, 0x0000 },
	{ CM7120_JACK_DET_CTRL4, 0x0000 },
	{ CM7120_JACK_DET_CTRL5, 0x0000 },
	{ CM7120_IRQ_ST1, 0x0000 },
	{ CM7120_IRQ_ST2, 0x0000 },
	{ CM7120_IRQ_CTRL1, 0x0000 },
	{ CM7120_IRQ_CTRL2, 0x0000 },
	{ CM7120_IRQ_CTRL3, 0x0000 },
	{ CM7120_IRQ_CTRL4, 0x0000 },
	{ CM7120_IRQ_CTRL5, 0x0000 },
	{ CM7120_IRQ_CTRL6, 0x0000 },
	{ CM7120_IRQ_CTRL7, 0x0000 },
	{ CM7120_IRQ_CTRL8, 0x0000 },
	{ CM7120_IRQ_CTRL9, 0x0000 },
	{ CM7120_MF_PIN_CTRL1, 0x2008 },
	{ CM7120_MF_PIN_CTRL2, 0x8600 },
	{ CM7120_MF_PIN_CTRL3, 0x0000 },
	{ CM7120_GPIO_CTRL1, 0x0000 },
	{ CM7120_GPIO_CTRL2, 0x0000 },
	{ CM7120_GPIO_CTRL3, 0x0000 },
	{ CM7120_GPIO_CTRL4, 0x0000 },
	{ CM7120_GPIO_CTRL5, 0x0000 },
	{ CM7120_GPIO_CTRL6, 0x0000 },
	{ CM7120_GPIO_ST1, 0x0000 },
	{ CM7120_GPIO_ST2, 0x0000 },
	{ CM7120_LP_DET_CTRL, 0x0300 },
	{ CM7120_STO1_ADC_HPF_CTRL1, 0xb320 },
	{ CM7120_STO1_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_MONO_ADC_HPF_CTRL1, 0xb300 },
	{ CM7120_MONO_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_STO2_ADC_HPF_CTRL1, 0xb300 },
	{ CM7120_STO2_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_STO3_ADC_HPF_CTRL1, 0xb300 },
	{ CM7120_STO3_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_ZCD_CTRL, 0x0000 },
	{ CM7120_IL_CMD1, 0x0008 },
	{ CM7120_IL_CMD2, 0x00c0 },
	{ CM7120_IL_CMD3, 0x6724 },
	{ CM7120_IL_CMD4, 0x3131 },
	{ CM7120_4BTN_IL_CMD1, 0x0008 },
	{ CM7120_4BTN_IL_CMD2, 0x4000 },
	{ CM7120_4BTN_IL_CMD3, 0x3131 },
	{ CM7120_PS_IL_CMD1, 0x402c },
	{ CM7120_DSP_OUTB_0123_MIXER_CTRL, 0xf8f8 },
	{ CM7120_DSP_OUTB_45_MIXER_CTRL, 0xf8f8 },
	{ CM7120_DSP_OUTB_67_MIXER_CTRL, 0xf8f8 },
	{ CM7120_MCLK_GATING_CTRL, 0x0000 },
	{ CM7120_VENDOR_ID, 0x0000 },
	{ CM7120_VENDOR_ID1, 0x10ec },
	{ CM7120_VENDOR_ID2, 0x6385 },
	{ CM7120_PDM_OUTPUT_CTRL, 0xc0c0 },
	{ CM7120_PDM1_CTRL1, 0x0000 },
	{ CM7120_PDM1_CTRL2, 0x0000 },
	{ CM7120_PDM1_CTRL3, 0x0000 },
	{ CM7120_PDM1_CTRL4, 0x0000 },
	{ CM7120_PDM1_CTRL5, 0x0000 },
	{ CM7120_PDM2_CTRL1, 0x0000 },
	{ CM7120_PDM2_CTRL2, 0x0000 },
	{ CM7120_PDM2_CTRL3, 0x0000 },
	{ CM7120_PDM2_CTRL4, 0x0000 },
	{ CM7120_PDM2_CTRL5, 0x0000 },
	{ CM7120_STO_DAC_POST_VOL_CTRL, 0xe400 },
	{ CM7120_ST_CTRL, 0x000b },
	{ CM7120_MCLK_DET_PROTECT_CTRL, 0x0000 },
	{ CM7120_STO_HP_NG2_CTRL1, 0x1d22 },
	{ CM7120_STO_HP_NG2_CTRL2, 0x0003 },
	{ CM7120_STO_HP_NG2_CTRL3, 0x0003 },
	{ CM7120_STO_HP_NG2_CTRL4, 0x0020 },
	{ CM7120_STO_HP_NG2_CTRL5, 0x0080 },
	{ CM7120_STO_HP_NG2_CTRL6, 0x0800 },
	{ CM7120_STO_HP_NG2_ST1, 0x0000 },
	{ CM7120_STO_HP_NG2_ST2, 0x0000 },
	{ CM7120_STO_HP_NG2_ST3, 0x0000 },
	{ CM7120_NG2_ENV_DITHER_CTRL, 0x0000 },
	{ CM7120_MONO_AMP_NG2_CTRL1, 0x1d1f },
	{ CM7120_MONO_AMP_NG2_CTRL2, 0x0000 },
	{ CM7120_MONO_AMP_NG2_CTRL3, 0x0020 },
	{ CM7120_MONO_AMP_NG2_CTRL4, 0x0080 },
	{ CM7120_MONO_AMP_NG2_CTRL5, 0x0800 },
	{ CM7120_MONO_AMP_NG2_ST1, 0x0000 },
	{ CM7120_MONO_AMP_NG2_ST2, 0x0000 },
	{ CM7120_IF_INPUT_DET_ST1, 0x0000 },
	{ CM7120_IF_INPUT_DET_ST2, 0x0000 },
	{ CM7120_IF_INPUT_DET_ST3, 0x0000 },
	{ CM7120_STO_DAC_SIL_DET_CTRL, 0x4131 },
	{ CM7120_MONO_DACL_SIL_DET_CTRL, 0x4131 },
	{ CM7120_MONO_DACR_SIL_DET_CTRL, 0x4131 },
	{ CM7120_DD_MIXERL_SIL_DET_CTRL, 0x4131 },
	{ CM7120_DD_MIXERR_SIL_DET_CTRL, 0x4131 },
	{ CM7120_SIL_DET_CTRLOUTPUT1, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT2, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT3, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT4, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT5, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT6, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT7, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT8, 0x0000 },
	{ CM7120_ADC_EQ_CTRL1, 0x6000 },
	{ CM7120_ADC_EQ_CTRL2, 0x0000 },
	{ CM7120_DAC_EQ_CTRL1, 0xc000 },
	{ CM7120_DAC_EQ_CTRL2, 0x0000 },
	{ CM7120_DAC_EQ_CTRL3, 0x0000 },
	{ CM7120_DAC_EQ_CTRL4, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL1, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL2, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL3, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL4, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL5, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL6, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL7, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL8, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL9, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL10, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL11, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL12, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL13, 0x0001 },
	{ CM7120_HP_DECR_DECOUP_CTRL1, 0x4b38 },
	{ CM7120_HP_DECR_DECOUP_CTRL2, 0x0000 },
	{ CM7120_HP_DECR_DECOUP_CTRL3, 0x0000 },
	{ CM7120_HP_DECR_DECOUP_CTRL4, 0x0030 },
	{ CM7120_VAD_ADC_FILTER_CTRL1, 0x882f },
	{ CM7120_VAD_ADC_FILTER_CTRL2, 0x0000 },
	{ CM7120_VAD_CLK_SETTING1, 0x0700 },
	{ CM7120_VAD_CLK_SETTING2, 0x0242 },
	{ CM7120_VAD_ADC_PLL3_CTRL1, 0x0e22 },
	{ CM7120_VAD_ADC_PLL3_CTRL2, 0x0001 },
	{ CM7120_HP_BL_CTRL1, 0x0000 },
	{ CM7120_HP_BL_CTRL2, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL1, 0x433d },
	{ CM7120_HP_IMP_SENS_CTRL2, 0x02a0 },
	{ CM7120_HP_IMP_SENS_CTRL3, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL4, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL5, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL6, 0x0009 },
	{ CM7120_HP_IMP_SENS_CTRL7, 0x0018 },
	{ CM7120_HP_IMP_SENS_CTRL8, 0x002a },
	{ CM7120_HP_IMP_SENS_CTRL9, 0x004c },
	{ CM7120_HP_IMP_SENS_CTRL10, 0x0097 },
	{ CM7120_HP_IMP_SENS_CTRL11, 0x01c3 },
	{ CM7120_HP_IMP_SENS_CTRL12, 0x03e9 },
	{ CM7120_HP_IMP_SENS_CTRL13, 0x1389 },
	{ CM7120_HP_IMP_SENS_CTRL14, 0xc351 },
	{ CM7120_HP_IMP_SENS_CTRL15, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL16, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL17, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL18, 0x0000 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL1, 0x40af },
	{ CM7120_HP_IMP_SENS_DIG_CTRL2, 0x0702 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL3, 0x0000 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL4, 0x0000 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL5, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL6, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL7, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL8, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL9, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL10, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL11, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL12, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL13, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL14, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL15, 0x003c },
	{ CM7120_HP_IMP_SENS_DIG_CTRL16, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL17, 0x0000 },
	{ CM7120_ALC_PGA_CTRL1, 0x5334 },
	{ CM7120_ALC_PGA_CTRL2, 0x18e0 },
	{ CM7120_ALC_PGA_CTRL3, 0x8728 },
	{ CM7120_ALC_PGA_CTRL4, 0x7418 },
	{ CM7120_ALC_PGA_CTRL5, 0x901f },
	{ CM7120_ALC_PGA_CTRL6, 0x4500 },
	{ CM7120_ALC_PGA_CTRL7, 0x5100 },
	{ CM7120_ALC_PGA_ST1, 0x0000 },
	{ CM7120_ALC_PGA_ST2, 0x0000 },
	{ CM7120_ALC_PGA_ST3, 0x0000 },
	{ CM7120_ALC_PGA_SOURCE_CTRL1, 0x0501 },
	{ CM7120_HAPTIC_GEN_CTRL1, 0x0111 },
	{ CM7120_HAPTIC_GEN_CTRL2, 0x0064 },
	{ CM7120_HAPTIC_GEN_CTRL3, 0xef0e },
	{ CM7120_HAPTIC_GEN_CTRL4, 0xf0f0 },
	{ CM7120_HAPTIC_GEN_CTRL5, 0xef0e },
	{ CM7120_HAPTIC_GEN_CTRL6, 0xf0f0 },
	{ CM7120_HAPTIC_GEN_CTRL7, 0xef0e },
	{ CM7120_HAPTIC_GEN_CTRL8, 0xf0f0 },
	{ CM7120_HAPTIC_GEN_CTRL9, 0xf000 },
	{ CM7120_HAPTIC_GEN_CTRL10, 0x0000 },
	{ CM7120_AUTO_RC_CLK_CTRL1, 0x0000 },
	{ CM7120_AUTO_RC_CLK_CTRL2, 0x0000 },
	{ CM7120_AUTO_RC_CLK_CTRL3, 0x0000 },
	{ CM7120_DAC_L_EQ_LPF1_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_LPF1_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_LPF1_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_LPF1_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_LPF2_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_LPF2_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_LPF2_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_LPF2_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF1_A1, 0xc882 },
	{ CM7120_DAC_L_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF1_A1, 0xc882 },
	{ CM7120_DAC_R_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF2_A1, 0xc882 },
	{ CM7120_DAC_L_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF2_A1, 0xc882 },
	{ CM7120_DAC_R_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF3_A1, 0xe904 },
	{ CM7120_DAC_L_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF3_A1, 0xe904 },
	{ CM7120_DAC_R_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF4_A1, 0xe904 },
	{ CM7120_DAC_L_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF4_A1, 0xe904 },
	{ CM7120_DAC_R_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF5_A1, 0xe904 },
	{ CM7120_DAC_L_EQ_BPF5_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF5_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF5_A1, 0xe904 },
	{ CM7120_DAC_R_EQ_BPF5_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF5_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_HPF2_A1, 0x2000 },
	{ CM7120_DAC_L_EQ_HPF2_A2, 0x0000 },
	{ CM7120_DAC_L_EQ_HPF2_H0, 0x2000 },
	{ CM7120_DAC_R_EQ_HPF2_A1, 0x2000 },
	{ CM7120_DAC_R_EQ_HPF2_A2, 0x0000 },
	{ CM7120_DAC_R_EQ_HPF2_H0, 0x2000 },
	{ CM7120_DAC_L_EQ_HPF3_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_HPF3_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_HPF3_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_HPF3_H0, 0x01f4 },
	{ CM7120_DAC_L_BI_EQ_H0_1, 0x0200 },
	{ CM7120_DAC_L_BI_EQ_H0_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B1_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B1_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B2_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B2_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A1_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A1_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A2_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A2_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_H0_1, 0x0200 },
	{ CM7120_DAC_R_BI_EQ_H0_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B1_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B1_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B2_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B2_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A1_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A1_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A2_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A2_2, 0x0000 },
	{ CM7120_DAC_L_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_DAC_R_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_DAC_L_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_DAC_R_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_L_EQ_LPF_A1, 0x1c10 },
	{ CM7120_ADC_L_EQ_LPF_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_LPF_A1, 0x1c10 },
	{ CM7120_ADC_R_EQ_LPF_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF1_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF1_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF2_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF2_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF3_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF3_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF4_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF4_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_ADC_L_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_ADC_R_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_R_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_L_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_R_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_PITCH_HELLO_DET_CTRL1, 0x7681 },
	{ CM7120_PITCH_HELLO_DET_CTRL2, 0x0020 },
	{ CM7120_PITCH_HELLO_DET_CTRL3, 0x7851 },
	{ CM7120_PITCH_HELLO_DET_CTRL4, 0x01f3 },
	{ CM7120_PITCH_HELLO_DET_CTRL5, 0x00fa },
	{ CM7120_PITCH_HELLO_DET_CTRL6, 0x0129 },
	{ CM7120_PITCH_HELLO_DET_CTRL7, 0x0602 },
	{ CM7120_PITCH_HELLO_DET_CTRL8, 0x0114 },
	{ CM7120_PITCH_HELLO_DET_CTRL9, 0x0010 },
	{ CM7120_PITCH_HELLO_DET_CTRL10, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL11, 0x120d },
	{ CM7120_PITCH_HELLO_DET_CTRL12, 0x0040 },
	{ CM7120_PITCH_HELLO_DET_CTRL13, 0x0040 },
	{ CM7120_PITCH_HELLO_DET_CTRL14, 0x0505 },
	{ CM7120_PITCH_HELLO_DET_CTRL15, 0x1322 },
	{ CM7120_PITCH_HELLO_DET_CTRL16, 0x2110 },
	{ CM7120_PITCH_HELLO_DET_CTRL17, 0x3040 },
	{ CM7120_PITCH_HELLO_DET_CTRL18, 0x6414 },
	{ CM7120_PITCH_HELLO_DET_CTRL19, 0x2000 },
	{ CM7120_PITCH_HELLO_DET_CTRL20, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL21, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL22, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL23, 0x0000 },
	{ CM7120_OK_DET_CTRL1, 0x4089 },
	{ CM7120_OK_DET_CTRL2, 0x0000 },
	{ CM7120_OK_DET_CTRL3, 0x0008 },
	{ CM7120_OK_DET_CTRL4, 0x0010 },
	{ CM7120_OK_DET_CTRL5, 0x0596 },
	{ CM7120_OK_DET_CTRL6, 0x0506 },
	{ CM7120_OK_DET_CTRL7, 0x0806 },
	{ CM7120_OK_DET_CTRL8, 0x1a00 },
	{ CM7120_OK_DET_CTRL9, 0x0705 },
	{ CM7120_OK_DET_CTRL10, 0x052d },
	{ CM7120_OK_DET_CTRL11, 0x180d },
	{ CM7120_OK_DET_CTRL12, 0x0009 },
	{ CM7120_OK_DET_CTRL13, 0x140a },
	{ CM7120_OK_DET_CTRL14, 0x0e4b },
	{ CM7120_OK_DET_CTRL15, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL1, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL2, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL3, 0x8060 },
	{ CM7120_DFLL_CAL_CTRL4, 0x0040 },
	{ CM7120_DFLL_CAL_CTRL5, 0x0001 },
	{ CM7120_DFLL_CAL_CTRL6, 0x0001 },
	{ CM7120_DFLL_CAL_CTRL7, 0x0400 },
	{ CM7120_DFLL_CAL_CTRL8, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL9, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL10, 0x4022 },
	{ CM7120_DFLL_CAL_CTRL11, 0x0002 },
	{ CM7120_DFLL_CAL_CTRL12, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL13, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL14, 0x0000 },
	{ CM7120_VAD_FUNCTION_CTRL1, 0x802c },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL1, 0x7fff },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL2, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL3, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL4, 0x006a },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL5, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL6, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL7, 0x0000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL1, 0x6000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL2, 0x4040 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL3, 0x4000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL4, 0x0000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL5, 0xc350 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL6, 0x0064 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL7, 0x0040 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL8, 0x0000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL9, 0x5280 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL10, 0x0001 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL11, 0x86a0 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL12, 0x0fd3 },
	{ CM7120_DAC_MULTI_DRC_MISC_CTRL, 0x3c10 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL1, 0x7dc2 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL2, 0xa178 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL3, 0x5383 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL4, 0x003e },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL5, 0x02c1 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL6, 0xd37d },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL7, 0x68d3 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL8, 0x82f6 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL9, 0xcd3b },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL10, 0x0035 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL11, 0xebf4 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL12, 0x2d6e },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL1, 0x5254 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL2, 0x0300 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL4, 0x133e },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL5, 0x32ff },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL6, 0x040c },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL7, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL8, 0x1800 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL10, 0x0045 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL11, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL12, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL1, 0x5254 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL2, 0x0300 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL4, 0x133e },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL5, 0x32ff },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL6, 0x040c },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL7, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL8, 0x1800 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL10, 0x0045 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL11, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL12, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL1, 0x5254 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL2, 0x0300 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL4, 0x133e },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL5, 0x32ff },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL6, 0x040c },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL7, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL8, 0x1800 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL10, 0x0045 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL11, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL12, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL1, 0x4951 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL2, 0x1860 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL4, 0x0032 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL5, 0x0450 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL6, 0x00ff },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL7, 0x040c },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL8, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL10, 0x8596 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL11, 0x0075 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL12, 0x0080 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL13, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_ST1, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_ST2, 0x0000 },
	{ CM7120_ADC_ALC_CTRL1, 0x4905 },
	{ CM7120_ADC_ALC_CTRL2, 0xe150 },
	{ CM7120_ADC_ALC_CTRL3, 0x0100 },
	{ CM7120_ADC_ALC_CTRL4, 0x5f5f },
	{ CM7120_ADC_ALC_CTRL5, 0x0603 },
	{ CM7120_ADC_ALC_CTRL6, 0x0022 },
	{ CM7120_ADC_ALC_CTRL7, 0x45ff },
	{ CM7120_ADC_ALC_CTRL8, 0x040c },
	{ CM7120_ADC_ALC_CTRL9, 0x7418 },
	{ CM7120_ADC_ALC_CTRL10, 0x0000 },
	{ CM7120_ADC_ALC_CTRL11, 0x0000 },
	{ CM7120_ADC_ALC_CTRL12, 0x8700 },
	{ CM7120_ADC_ALC_CTRL13, 0x5080 },
	{ CM7120_ADC_ALC_CTRL14, 0x0000 },
	{ CM7120_ADC_ALC_ST1, 0x0000 },
	{ CM7120_ADC_ALC_ST2, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL1, 0x7f08 },
	{ CM7120_HP_DC_CAL_CTRL2, 0x0030 },
	{ CM7120_HP_DC_CAL_CTRL3, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL4, 0x0261 },
	{ CM7120_HP_DC_CAL_CTRL5, 0x1c3c },
	{ CM7120_HP_DC_CAL_CTRL6, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL7, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL8, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL9, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL10, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL11, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL12, 0x0000 },
	{ CM7120_HP_DC_CAL_ST1, 0x0000 },
	{ CM7120_HP_DC_CAL_ST2, 0x0000 },
	{ CM7120_HP_DC_CAL_ST3, 0x0000 },
	{ CM7120_HP_DC_CAL_ST4, 0x0000 },
	{ CM7120_HP_DC_CAL_ST5, 0x0000 },
	{ CM7120_HP_DC_CAL_ST6, 0x0000 },
	{ CM7120_HP_DC_CAL_ST7, 0x0000 },
	{ CM7120_HP_DC_CAL_ST8, 0x0000 },
	{ CM7120_HP_DC_CAL_ST9, 0x0000 },
	{ CM7120_HP_DC_CAL_ST10, 0x0000 },
	{ CM7120_HP_DC_CAL_ST11, 0x0000 },
	{ CM7120_HP_DC_CAL_ST12, 0x0000 },
	{ CM7120_HP_DC_CAL_ST13, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL1, 0x7914 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL2, 0x0261 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL3, 0x6000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL4, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL5, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL6, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL7, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_ST1, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_ST2, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_ST3, 0x0000 },
	{ CM7120_DSP_IB_CTRL1, 0x0000 },
	{ CM7120_DSP_IB_CTRL2, 0x0000 },
	{ CM7120_DSP_IN_OB_CTRL, 0x0000 },
	{ CM7120_DSP_OB01_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_OB23_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_OB45_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_OB67_DIG_VOL, 0x2f2f },
	{ CM7120_MINI_DSP_OB01_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_IB1_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_IB1_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_IB1_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_IB1_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_IB2_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_IB2_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_IB2_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_IB2_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_IB3_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_IB3_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_IB3_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_IB3_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_OB1_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_OB1_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_OB1_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_OB1_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_OB2_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_OB2_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_OB2_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_OB2_SRC_CTRL4, 0x0800 },
	{ CM7120_HIFI_MINI_DSP_CTRL_ST, 0x0041 },
	{ CM7120_SPI_SLAVE_CRC_CHECK_CTRL, 0x0000 },
	{ CM7120_EFUSE_CTRL1, 0x0000 },
	{ CM7120_EFUSE_CTRL2, 0x0000 },
	{ CM7120_EFUSE_CTRL3, 0x0000 },
	{ CM7120_EFUSE_CTRL4, 0x0000 },
	{ CM7120_EFUSE_CTRL5, 0x0000 },
	{ CM7120_EFUSE_CTRL6, 0x0000 },
	{ CM7120_EFUSE_CTRL7, 0x0000 },
	{ CM7120_EFUSE_CTRL8, 0x0000 },
	{ CM7120_EFUSE_CTRL9, 0x0000 },
	{ CM7120_EFUSE_CTRL10, 0x0000 },
	{ CM7120_EFUSE_CTRL11, 0x0000 },
	{ CM7120_I2C_AND_SPI_SCRAM_CTRL, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY1_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY1_LSB, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY2_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY2_LSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY1_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY1_LSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY2_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY2_LSB, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_1, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_2, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_3, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_4, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_1, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_2, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_3, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_4, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_1, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_2, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_3, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_4, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_1, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_2, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_3, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_4, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL1, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL2, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL3, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL4, 0x0000 },
	{ CM7120_PR_REG_MONO_AMP_BIAS_CTRL, 0x8a69 },
	{ CM7120_PR_REG_BIAS_CTRL1, 0xaa66 },
	{ CM7120_PR_REG_BIAS_CTRL2, 0x00aa },
	{ CM7120_PR_REG_BIAS_CTRL3, 0x0666 },
	{ CM7120_PR_REG_BIAS_CTRL4, 0xaaa6 },
	{ CM7120_PR_REG_BIAS_CTRL5, 0xaaaa },
	{ CM7120_PR_REG_BIAS_CTRL6, 0xaaaa },
	{ CM7120_PR_REG_BIAS_CTRL7, 0xa666 },
	{ CM7120_PR_REG_BIAS_CTRL8, 0x4000 },
	{ CM7120_PR_REG_BIAS_CTRL9, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL10, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL11, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL12, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL13, 0xa860 },
	{ CM7120_PR_REG_ADC12_CLK_CTRL, 0xa490 },
	{ CM7120_PR_REG_ADC34_CLK_CTRL, 0xa490 },
	{ CM7120_PR_REG_ADC5_CLK_CTRL1, 0x0410 },
	{ CM7120_PR_REG_ADC5_CLK_CTRL2, 0x0000 },
	{ CM7120_PR_REG_ADC67_CLK_CTRL, 0xa490 },
	{ CM7120_PR_REG_PLL1_CTRL1, 0x3303 },
	{ CM7120_PR_REG_PLL1_CTRL2, 0x0054 },
	{ CM7120_PR_REG_PLL2_CTRL1, 0x3303 },
	{ CM7120_PR_REG_PLL2_CTRL2, 0x0054 },
	{ CM7120_PR_REG_VREF_CTRL1, 0x045f },
	{ CM7120_PR_REG_VREF_CTRL2, 0x081f },
	{ CM7120_PR_REG_BST1_CTRL, 0x0095 },
	{ CM7120_PR_REG_BST2_CTRL, 0x0095 },
	{ CM7120_PR_REG_BST3_CTRL, 0x0095 },
	{ CM7120_PR_REG_BST4_CTRL, 0x0095 },
	{ CM7120_DAC_ADC_DIG_VOL1, 0xaaa0 },
	{ CM7120_DAC_ADC_DIG_VOL2, 0xaaaa },
	{ CM7120_VAD_SRAM_TEST, 0x0000 },
	{ CM7120_PAD_DRIVING_CTRL1, 0x0000 },
	{ CM7120_PAD_DRIVING_CTRL2, 0x0000 },
	{ CM7120_PAD_DRIVING_CTRL3, 0x0003 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL1, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL2, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL3, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL4, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL5, 0x0000 },
	{ CM7120_TEST_MODE_CTRL1, 0x3002 },
	{ CM7120_TEST_MODE_CTRL2, 0x0000 },
	{ CM7120_GPIO1_GPIO3_TEST_MODE_CTRL, 0x0000 },
	{ CM7120_GPIO5_GPIO6_TEST_MODE_CTRL, 0x0000 },
	{ CM7120_GPIO6_GPIO7_TEST_MODE_CTRL, 0x0000 },
	{ CM7120_CODEC_DOMAIN_REG_RW_CTRL, 0x0000 },
	{ CM7120_DAC1_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC2_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC3_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC4_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC5_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC1_DAC2_DUMMY_REG, 0x0000 },
	{ CM7120_HP_CTRL1, 0x0000 },
	{ CM7120_HP_CTRL2, 0x30c2 },
	{ CM7120_HP_CTRL3, 0x0803 },
	{ CM7120_HP_CTRL4, 0xaaaa },
	{ CM7120_HP_CTRL5, 0x1100 },
	{ CM7120_HP_CTRL6, 0x0a54 },
	{ CM7120_LDO6_PR_CTRL1, 0x0000 },
	{ CM7120_LDO6_PR_CTRL2, 0x0002 },
	{ CM7120_LDO6_PR_CTRL3, 0x0002 },
	{ CM7120_LDO6_PR_CTRL4, 0x0000 },
	{ CM7120_LDO_AVDD1_PR_CTRL, 0x0114 },
	{ CM7120_LDO_HV2_PR_CTRL, 0x0010 },
	{ CM7120_LDO_HV3_PR_CTRL, 0x0210 },
	{ CM7120_LDO1_LDO3_LDO4_PR_CTRL, 0x0067 },
	{ CM7120_LDO8_LDO9_PR_CTRL, 0x0711 },
	{ CM7120_VREF5_L_PR_CTRL, 0x1024 },
	{ CM7120_VREF5_R_PR_CTRL, 0x1024 },
	{ CM7120_SLIMBUS_PARAMETER, 0x0000 },
	{ CM7120_SLIMBUS_RX, 0x0000 },
	{ CM7120_SLIMBUS_CTRL, 0x0000 },
	{ CM7120_LOUT_CTRL, 0x0055 },
	{ CM7120_DUMMY_REG_1, 0x0020 },
	{ CM7120_DUMMY_REG_2, 0x0000 },
	{ CM7120_DUMMY_REG_3, 0x0000 },
	{ CM7120_DUMMY_REG_4, 0x0000 },
};

/**
 * cm7120_dsp_mode_i2c_write_addr - Write value to address on DSP mode.
 * @cm7120: Private Data.
 * @addr: Address index.
 * @value: Address data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_write_addr(struct cm7120_priv *cm7120,
					  unsigned int addr, unsigned int value,
					  unsigned int opcode)
{
	struct snd_soc_component *component = cm7120->component;
	int ret;

	mutex_lock(&cm7120->dsp_lock);

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_MSB,
			   addr >> 16);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr msb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_LSB,
			   addr & 0xffff);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr lsb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_DATA_MSB,
			   value >> 16);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set data msb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_DATA_LSB,
			   value & 0xffff);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set data lsb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_OP_CODE, opcode);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set op code value: %d\n",
			ret);
		goto err;
	}

err:
	mutex_unlock(&cm7120->dsp_lock);

	return ret;
}

/**
 * cm7120_dsp_mode_i2c_read_addr - Read value from address on DSP mode.
 * cm7120: Private Data.
 * @addr: Address index.
 * @value: Address data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_read_addr(struct cm7120_priv *cm7120,
					 unsigned int addr, unsigned int *value)
{
	struct snd_soc_component *component = cm7120->component;
	int ret;
	unsigned int msb, lsb;

	mutex_lock(&cm7120->dsp_lock);

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_MSB,
			   addr >> 16);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr msb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_LSB,
			   addr & 0xffff);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr lsb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_OP_CODE, 0x0002);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set op code value: %d\n",
			ret);
		goto err;
	}

	regmap_read(cm7120->real_regmap, CM7120_DSP_I2C_DATA_MSB, &msb);
	regmap_read(cm7120->real_regmap, CM7120_DSP_I2C_DATA_LSB, &lsb);
	*value = (msb << 16) | lsb;

err:
	mutex_unlock(&cm7120->dsp_lock);

	return ret;
}

/**
 * cm7120_dsp_mode_i2c_write - Write register on DSP mode.
 * cm7120: Private Data.
 * @reg: Register index.
 * @value: Register data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_write(struct cm7120_priv *cm7120,
				     unsigned int reg, unsigned int value)
{
	return cm7120_dsp_mode_i2c_write_addr(cm7120, 0x1800c000 + reg * 2,
					      value << 16 | value, 0x1);
}

/**
 * cm7120_dsp_mode_i2c_read - Read register on DSP mode.
 * @component: SoC audio component device.
 * @reg: Register index.
 * @value: Register data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_read(struct cm7120_priv *cm7120,
				    unsigned int reg, unsigned int *value)
{
	int ret = cm7120_dsp_mode_i2c_read_addr(cm7120, 0x1800c000 + reg * 2,
						value);

	*value &= 0xffff;

	return ret;
}

static bool cm7120_volatile_register(struct device *dev, unsigned int reg)
{
	switch (reg) {
	case CM7120_RESET:
	case CM7120_SPDIF_IN_CTRL:
	case CM7120_FRAC_DIV_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL4:
	case CM7120_IRQ_ST1:
	case CM7120_IRQ_ST2:
	case CM7120_GPIO_ST1:
	case CM7120_GPIO_ST2:
	case CM7120_IL_CMD1:
	case CM7120_4BTN_IL_CMD1:
	case CM7120_PS_IL_CMD1:
	case CM7120_VENDOR_ID:
	case CM7120_VENDOR_ID1:
	case CM7120_VENDOR_ID2:
	case CM7120_PDM1_CTRL1:
	case CM7120_PDM1_CTRL2:
	case CM7120_PDM1_CTRL5:
	case CM7120_PDM2_CTRL1:
	case CM7120_PDM2_CTRL2:
	case CM7120_PDM2_CTRL5:
	case CM7120_MCLK_DET_PROTECT_CTRL:
	case CM7120_STO_HP_NG2_ST1 ... CM7120_STO_HP_NG2_ST3:
	case CM7120_MONO_AMP_NG2_ST1:
	case CM7120_MONO_AMP_NG2_ST2:
	case CM7120_IF_INPUT_DET_ST1 ... CM7120_IF_INPUT_DET_ST3:
	case CM7120_STO_DAC_SIL_DET_CTRL ... CM7120_DD_MIXERR_SIL_DET_CTRL:
	case CM7120_ADC_EQ_CTRL1:
	case CM7120_DAC_EQ_CTRL1:
	case CM7120_DAC_EQ_CTRL2:
	case CM7120_I2S_MASTER_CLK_CTRL5:
	case CM7120_I2S_MASTER_CLK_CTRL7:
	case CM7120_I2S_MASTER_CLK_CTRL9:
	case CM7120_I2S_MASTER_CLK_CTRL11:
	case CM7120_I2S_MASTER_CLK_CTRL13:
	case CM7120_VAD_CLK_SETTING1:
	case CM7120_VAD_ADC_PLL3_CTRL2:
	case CM7120_HP_IMP_SENS_CTRL1:
	case CM7120_HP_IMP_SENS_CTRL3 ... CM7120_HP_IMP_SENS_CTRL5:
	case CM7120_HP_IMP_SENS_DIG_CTRL2:
	case CM7120_HP_IMP_SENS_DIG_CTRL16:
	case CM7120_HP_IMP_SENS_DIG_CTRL17:
	case CM7120_ALC_PGA_ST1 ... CM7120_ALC_PGA_ST3:
	case CM7120_HAPTIC_GEN_CTRL1:
	case CM7120_HAPTIC_GEN_CTRL2:
	case CM7120_PITCH_HELLO_DET_CTRL1:
	case CM7120_PITCH_HELLO_DET_CTRL19:
	case CM7120_PITCH_HELLO_DET_CTRL20:
	case CM7120_PITCH_HELLO_DET_CTRL22:
	case CM7120_PITCH_HELLO_DET_CTRL23:
	case CM7120_OK_DET_CTRL1:
	case CM7120_OK_DET_CTRL2:
	case CM7120_OK_DET_CTRL15:
	case CM7120_DFLL_CAL_CTRL2:
	case CM7120_DFLL_CAL_CTRL10:
	case CM7120_DFLL_CAL_CTRL12 ... CM7120_DFLL_CAL_CTRL14:
	case CM7120_VAD_FUNCTION_CTRL1:
	case CM7120_DELAY_BUFFER_SRAM_CTRL2:
	case CM7120_DELAY_BUFFER_SRAM_CTRL3:
	case CM7120_DELAY_BUFFER_SRAM_CTRL5:
	case CM7120_DELAY_BUFFER_SRAM_CTRL6:
	case CM7120_DMIC_CLK_ON_OFF_CTRL12:
	case CM7120_DAC_MULTI_DRC_HB_CTRL9:
	case CM7120_DAC_MULTI_DRC_HB_CTRL11:
	case CM7120_DAC_MULTI_DRC_HB_CTRL12:
	case CM7120_DAC_MULTI_DRC_MB_CTRL9:
	case CM7120_DAC_MULTI_DRC_MB_CTRL11:
	case CM7120_DAC_MULTI_DRC_MB_CTRL12:
	case CM7120_DAC_MULTI_DRC_BB_CTRL9:
	case CM7120_DAC_MULTI_DRC_BB_CTRL11:
	case CM7120_DAC_MULTI_DRC_BB_CTRL12:
	case CM7120_DAC_MULTI_DRC_POS_ST1:
	case CM7120_DAC_MULTI_DRC_POS_ST2:
	case CM7120_ADC_ALC_ST1:
	case CM7120_ADC_ALC_ST2:
	case CM7120_HP_DC_CAL_CTRL1:
	case CM7120_HP_DC_CAL_CTRL10:
	case CM7120_HP_DC_CAL_ST1 ... CM7120_HP_DC_CAL_ST13:
	case CM7120_MONO_AMP_DC_CAL_CTRL1:
	case CM7120_MONO_AMP_DC_CAL_CTRL5:
	case CM7120_MONO_AMP_DC_CAL_ST1 ... CM7120_MONO_AMP_DC_CAL_ST3:
	case CM7120_HIFI_MINI_DSP_CTRL_ST:
	case CM7120_SPI_SLAVE_CRC_CHECK_CTRL:
	case CM7120_EFUSE_CTRL1:
	case CM7120_EFUSE_CTRL6 ... CM7120_EFUSE_CTRL9:
	case CM7120_EFUSE_CTRL11:
	case CM7120_SLIMBUS_PARAMETER:
	case CM7120_DUMMY_REG_1:
		return true;

	default:
		return false;
	}
}

static bool cm7120_readable_register(struct device *dev, unsigned int reg)
{
	switch (reg) {
	case CM7120_RESET:
	case CM7120_LOUT:
	case CM7120_HP_OUT:
	case CM7120_MONO_OUT:
	case CM7120_BST12_CTRL:
	case CM7120_BST34_CTRL:
	case CM7120_VAD_INBUF_CTRL:
	case CM7120_CAL_ADC_MIXER_CTRL:
	case CM7120_MICBIAS1_CTRL1:
	case CM7120_MICBIAS1_CTRL2:
	case CM7120_DAC1_POST_DIG_VOL:
	case CM7120_DAC1_DIG_VOL:
	case CM7120_DAC2_DIG_VOL:
	case CM7120_DAC3_DIG_VOL:
	case CM7120_STO1_ADC_DIG_VOL:
	case CM7120_MONO_ADC_DIG_VOL:
	case CM7120_STO2_ADC_DIG_VOL:
	case CM7120_STO3_ADC_DIG_VOL:
	case CM7120_ADC_BST_GAIN_CTRL1:
	case CM7120_ADC_BST_GAIN_CTRL2:
	case CM7120_ADC_BST_GAIN_CTRL3:
	case CM7120_SPDIF_IN_CTRL:
	case CM7120_IF3_DATA_CTRL:
	case CM7120_IF4_DATA_CTRL:
	case CM7120_IF5_DATA_CTRL:
	case CM7120_TDM1_CTRL1:
	case CM7120_TDM1_CTRL2:
	case CM7120_TDM1_CTRL3:
	case CM7120_TDM1_CTRL4:
	case CM7120_TDM1_CTRL5:
	case CM7120_TDM1_CTRL6:
	case CM7120_TDM1_CTRL7:
	case CM7120_TDM2_CTRL1:
	case CM7120_TDM2_CTRL2:
	case CM7120_TDM2_CTRL3:
	case CM7120_TDM2_CTRL4:
	case CM7120_TDM2_CTRL5:
	case CM7120_TDM2_CTRL6:
	case CM7120_TDM2_CTRL7:
	case CM7120_STO1_DAC_MIXER_CTRL1:
	case CM7120_STO1_DAC_MIXER_CTRL2:
	case CM7120_MONO_DAC_MIXER_CTRL1:
	case CM7120_MONO_DAC_MIXER_CTRL2:
	case CM7120_DD_MIXER_CTRL1:
	case CM7120_DD_MIXER_CTRL2:
	case CM7120_DAC1_MIXER_CTRL:
	case CM7120_DAC2_MIXER_CTRL:
	case CM7120_DAC3_MIXER_CTRL:
	case CM7120_DAC_SOURCE_CTRL:
	case CM7120_STO1_ADC_MIXER_CTRL:
	case CM7120_MONO_ADC_MIXER_CTRL1:
	case CM7120_MONO_ADC_MIXER_CTRL2:
	case CM7120_STO2_ADC_MIXER_CTRL:
	case CM7120_STO3_ADC_MIXER_CTRL:
	case CM7120_DMIC_CTRL1:
	case CM7120_DMIC_CTRL2:
	case CM7120_HPF_CTRL1:
	case CM7120_SV_ZCD_CTRL1:
	case CM7120_PWR_ADC:
	case CM7120_PWR_DIG1:
	case CM7120_PWR_DIG2:
	case CM7120_PWR_ANA1:
	case CM7120_PWR_ANA2:
	case CM7120_PWR_DSP:
	case CM7120_PWR_LDO1:
	case CM7120_PWR_LDO2:
	case CM7120_PWR_LDO3:
	case CM7120_PWR_LDO4:
	case CM7120_PWR_LDO5:
	case CM7120_I2S1_SDP:
	case CM7120_I2S2_SDP:
	case CM7120_I2S3_SDP:
	case CM7120_I2S4_SDP:
	case CM7120_I2S5_SDP:
	case CM7120_I2S_LRCK_BCLK_SOURCE:
	case CM7120_CLK_TREE_CTRL1:
	case CM7120_CLK_TREE_CTRL2:
	case CM7120_CLK_TREE_CTRL3:
	case CM7120_CLK_TREE_CTRL4:
	case CM7120_PLL1_CTRL1:
	case CM7120_PLL1_CTRL2:
	case CM7120_PLL2_CTRL1:
	case CM7120_PLL2_CTRL2:
	case CM7120_DSP_CLK_SOURCE1:
	case CM7120_DSP_CLK_SOURCE2:
	case CM7120_GLB_CLK1:
	case CM7120_GLB_CLK2:
	case CM7120_ASRC1:
	case CM7120_ASRC2:
	case CM7120_ASRC3:
	case CM7120_ASRC4:
	case CM7120_ASRC5:
	case CM7120_ASRC6:
	case CM7120_ASRC7:
	case CM7120_ASRC8:
	case CM7120_ASRC9:
	case CM7120_ASRC10:
	case CM7120_ASRC11:
	case CM7120_ASRC12:
	case CM7120_ASRC13:
	case CM7120_ASRC14:
	case CM7120_ASRC15:
	case CM7120_ASRC16:
	case CM7120_ASRC17:
	case CM7120_ASRC18:
	case CM7120_ASRC19:
	case CM7120_ASRC20:
	case CM7120_ASRC21:
	case CM7120_ASRC22:
	case CM7120_ASRC23:
	case CM7120_ASRC24:
	case CM7120_ASRC25:
	case CM7120_FRAC_DIV_CTRL1:
	case CM7120_FRAC_DIV_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL1:
	case CM7120_JACK_MIC_DET_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL3:
	case CM7120_JACK_MIC_DET_CTRL4:
	case CM7120_JACK_DET_CTRL1:
	case CM7120_JACK_DET_CTRL2:
	case CM7120_JACK_DET_CTRL3:
	case CM7120_JACK_DET_CTRL4:
	case CM7120_JACK_DET_CTRL5:
	case CM7120_IRQ_ST1:
	case CM7120_IRQ_ST2:
	case CM7120_IRQ_CTRL1:
	case CM7120_IRQ_CTRL2:
	case CM7120_IRQ_CTRL3:
	case CM7120_IRQ_CTRL4:
	case CM7120_IRQ_CTRL5:
	case CM7120_IRQ_CTRL6:
	case CM7120_IRQ_CTRL7:
	case CM7120_IRQ_CTRL8:
	case CM7120_IRQ_CTRL9:
	case CM7120_MF_PIN_CTRL1:
	case CM7120_MF_PIN_CTRL2:
	case CM7120_MF_PIN_CTRL3:
	case CM7120_GPIO_CTRL1:
	case CM7120_GPIO_CTRL2:
	case CM7120_GPIO_CTRL3:
	case CM7120_GPIO_CTRL4:
	case CM7120_GPIO_CTRL5:
	case CM7120_GPIO_CTRL6:
	case CM7120_GPIO_ST1:
	case CM7120_GPIO_ST2:
	case CM7120_LP_DET_CTRL:
	case CM7120_STO1_ADC_HPF_CTRL1:
	case CM7120_STO1_ADC_HPF_CTRL2:
	case CM7120_MONO_ADC_HPF_CTRL1:
	case CM7120_MONO_ADC_HPF_CTRL2:
	case CM7120_STO2_ADC_HPF_CTRL1:
	case CM7120_STO2_ADC_HPF_CTRL2:
	case CM7120_STO3_ADC_HPF_CTRL1:
	case CM7120_STO3_ADC_HPF_CTRL2:
	case CM7120_ZCD_CTRL:
	case CM7120_IL_CMD1:
	case CM7120_IL_CMD2:
	case CM7120_IL_CMD3:
	case CM7120_IL_CMD4:
	case CM7120_4BTN_IL_CMD1:
	case CM7120_4BTN_IL_CMD2:
	case CM7120_4BTN_IL_CMD3:
	case CM7120_PS_IL_CMD1:
	case CM7120_DSP_OUTB_0123_MIXER_CTRL:
	case CM7120_DSP_OUTB_45_MIXER_CTRL:
	case CM7120_DSP_OUTB_67_MIXER_CTRL:
	case CM7120_MCLK_GATING_CTRL:
	case CM7120_VENDOR_ID:
	case CM7120_VENDOR_ID1:
	case CM7120_VENDOR_ID2:
	case CM7120_PDM_OUTPUT_CTRL:
	case CM7120_PDM1_CTRL1:
	case CM7120_PDM1_CTRL2:
	case CM7120_PDM1_CTRL3:
	case CM7120_PDM1_CTRL4:
	case CM7120_PDM1_CTRL5:
	case CM7120_PDM2_CTRL1:
	case CM7120_PDM2_CTRL2:
	case CM7120_PDM2_CTRL3:
	case CM7120_PDM2_CTRL4:
	case CM7120_PDM2_CTRL5:
	case CM7120_STO_DAC_POST_VOL_CTRL:
	case CM7120_ST_CTRL:
	case CM7120_MCLK_DET_PROTECT_CTRL:
	case CM7120_STO_HP_NG2_CTRL1:
	case CM7120_STO_HP_NG2_CTRL2:
	case CM7120_STO_HP_NG2_CTRL3:
	case CM7120_STO_HP_NG2_CTRL4:
	case CM7120_STO_HP_NG2_CTRL5:
	case CM7120_STO_HP_NG2_CTRL6:
	case CM7120_STO_HP_NG2_ST1:
	case CM7120_STO_HP_NG2_ST2:
	case CM7120_STO_HP_NG2_ST3:
	case CM7120_NG2_ENV_DITHER_CTRL:
	case CM7120_MONO_AMP_NG2_CTRL1:
	case CM7120_MONO_AMP_NG2_CTRL2:
	case CM7120_MONO_AMP_NG2_CTRL3:
	case CM7120_MONO_AMP_NG2_CTRL4:
	case CM7120_MONO_AMP_NG2_CTRL5:
	case CM7120_MONO_AMP_NG2_ST1:
	case CM7120_MONO_AMP_NG2_ST2:
	case CM7120_IF_INPUT_DET_ST1:
	case CM7120_IF_INPUT_DET_ST2:
	case CM7120_IF_INPUT_DET_ST3:
	case CM7120_STO_DAC_SIL_DET_CTRL:
	case CM7120_MONO_DACL_SIL_DET_CTRL:
	case CM7120_MONO_DACR_SIL_DET_CTRL:
	case CM7120_DD_MIXERL_SIL_DET_CTRL:
	case CM7120_DD_MIXERR_SIL_DET_CTRL:
	case CM7120_SIL_DET_CTRLOUTPUT1:
	case CM7120_SIL_DET_CTRLOUTPUT2:
	case CM7120_SIL_DET_CTRLOUTPUT3:
	case CM7120_SIL_DET_CTRLOUTPUT4:
	case CM7120_SIL_DET_CTRLOUTPUT5:
	case CM7120_SIL_DET_CTRLOUTPUT6:
	case CM7120_SIL_DET_CTRLOUTPUT7:
	case CM7120_SIL_DET_CTRLOUTPUT8:
	case CM7120_ADC_EQ_CTRL1:
	case CM7120_ADC_EQ_CTRL2:
	case CM7120_DAC_EQ_CTRL1:
	case CM7120_DAC_EQ_CTRL2:
	case CM7120_DAC_EQ_CTRL3:
	case CM7120_DAC_EQ_CTRL4:
	case CM7120_I2S_MASTER_CLK_CTRL1:
	case CM7120_I2S_MASTER_CLK_CTRL2:
	case CM7120_I2S_MASTER_CLK_CTRL3:
	case CM7120_I2S_MASTER_CLK_CTRL4:
	case CM7120_I2S_MASTER_CLK_CTRL5:
	case CM7120_I2S_MASTER_CLK_CTRL6:
	case CM7120_I2S_MASTER_CLK_CTRL7:
	case CM7120_I2S_MASTER_CLK_CTRL8:
	case CM7120_I2S_MASTER_CLK_CTRL9:
	case CM7120_I2S_MASTER_CLK_CTRL10:
	case CM7120_I2S_MASTER_CLK_CTRL11:
	case CM7120_I2S_MASTER_CLK_CTRL12:
	case CM7120_I2S_MASTER_CLK_CTRL13:
	case CM7120_HP_DECR_DECOUP_CTRL1:
	case CM7120_HP_DECR_DECOUP_CTRL2:
	case CM7120_HP_DECR_DECOUP_CTRL3:
	case CM7120_HP_DECR_DECOUP_CTRL4:
	case CM7120_VAD_ADC_FILTER_CTRL1:
	case CM7120_VAD_ADC_FILTER_CTRL2:
	case CM7120_VAD_CLK_SETTING1:
	case CM7120_VAD_CLK_SETTING2:
	case CM7120_VAD_ADC_PLL3_CTRL1:
	case CM7120_VAD_ADC_PLL3_CTRL2:
	case CM7120_HP_BL_CTRL1:
	case CM7120_HP_BL_CTRL2:
	case CM7120_HP_IMP_SENS_CTRL1:
	case CM7120_HP_IMP_SENS_CTRL2:
	case CM7120_HP_IMP_SENS_CTRL3:
	case CM7120_HP_IMP_SENS_CTRL4:
	case CM7120_HP_IMP_SENS_CTRL5:
	case CM7120_HP_IMP_SENS_CTRL6:
	case CM7120_HP_IMP_SENS_CTRL7:
	case CM7120_HP_IMP_SENS_CTRL8:
	case CM7120_HP_IMP_SENS_CTRL9:
	case CM7120_HP_IMP_SENS_CTRL10:
	case CM7120_HP_IMP_SENS_CTRL11:
	case CM7120_HP_IMP_SENS_CTRL12:
	case CM7120_HP_IMP_SENS_CTRL13:
	case CM7120_HP_IMP_SENS_CTRL14:
	case CM7120_HP_IMP_SENS_CTRL15:
	case CM7120_HP_IMP_SENS_CTRL16:
	case CM7120_HP_IMP_SENS_CTRL17:
	case CM7120_HP_IMP_SENS_CTRL18:
	case CM7120_HP_IMP_SENS_DIG_CTRL1:
	case CM7120_HP_IMP_SENS_DIG_CTRL2:
	case CM7120_HP_IMP_SENS_DIG_CTRL3:
	case CM7120_HP_IMP_SENS_DIG_CTRL4:
	case CM7120_HP_IMP_SENS_DIG_CTRL5:
	case CM7120_HP_IMP_SENS_DIG_CTRL6:
	case CM7120_HP_IMP_SENS_DIG_CTRL7:
	case CM7120_HP_IMP_SENS_DIG_CTRL8:
	case CM7120_HP_IMP_SENS_DIG_CTRL9:
	case CM7120_HP_IMP_SENS_DIG_CTRL10:
	case CM7120_HP_IMP_SENS_DIG_CTRL11:
	case CM7120_HP_IMP_SENS_DIG_CTRL12:
	case CM7120_HP_IMP_SENS_DIG_CTRL13:
	case CM7120_HP_IMP_SENS_DIG_CTRL14:
	case CM7120_HP_IMP_SENS_DIG_CTRL15:
	case CM7120_HP_IMP_SENS_DIG_CTRL16:
	case CM7120_HP_IMP_SENS_DIG_CTRL17:
	case CM7120_ALC_PGA_CTRL1:
	case CM7120_ALC_PGA_CTRL2:
	case CM7120_ALC_PGA_CTRL3:
	case CM7120_ALC_PGA_CTRL4:
	case CM7120_ALC_PGA_CTRL5:
	case CM7120_ALC_PGA_CTRL6:
	case CM7120_ALC_PGA_CTRL7:
	case CM7120_ALC_PGA_ST1:
	case CM7120_ALC_PGA_ST2:
	case CM7120_ALC_PGA_ST3:
	case CM7120_ALC_PGA_SOURCE_CTRL1:
	case CM7120_HAPTIC_GEN_CTRL1:
	case CM7120_HAPTIC_GEN_CTRL2:
	case CM7120_HAPTIC_GEN_CTRL3:
	case CM7120_HAPTIC_GEN_CTRL4:
	case CM7120_HAPTIC_GEN_CTRL5:
	case CM7120_HAPTIC_GEN_CTRL6:
	case CM7120_HAPTIC_GEN_CTRL7:
	case CM7120_HAPTIC_GEN_CTRL8:
	case CM7120_HAPTIC_GEN_CTRL9:
	case CM7120_HAPTIC_GEN_CTRL10:
	case CM7120_AUTO_RC_CLK_CTRL1:
	case CM7120_AUTO_RC_CLK_CTRL2:
	case CM7120_AUTO_RC_CLK_CTRL3:
	case CM7120_DAC_L_EQ_LPF1_A1:
	case CM7120_DAC_L_EQ_LPF1_H0:
	case CM7120_DAC_R_EQ_LPF1_A1:
	case CM7120_DAC_R_EQ_LPF1_H0:
	case CM7120_DAC_L_EQ_LPF2_A1:
	case CM7120_DAC_L_EQ_LPF2_H0:
	case CM7120_DAC_R_EQ_LPF2_A1:
	case CM7120_DAC_R_EQ_LPF2_H0:
	case CM7120_DAC_L_EQ_BPF1_A1:
	case CM7120_DAC_L_EQ_BPF1_A2:
	case CM7120_DAC_L_EQ_BPF1_H0:
	case CM7120_DAC_R_EQ_BPF1_A1:
	case CM7120_DAC_R_EQ_BPF1_A2:
	case CM7120_DAC_R_EQ_BPF1_H0:
	case CM7120_DAC_L_EQ_BPF2_A1:
	case CM7120_DAC_L_EQ_BPF2_A2:
	case CM7120_DAC_L_EQ_BPF2_H0:
	case CM7120_DAC_R_EQ_BPF2_A1:
	case CM7120_DAC_R_EQ_BPF2_A2:
	case CM7120_DAC_R_EQ_BPF2_H0:
	case CM7120_DAC_L_EQ_BPF3_A1:
	case CM7120_DAC_L_EQ_BPF3_A2:
	case CM7120_DAC_L_EQ_BPF3_H0:
	case CM7120_DAC_R_EQ_BPF3_A1:
	case CM7120_DAC_R_EQ_BPF3_A2:
	case CM7120_DAC_R_EQ_BPF3_H0:
	case CM7120_DAC_L_EQ_BPF4_A1:
	case CM7120_DAC_L_EQ_BPF4_A2:
	case CM7120_DAC_L_EQ_BPF4_H0:
	case CM7120_DAC_R_EQ_BPF4_A1:
	case CM7120_DAC_R_EQ_BPF4_A2:
	case CM7120_DAC_R_EQ_BPF4_H0:
	case CM7120_DAC_L_EQ_BPF5_A1:
	case CM7120_DAC_L_EQ_BPF5_A2:
	case CM7120_DAC_L_EQ_BPF5_H0:
	case CM7120_DAC_R_EQ_BPF5_A1:
	case CM7120_DAC_R_EQ_BPF5_A2:
	case CM7120_DAC_R_EQ_BPF5_H0:
	case CM7120_DAC_L_EQ_HPF1_A1:
	case CM7120_DAC_L_EQ_HPF1_H0:
	case CM7120_DAC_R_EQ_HPF1_A1:
	case CM7120_DAC_R_EQ_HPF1_H0:
	case CM7120_DAC_L_EQ_HPF2_A1:
	case CM7120_DAC_L_EQ_HPF2_A2:
	case CM7120_DAC_L_EQ_HPF2_H0:
	case CM7120_DAC_R_EQ_HPF2_A1:
	case CM7120_DAC_R_EQ_HPF2_A2:
	case CM7120_DAC_R_EQ_HPF2_H0:
	case CM7120_DAC_L_EQ_HPF3_A1:
	case CM7120_DAC_L_EQ_HPF3_H0:
	case CM7120_DAC_R_EQ_HPF3_A1:
	case CM7120_DAC_R_EQ_HPF3_H0:
	case CM7120_DAC_L_BI_EQ_H0_1:
	case CM7120_DAC_L_BI_EQ_H0_2:
	case CM7120_DAC_L_BI_EQ_B1_1:
	case CM7120_DAC_L_BI_EQ_B1_2:
	case CM7120_DAC_L_BI_EQ_B2_1:
	case CM7120_DAC_L_BI_EQ_B2_2:
	case CM7120_DAC_L_BI_EQ_A1_1:
	case CM7120_DAC_L_BI_EQ_A1_2:
	case CM7120_DAC_L_BI_EQ_A2_1:
	case CM7120_DAC_L_BI_EQ_A2_2:
	case CM7120_DAC_R_BI_EQ_H0_1:
	case CM7120_DAC_R_BI_EQ_H0_2:
	case CM7120_DAC_R_BI_EQ_B1_1:
	case CM7120_DAC_R_BI_EQ_B1_2:
	case CM7120_DAC_R_BI_EQ_B2_1:
	case CM7120_DAC_R_BI_EQ_B2_2:
	case CM7120_DAC_R_BI_EQ_A1_1:
	case CM7120_DAC_R_BI_EQ_A1_2:
	case CM7120_DAC_R_BI_EQ_A2_1:
	case CM7120_DAC_R_BI_EQ_A2_2:
	case CM7120_DAC_L_EQ_PRE_VOL_CTRL:
	case CM7120_DAC_R_EQ_PRE_VOL_CTRL:
	case CM7120_DAC_L_EQ_POST_VOL_CTRL:
	case CM7120_DAC_R_EQ_POST_VOL_CTRL:
	case CM7120_ADC_L_EQ_LPF_A1:
	case CM7120_ADC_L_EQ_LPF_H0:
	case CM7120_ADC_R_EQ_LPF_A1:
	case CM7120_ADC_R_EQ_LPF_H0:
	case CM7120_ADC_L_EQ_BPF1_A1:
	case CM7120_ADC_L_EQ_BPF1_A2:
	case CM7120_ADC_L_EQ_BPF1_H0:
	case CM7120_ADC_R_EQ_BPF1_A1:
	case CM7120_ADC_R_EQ_BPF1_A2:
	case CM7120_ADC_R_EQ_BPF1_H0:
	case CM7120_ADC_L_EQ_BPF2_A1:
	case CM7120_ADC_L_EQ_BPF2_A2:
	case CM7120_ADC_L_EQ_BPF2_H0:
	case CM7120_ADC_R_EQ_BPF2_A1:
	case CM7120_ADC_R_EQ_BPF2_A2:
	case CM7120_ADC_R_EQ_BPF2_H0:
	case CM7120_ADC_L_EQ_BPF3_A1:
	case CM7120_ADC_L_EQ_BPF3_A2:
	case CM7120_ADC_L_EQ_BPF3_H0:
	case CM7120_ADC_R_EQ_BPF3_A1:
	case CM7120_ADC_R_EQ_BPF3_A2:
	case CM7120_ADC_R_EQ_BPF3_H0:
	case CM7120_ADC_L_EQ_BPF4_A1:
	case CM7120_ADC_L_EQ_BPF4_A2:
	case CM7120_ADC_L_EQ_BPF4_H0:
	case CM7120_ADC_R_EQ_BPF4_A1:
	case CM7120_ADC_R_EQ_BPF4_A2:
	case CM7120_ADC_R_EQ_BPF4_H0:
	case CM7120_ADC_L_EQ_HPF1_A1:
	case CM7120_ADC_L_EQ_HPF1_H0:
	case CM7120_ADC_R_EQ_HPF1_A1:
	case CM7120_ADC_R_EQ_HPF1_H0:
	case CM7120_ADC_L_EQ_PRE_VOL_CTRL:
	case CM7120_ADC_R_EQ_PRE_VOL_CTRL:
	case CM7120_ADC_L_EQ_POST_VOL_CTRL:
	case CM7120_ADC_R_EQ_POST_VOL_CTRL:
	case CM7120_PITCH_HELLO_DET_CTRL1:
	case CM7120_PITCH_HELLO_DET_CTRL2:
	case CM7120_PITCH_HELLO_DET_CTRL3:
	case CM7120_PITCH_HELLO_DET_CTRL4:
	case CM7120_PITCH_HELLO_DET_CTRL5:
	case CM7120_PITCH_HELLO_DET_CTRL6:
	case CM7120_PITCH_HELLO_DET_CTRL7:
	case CM7120_PITCH_HELLO_DET_CTRL8:
	case CM7120_PITCH_HELLO_DET_CTRL9:
	case CM7120_PITCH_HELLO_DET_CTRL10:
	case CM7120_PITCH_HELLO_DET_CTRL11:
	case CM7120_PITCH_HELLO_DET_CTRL12:
	case CM7120_PITCH_HELLO_DET_CTRL13:
	case CM7120_PITCH_HELLO_DET_CTRL14:
	case CM7120_PITCH_HELLO_DET_CTRL15:
	case CM7120_PITCH_HELLO_DET_CTRL16:
	case CM7120_PITCH_HELLO_DET_CTRL17:
	case CM7120_PITCH_HELLO_DET_CTRL18:
	case CM7120_PITCH_HELLO_DET_CTRL19:
	case CM7120_PITCH_HELLO_DET_CTRL20:
	case CM7120_PITCH_HELLO_DET_CTRL21:
	case CM7120_PITCH_HELLO_DET_CTRL22:
	case CM7120_PITCH_HELLO_DET_CTRL23:
	case CM7120_OK_DET_CTRL1:
	case CM7120_OK_DET_CTRL2:
	case CM7120_OK_DET_CTRL3:
	case CM7120_OK_DET_CTRL4:
	case CM7120_OK_DET_CTRL5:
	case CM7120_OK_DET_CTRL6:
	case CM7120_OK_DET_CTRL7:
	case CM7120_OK_DET_CTRL8:
	case CM7120_OK_DET_CTRL9:
	case CM7120_OK_DET_CTRL10:
	case CM7120_OK_DET_CTRL11:
	case CM7120_OK_DET_CTRL12:
	case CM7120_OK_DET_CTRL13:
	case CM7120_OK_DET_CTRL14:
	case CM7120_OK_DET_CTRL15:
	case CM7120_DFLL_CAL_CTRL1:
	case CM7120_DFLL_CAL_CTRL2:
	case CM7120_DFLL_CAL_CTRL3:
	case CM7120_DFLL_CAL_CTRL4:
	case CM7120_DFLL_CAL_CTRL5:
	case CM7120_DFLL_CAL_CTRL6:
	case CM7120_DFLL_CAL_CTRL7:
	case CM7120_DFLL_CAL_CTRL8:
	case CM7120_DFLL_CAL_CTRL9:
	case CM7120_DFLL_CAL_CTRL10:
	case CM7120_DFLL_CAL_CTRL11:
	case CM7120_DFLL_CAL_CTRL12:
	case CM7120_DFLL_CAL_CTRL13:
	case CM7120_DFLL_CAL_CTRL14:
	case CM7120_VAD_FUNCTION_CTRL1:
	case CM7120_DELAY_BUFFER_SRAM_CTRL1:
	case CM7120_DELAY_BUFFER_SRAM_CTRL2:
	case CM7120_DELAY_BUFFER_SRAM_CTRL3:
	case CM7120_DELAY_BUFFER_SRAM_CTRL4:
	case CM7120_DELAY_BUFFER_SRAM_CTRL5:
	case CM7120_DELAY_BUFFER_SRAM_CTRL6:
	case CM7120_DELAY_BUFFER_SRAM_CTRL7:
	case CM7120_DMIC_CLK_ON_OFF_CTRL1:
	case CM7120_DMIC_CLK_ON_OFF_CTRL2:
	case CM7120_DMIC_CLK_ON_OFF_CTRL3:
	case CM7120_DMIC_CLK_ON_OFF_CTRL4:
	case CM7120_DMIC_CLK_ON_OFF_CTRL5:
	case CM7120_DMIC_CLK_ON_OFF_CTRL6:
	case CM7120_DMIC_CLK_ON_OFF_CTRL7:
	case CM7120_DMIC_CLK_ON_OFF_CTRL8:
	case CM7120_DMIC_CLK_ON_OFF_CTRL9:
	case CM7120_DMIC_CLK_ON_OFF_CTRL10:
	case CM7120_DMIC_CLK_ON_OFF_CTRL11:
	case CM7120_DMIC_CLK_ON_OFF_CTRL12:
	case CM7120_DAC_MULTI_DRC_MISC_CTRL:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL1:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL2:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL3:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL4:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL5:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL6:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL7:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL8:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL9:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL10:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL11:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL12:
	case CM7120_DAC_MULTI_DRC_HB_CTRL1:
	case CM7120_DAC_MULTI_DRC_HB_CTRL2:
	case CM7120_DAC_MULTI_DRC_HB_CTRL3:
	case CM7120_DAC_MULTI_DRC_HB_CTRL4:
	case CM7120_DAC_MULTI_DRC_HB_CTRL5:
	case CM7120_DAC_MULTI_DRC_HB_CTRL6:
	case CM7120_DAC_MULTI_DRC_HB_CTRL7:
	case CM7120_DAC_MULTI_DRC_HB_CTRL8:
	case CM7120_DAC_MULTI_DRC_HB_CTRL9:
	case CM7120_DAC_MULTI_DRC_HB_CTRL10:
	case CM7120_DAC_MULTI_DRC_HB_CTRL11:
	case CM7120_DAC_MULTI_DRC_HB_CTRL12:
	case CM7120_DAC_MULTI_DRC_MB_CTRL1:
	case CM7120_DAC_MULTI_DRC_MB_CTRL2:
	case CM7120_DAC_MULTI_DRC_MB_CTRL3:
	case CM7120_DAC_MULTI_DRC_MB_CTRL4:
	case CM7120_DAC_MULTI_DRC_MB_CTRL5:
	case CM7120_DAC_MULTI_DRC_MB_CTRL6:
	case CM7120_DAC_MULTI_DRC_MB_CTRL7:
	case CM7120_DAC_MULTI_DRC_MB_CTRL8:
	case CM7120_DAC_MULTI_DRC_MB_CTRL9:
	case CM7120_DAC_MULTI_DRC_MB_CTRL10:
	case CM7120_DAC_MULTI_DRC_MB_CTRL11:
	case CM7120_DAC_MULTI_DRC_MB_CTRL12:
	case CM7120_DAC_MULTI_DRC_BB_CTRL1:
	case CM7120_DAC_MULTI_DRC_BB_CTRL2:
	case CM7120_DAC_MULTI_DRC_BB_CTRL3:
	case CM7120_DAC_MULTI_DRC_BB_CTRL4:
	case CM7120_DAC_MULTI_DRC_BB_CTRL5:
	case CM7120_DAC_MULTI_DRC_BB_CTRL6:
	case CM7120_DAC_MULTI_DRC_BB_CTRL7:
	case CM7120_DAC_MULTI_DRC_BB_CTRL8:
	case CM7120_DAC_MULTI_DRC_BB_CTRL9:
	case CM7120_DAC_MULTI_DRC_BB_CTRL10:
	case CM7120_DAC_MULTI_DRC_BB_CTRL11:
	case CM7120_DAC_MULTI_DRC_BB_CTRL12:
	case CM7120_DAC_MULTI_DRC_POS_CTRL1:
	case CM7120_DAC_MULTI_DRC_POS_CTRL2:
	case CM7120_DAC_MULTI_DRC_POS_CTRL3:
	case CM7120_DAC_MULTI_DRC_POS_CTRL4:
	case CM7120_DAC_MULTI_DRC_POS_CTRL5:
	case CM7120_DAC_MULTI_DRC_POS_CTRL6:
	case CM7120_DAC_MULTI_DRC_POS_CTRL7:
	case CM7120_DAC_MULTI_DRC_POS_CTRL8:
	case CM7120_DAC_MULTI_DRC_POS_CTRL9:
	case CM7120_DAC_MULTI_DRC_POS_CTRL10:
	case CM7120_DAC_MULTI_DRC_POS_CTRL11:
	case CM7120_DAC_MULTI_DRC_POS_CTRL12:
	case CM7120_DAC_MULTI_DRC_POS_CTRL13:
	case CM7120_DAC_MULTI_DRC_POS_ST1:
	case CM7120_DAC_MULTI_DRC_POS_ST2:
	case CM7120_ADC_ALC_CTRL1:
	case CM7120_ADC_ALC_CTRL2:
	case CM7120_ADC_ALC_CTRL3:
	case CM7120_ADC_ALC_CTRL4:
	case CM7120_ADC_ALC_CTRL5:
	case CM7120_ADC_ALC_CTRL6:
	case CM7120_ADC_ALC_CTRL7:
	case CM7120_ADC_ALC_CTRL8:
	case CM7120_ADC_ALC_CTRL9:
	case CM7120_ADC_ALC_CTRL10:
	case CM7120_ADC_ALC_CTRL11:
	case CM7120_ADC_ALC_CTRL12:
	case CM7120_ADC_ALC_CTRL13:
	case CM7120_ADC_ALC_CTRL14:
	case CM7120_ADC_ALC_ST1:
	case CM7120_ADC_ALC_ST2:
	case CM7120_HP_DC_CAL_CTRL1:
	case CM7120_HP_DC_CAL_CTRL2:
	case CM7120_HP_DC_CAL_CTRL3:
	case CM7120_HP_DC_CAL_CTRL4:
	case CM7120_HP_DC_CAL_CTRL5:
	case CM7120_HP_DC_CAL_CTRL6:
	case CM7120_HP_DC_CAL_CTRL7:
	case CM7120_HP_DC_CAL_CTRL8:
	case CM7120_HP_DC_CAL_CTRL9:
	case CM7120_HP_DC_CAL_CTRL10:
	case CM7120_HP_DC_CAL_CTRL11:
	case CM7120_HP_DC_CAL_CTRL12:
	case CM7120_HP_DC_CAL_ST1:
	case CM7120_HP_DC_CAL_ST2:
	case CM7120_HP_DC_CAL_ST3:
	case CM7120_HP_DC_CAL_ST4:
	case CM7120_HP_DC_CAL_ST5:
	case CM7120_HP_DC_CAL_ST6:
	case CM7120_HP_DC_CAL_ST7:
	case CM7120_HP_DC_CAL_ST8:
	case CM7120_HP_DC_CAL_ST9:
	case CM7120_HP_DC_CAL_ST10:
	case CM7120_HP_DC_CAL_ST11:
	case CM7120_HP_DC_CAL_ST12:
	case CM7120_HP_DC_CAL_ST13:
	case CM7120_MONO_AMP_DC_CAL_CTRL1:
	case CM7120_MONO_AMP_DC_CAL_CTRL2:
	case CM7120_MONO_AMP_DC_CAL_CTRL3:
	case CM7120_MONO_AMP_DC_CAL_CTRL4:
	case CM7120_MONO_AMP_DC_CAL_CTRL5:
	case CM7120_MONO_AMP_DC_CAL_CTRL6:
	case CM7120_MONO_AMP_DC_CAL_CTRL7:
	case CM7120_MONO_AMP_DC_CAL_ST1:
	case CM7120_MONO_AMP_DC_CAL_ST2:
	case CM7120_MONO_AMP_DC_CAL_ST3:
	case CM7120_DSP_IB_CTRL1:
	case CM7120_DSP_IB_CTRL2:
	case CM7120_DSP_IN_OB_CTRL:
	case CM7120_DSP_OB01_DIG_VOL:
	case CM7120_DSP_OB23_DIG_VOL:
	case CM7120_DSP_OB45_DIG_VOL:
	case CM7120_DSP_OB67_DIG_VOL:
	case CM7120_MINI_DSP_OB01_DIG_VOL:
	case CM7120_DSP_IB1_SRC_CTRL1:
	case CM7120_DSP_IB1_SRC_CTRL2:
	case CM7120_DSP_IB1_SRC_CTRL3:
	case CM7120_DSP_IB1_SRC_CTRL4:
	case CM7120_DSP_IB2_SRC_CTRL1:
	case CM7120_DSP_IB2_SRC_CTRL2:
	case CM7120_DSP_IB2_SRC_CTRL3:
	case CM7120_DSP_IB2_SRC_CTRL4:
	case CM7120_DSP_IB3_SRC_CTRL1:
	case CM7120_DSP_IB3_SRC_CTRL2:
	case CM7120_DSP_IB3_SRC_CTRL3:
	case CM7120_DSP_IB3_SRC_CTRL4:
	case CM7120_DSP_OB1_SRC_CTRL1:
	case CM7120_DSP_OB1_SRC_CTRL2:
	case CM7120_DSP_OB1_SRC_CTRL3:
	case CM7120_DSP_OB1_SRC_CTRL4:
	case CM7120_DSP_OB2_SRC_CTRL1:
	case CM7120_DSP_OB2_SRC_CTRL2:
	case CM7120_DSP_OB2_SRC_CTRL3:
	case CM7120_DSP_OB2_SRC_CTRL4:
	case CM7120_HIFI_MINI_DSP_CTRL_ST:
	case CM7120_SPI_SLAVE_CRC_CHECK_CTRL:
	case CM7120_EFUSE_CTRL1:
	case CM7120_EFUSE_CTRL2:
	case CM7120_EFUSE_CTRL3:
	case CM7120_EFUSE_CTRL4:
	case CM7120_EFUSE_CTRL5:
	case CM7120_EFUSE_CTRL6:
	case CM7120_EFUSE_CTRL7:
	case CM7120_EFUSE_CTRL8:
	case CM7120_EFUSE_CTRL9:
	case CM7120_EFUSE_CTRL10:
	case CM7120_EFUSE_CTRL11:
	case CM7120_I2C_AND_SPI_SCRAM_CTRL:
	case CM7120_I2C_SCRAM_WRITE_KEY1_MSB:
	case CM7120_I2C_SCRAM_WRITE_KEY1_LSB:
	case CM7120_I2C_SCRAM_WRITE_KEY2_MSB:
	case CM7120_I2C_SCRAM_WRITE_KEY2_LSB:
	case CM7120_I2C_SCRAM_READ_KEY1_MSB:
	case CM7120_I2C_SCRAM_READ_KEY1_LSB:
	case CM7120_I2C_SCRAM_READ_KEY2_MSB:
	case CM7120_I2C_SCRAM_READ_KEY2_LSB:
	case CM7120_SPI_SCRAM_WRITE_KEY1_1:
	case CM7120_SPI_SCRAM_WRITE_KEY1_2:
	case CM7120_SPI_SCRAM_WRITE_KEY1_3:
	case CM7120_SPI_SCRAM_WRITE_KEY1_4:
	case CM7120_SPI_SCRAM_WRITE_KEY2_1:
	case CM7120_SPI_SCRAM_WRITE_KEY2_2:
	case CM7120_SPI_SCRAM_WRITE_KEY2_3:
	case CM7120_SPI_SCRAM_WRITE_KEY2_4:
	case CM7120_SPI_SCRAM_READ_KEY1_1:
	case CM7120_SPI_SCRAM_READ_KEY1_2:
	case CM7120_SPI_SCRAM_READ_KEY1_3:
	case CM7120_SPI_SCRAM_READ_KEY1_4:
	case CM7120_SPI_SCRAM_READ_KEY2_1:
	case CM7120_SPI_SCRAM_READ_KEY2_2:
	case CM7120_SPI_SCRAM_READ_KEY2_3:
	case CM7120_SPI_SCRAM_READ_KEY2_4:
	case CM7120_GPIO1_TEST_OUTPUT_SEL1:
	case CM7120_GPIO1_TEST_OUTPUT_SEL2:
	case CM7120_GPIO1_TEST_OUTPUT_SEL3:
	case CM7120_GPIO1_TEST_OUTPUT_SEL4:
	case CM7120_PR_REG_MONO_AMP_BIAS_CTRL:
	case CM7120_PR_REG_BIAS_CTRL1:
	case CM7120_PR_REG_BIAS_CTRL2:
	case CM7120_PR_REG_BIAS_CTRL3:
	case CM7120_PR_REG_BIAS_CTRL4:
	case CM7120_PR_REG_BIAS_CTRL5:
	case CM7120_PR_REG_BIAS_CTRL6:
	case CM7120_PR_REG_BIAS_CTRL7:
	case CM7120_PR_REG_BIAS_CTRL8:
	case CM7120_PR_REG_BIAS_CTRL9:
	case CM7120_PR_REG_BIAS_CTRL10:
	case CM7120_PR_REG_BIAS_CTRL11:
	case CM7120_PR_REG_BIAS_CTRL12:
	case CM7120_PR_REG_BIAS_CTRL13:
	case CM7120_PR_REG_ADC12_CLK_CTRL:
	case CM7120_PR_REG_ADC34_CLK_CTRL:
	case CM7120_PR_REG_ADC5_CLK_CTRL1:
	case CM7120_PR_REG_ADC5_CLK_CTRL2:
	case CM7120_PR_REG_ADC67_CLK_CTRL:
	case CM7120_PR_REG_PLL1_CTRL1:
	case CM7120_PR_REG_PLL1_CTRL2:
	case CM7120_PR_REG_PLL2_CTRL1:
	case CM7120_PR_REG_PLL2_CTRL2:
	case CM7120_PR_REG_VREF_CTRL1:
	case CM7120_PR_REG_VREF_CTRL2:
	case CM7120_PR_REG_BST1_CTRL:
	case CM7120_PR_REG_BST2_CTRL:
	case CM7120_PR_REG_BST3_CTRL:
	case CM7120_PR_REG_BST4_CTRL:
	case CM7120_DAC_ADC_DIG_VOL1:
	case CM7120_DAC_ADC_DIG_VOL2:
	case CM7120_VAD_SRAM_TEST:
	case CM7120_PAD_DRIVING_CTRL1:
	case CM7120_PAD_DRIVING_CTRL2:
	case CM7120_PAD_DRIVING_CTRL3:
	case CM7120_DIG_INPUT_PIN_ST_CTRL1:
	case CM7120_DIG_INPUT_PIN_ST_CTRL2:
	case CM7120_DIG_INPUT_PIN_ST_CTRL3:
	case CM7120_DIG_INPUT_PIN_ST_CTRL4:
	case CM7120_DIG_INPUT_PIN_ST_CTRL5:
	case CM7120_TEST_MODE_CTRL1:
	case CM7120_TEST_MODE_CTRL2:
	case CM7120_GPIO1_GPIO3_TEST_MODE_CTRL:
	case CM7120_GPIO5_GPIO6_TEST_MODE_CTRL:
	case CM7120_GPIO6_GPIO7_TEST_MODE_CTRL:
	case CM7120_CODEC_DOMAIN_REG_RW_CTRL:
	case CM7120_DAC1_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC2_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC3_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC4_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC5_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC1_DAC2_DUMMY_REG:
	case CM7120_HP_CTRL1:
	case CM7120_HP_CTRL2:
	case CM7120_HP_CTRL3:
	case CM7120_HP_CTRL4:
	case CM7120_HP_CTRL5:
	case CM7120_HP_CTRL6:
	case CM7120_LDO6_PR_CTRL1:
	case CM7120_LDO6_PR_CTRL2:
	case CM7120_LDO6_PR_CTRL3:
	case CM7120_LDO6_PR_CTRL4:
	case CM7120_LDO_AVDD1_PR_CTRL:
	case CM7120_LDO_HV2_PR_CTRL:
	case CM7120_LDO_HV3_PR_CTRL:
	case CM7120_LDO1_LDO3_LDO4_PR_CTRL:
	case CM7120_LDO8_LDO9_PR_CTRL:
	case CM7120_VREF5_L_PR_CTRL:
	case CM7120_VREF5_R_PR_CTRL:
	case CM7120_SLIMBUS_PARAMETER:
	case CM7120_SLIMBUS_RX:
	case CM7120_SLIMBUS_CTRL:
	case CM7120_LOUT_CTRL:
	case CM7120_DUMMY_REG_1:
	case CM7120_DUMMY_REG_2:
	case CM7120_DUMMY_REG_3:
	case CM7120_DUMMY_REG_4:
	case CM7120_DSP_I2C_DATA_MSB:
		return true;

	default:
		return false;
	}
}

static int cm7120_hp_vol_put(struct snd_kcontrol *kcontrol,
			     struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
	int ret = snd_soc_put_volsw(kcontrol, ucontrol);

	if (snd_soc_component_read32(component, CM7120_STO_HP_NG2_CTRL1) &
	    0x8000) {
		snd_soc_component_update_bits(
			component, CM7120_STO_HP_NG2_CTRL1, 0x8000, 0x0000);
		snd_soc_component_update_bits(
			component, CM7120_STO_HP_NG2_CTRL1, 0x8000, 0x8000);
	}

	return ret;
}

static const DECLARE_TLV_DB_SCALE(ng2_vol_tlv, -2325, 75, 0);
/* 0x16, min = -65.625dB, step = 0.375dB */
static const DECLARE_TLV_DB_SCALE(dachp_vol_tlv, -65625, 375, 0);
/* 0x0505, min = -17.625dB, step = 0.375dB */
static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -17625, 375, 0);
static const DECLARE_TLV_DB_SCALE(bst_tlv, -1200, 75, 0);
static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -17625, 375, 0);
static const DECLARE_TLV_DB_SCALE(adc_bst_tlv, 0, 1200, 0);
static const DECLARE_TLV_DB_SCALE(eq_pre_tlv, -1200, 100, 0);
static const DECLARE_TLV_DB_SCALE(eq_vol_tlv, -2000, 100, 0);

static const struct snd_kcontrol_new cm7120_snd_controls[] = {
	/* Headphone Output Volume */
	SOC_DOUBLE_R_EXT_TLV("Headphone Analog Volume", CM7120_STO_HP_NG2_CTRL2,
			     CM7120_STO_HP_NG2_CTRL3, CM7120_G_HP_SFT, 34, 1,
			     snd_soc_get_volsw, cm7120_hp_vol_put, ng2_vol_tlv),

	/* DAC Digital Volume */
	SOC_DOUBLE_TLV("Headphone Volume",
		       CM7120_DAC1_DIG_VOL, /* 0x15,  65625 / 375 = 175 */
		       CM7120_L_VOL_SFT, CM7120_R_VOL_SFT, 175, 0,
		       dachp_vol_tlv),
	SOC_DOUBLE_TLV(
		"Speaker Left Channel Volume",
		CM7120_DSP_OB45_DIG_VOL,
		/* 0x0505, [30000 - (-17625)] / 375 = 127 */
		CM7120_L_VOL_SFT, CM7120_R_VOL_SFT, 127, 0, dac_vol_tlv),
	SOC_DOUBLE_TLV("Speaker Right Channel Volume",
		       CM7120_DSP_OB67_DIG_VOL, /* 0x0506 */
		       CM7120_L_VOL_SFT, CM7120_R_VOL_SFT, 127, 0,
		       dac_vol_tlv), /* max value, invert, tlv_array */

	/* IN Boost Control */
	SOC_SINGLE_TLV("IN1 Capture Volume", CM7120_BST12_CTRL, CM7120_BST1_SFT,
		       69, 0, bst_tlv),
	SOC_SINGLE_TLV("IN2 Capture Volume", CM7120_BST12_CTRL, CM7120_BST2_SFT,
		       69, 0, bst_tlv),
	SOC_SINGLE_TLV("IN3 Capture Volume", CM7120_BST34_CTRL, CM7120_BST3_SFT,
		       69, 0, bst_tlv),
	SOC_SINGLE_TLV("IN4 Capture Volume", CM7120_BST34_CTRL, CM7120_BST4_SFT,
		       69, 0, bst_tlv),

	/* ADC Digital Capture Switch, stereo2 0x1c and Stereo1 0x1a */
	SOC_SINGLE_EXT("ADC1 ON_OFF", MIC_ADC1_ON_OFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("ADC2 ON_OFF", MIC_ADC2_ON_OFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("ADC3 ON_OFF", MIC_ADC3_ON_OFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),

	/* ADC Digital Volume Control, stereo2 0x1c and Stereo1 0x1a */
	SOC_SINGLE_TLV("Mic1 VOL Capture Volume", CM7120_STO2_ADC_DIG_VOL,
			CM7120_STO2_ADC_L_VOL_SFT, 127, 0, adc_vol_tlv),
	SOC_SINGLE_TLV("Mic2 VOL Capture Volume", CM7120_STO2_ADC_DIG_VOL,
			CM7120_STO2_ADC_R_VOL_SFT, 127, 0, adc_vol_tlv),
	SOC_SINGLE_TLV("Mic3 VOL Capture Volume", CM7120_STO1_ADC_DIG_VOL,
			CM7120_STO1_ADC_L_VOL_SFT, 127, 0, adc_vol_tlv),

	/* ADC Boost Volume Control, adc boost gain / 0x20 */
	SOC_DOUBLE_TLV("Microphone Digital Boost Volume",
			CM7120_ADC_BST_GAIN_CTRL1, CM7120_STO2_ADC_L_BST_SFT,
			CM7120_STO2_ADC_R_BST_SFT, 3, 0, adc_bst_tlv),

	/* ADC1 to HP out */
	SOC_SINGLE_EXT("Microphone Monitor to HP out", MIC_MONITOR_ON_OFF, 0, 1,
			0, cm7120_get_vu, cm7120_put_vu),

	/* MIC */
	SOC_SINGLE_EXT("MIC TEST ADC MUTE", MIC_MUTE_STO2, 0, 3, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("Headphone Impedance", HP_IMPEDANCE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),

	SOC_SINGLE_EXT("MIC EQ Switch", MIC_EQ_ON_OFF, 0, 1, 0,
		       cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT_TLV("MIC EQ Pre Gain", MIC_EQ_PRE_GAIN, 0, 12, 0,
			   cm7120_get_eq_gain, cm7120_put_eq_gain, eq_pre_tlv),
	SOC_SINGLE_EXT("MIC EQ AGC Switch", MIC_EQ_AGC_ON_OFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("Mic DSP AEC", MIC_DSP_AEC_ON_OFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("Mic DSP ENC", MIC_DSP_ENC_ON_OFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("Mic DSP WW AEC", MIC_DSP_WW_AEC_ON_OFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("MIC DSP AEC MaxNR", MIC_DSP_AEC_MAXNR, 0, 32768, 0,
			cm710x_get_dsp_param, cm710x_put_dsp_param),
	SOC_SINGLE_EXT("MIC DSP ENC MaxNR", MIC_DSP_ENC_MAXNR, 0, 32768, 0,
			cm710x_get_dsp_param, cm710x_put_dsp_param),
	SOC_SINGLE_EXT("MIC DSP ENC Mode", MIC_DSP_ENC_MODE, 0, 2, 0,
			cm710x_get_dsp_param, cm710x_put_dsp_param),
	SOC_SINGLE_EXT("MIC DSP AEC TBrr State", MIC_DSP_AEC_TBRR_STATE,
			0, 12, 0, cm710x_get_dsp_param, cm710x_put_dsp_param),
	SOC_SINGLE_EXT("MIC DSP Noise Gate", MIC_DSP_NOISE_GATE, 0, 1048575, 0,
			cm710x_get_dsp_param, cm710x_put_dsp_param),
	SOC_SINGLE_EXT("MIC DSP Ref Delay", MIC_DSP_REF_DELAY, 0, 24, 0,
			cm710x_get_dsp_param, cm710x_put_dsp_param),
	SOC_SINGLE_EXT("MIC DSP WW AEC MaxNR", MIC_DSP_WW_AEC_MAXNR, 0, 32768,
			0, cm710x_get_dsp_param, cm710x_put_dsp_param),

	/* Config REG */
	SOC_SINGLE_EXT("SPK L1 TO MUTE", SPK_L1_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("SPK L2 TO MUTE", SPK_L2_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("SPK R1 TO MUTE", SPK_R1_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("SPK R2 TO MUTE", SPK_R2_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("SPK 2CH TO 4CH", SPK_2CH_TO_4CH, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("MIC TO CHANNEL0", MIC_TO_CHANNEL0, 0, 4, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("MIC TO CHANNEL1", MIC_TO_CHANNEL1, 0, 4, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("MIC TO I2S1 0", MIC_TO_I2S10, 0, 2, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("MIC TO I2S1 1", MIC_TO_I2S11, 0, 2, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("LEFT FIR FLIP", LEFT_FIR_FLIP, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("RIGHT FIR FLIP", RIGHT_FIR_FLIP, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("LEFT FIR ONOFF", LEFT_FIR_ONOFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("RIGHT FIR ONOFF", RIGHT_FIR_ONOFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("MIC FIR ONOFF", MIC_FIR_ONOFF, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("UPDATE FIR COEFFICIENT", UPDATE_FIR_COEFFICIENT,
			0, 1, 0, cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("REC L MUTE", REC_L_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("REC R MUTE", REC_R_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("REC I2S1L MUTE", REC_I2S1L_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("REC I2S1R MUTE", REC_I2S1R_MUTE, 0, 1, 0,
			cm7120_get_vu, cm7120_put_vu),
};

static int cm7120_get_eq_gain(struct snd_kcontrol *kcontrol,
			      struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;

	switch (reg) {
	case MIC_EQ_PRE_GAIN:
		ucontrol->value.integer.value[0] =
		    (char)cm7120_codec->preGainMic;
		break;

	default:
		break;
	}

	return 0;
}

static int cm7120_put_eq_gain(struct snd_kcontrol *kcontrol,
			      struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	int rc = 0;

	rc = wait_for_completion_timeout(&cm7120_codec->fw_download_complete,
					 FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		pr_err("%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	switch (reg) {
	case MIC_EQ_PRE_GAIN:
		cm7120_codec->preGainMic =
		    (char)ucontrol->value.integer.value[0];
		cm7120_update_eq_pregain_enable(cm7120_codec);
		break;

	default:
		break;
	}

	return 0;
}

/**
* 0x5FFC0004: Out config register
*	Bit 0~3: Mic ID dump to channel 0 (value 0/1/2 as Mic1/Mic2/Mic3,
*	3/4 as reference signal left/right)
*	Bit 4~7: Mic ID dump to channel 1
*	Bit 8~11: Mic ID dump to I2S1 channel 0
*	Bit 12~15: Mic ID dump to I2S1 channel 1
*	Bit 16: Left channel HF FIR polarity flip
*	Bit 17: Right channel HF FIR polarity flip
*	Bit 18: Left channel FIR on/off
*	Bit 19: Right channel FIR on/off
*	Bit 20: Mic FIR on/off
*	Bit 21: Update FIR coefficient (will be cleared to 0 when done)
*	Bit 22~23: Reserved
*	Bit 24: Mute SPK L1
*	Bit 25: Mute SPK L2
*	Bit 26: Mute SPK R1
*	Bit 27: Mute SPK R2
*	Bit 28: Mute Rec L
*	Bit 29: Mute Rec R
*	Bit 30: Mute Rec I2S1 L
*	Bit 31: Mute Rec I2S1 R
*/
static int cm7120_set_config_register(struct cm7120_priv *cm7120_codec,
		char value, char mute)
{
	u32 dspValue = 0;
	u8 recLMuteValue = 0;
	u8 recRMuteValue = 0;
	u8 recI2s1LMuteValue = 0;
	u8 recI2s1RMuteValue = 0;
	u8 spk2CHTo4CHValue = 0;
	u8 spkR2MuteValue = 0;
	u8 spkR1MuteValue = 0;
	u8 spkL2MuteValue = 0;
	u8 spkL1MuteValue = 0;
	u8 micChannel0Value = 0;
	u8 micChannel1Value = 0;
	u8 micI2S10Value = 0;
	u8 micI2S11Value = 0;
	u8 leftFIRfilpValue = 0;
	u8 rightFIRfilpValue = 0;
	u8 leftFIRValue = 0;
	u8 rightFIRValue = 0;
	u8 micFIRValue = 0;
	u8 updateFIRValue = 0;
	int ret = 0;

	if (cm7120_codec->is_dsp_mode) {
		mutex_lock(&cm7120_codec->dsp_lock);
		cm7120_dsp_mode_i2c_read_mem(cm7120_codec->real_regmap,
				CM7120_DSP_OUT_CONFIG_REG, &dspValue);
		mutex_unlock(&cm7120_codec->dsp_lock);
	} else {
		dev_err(cm7120_codec->dev, "%s: Not in DSP mode!\n", __func__);
		return -EINVAL;
	}

	dev_dbg(cm7120_codec->dev,
			"%s: before dspValue = 0x%08x value = %d, mute = %d\n",
			__func__, dspValue, value, mute);

	switch (value) {
	case 0:
		if (mute == 0)
			spkL1MuteValue = 0x0;
		else if (mute == 1)
			spkL1MuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 1:
		if (mute == 0)
			spkL2MuteValue = 0x0;
		else if (mute == 1)
			spkL2MuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 2:
		if (mute == 0)
			spkR1MuteValue = 0x0;
		else if (mute == 1)
			spkR1MuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 3:
		if (mute == 0)
			spkR2MuteValue = 0x0;
		else if (mute == 1)
			spkR2MuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 4:
		if (mute == 0)
			micChannel0Value = 0x00;
		else if (mute == 1)
			micChannel0Value = 0x01;
		else if (mute == 2)
			micChannel0Value = 0x02;
		else if (mute == 3)
			micChannel0Value = 0x03;
		else if (mute == 4)
			micChannel0Value = 0x04;
		else
			ret = -EINVAL;
		break;
	case 5:
		if (mute == 0)
			micChannel1Value = 0x00;
		else if (mute == 1)
			micChannel1Value = 0x01;
		else if (mute == 2)
			micChannel1Value = 0x02;
		else if (mute == 3)
			micChannel1Value = 0x03;
		else if (mute == 4)
			micChannel1Value = 0x04;
		else
			ret = -EINVAL;
		break;
	case 6:
		if (mute == 0)
			micI2S10Value = 0x00;
		else if (mute == 1)
			micI2S10Value = 0x01;
		else if (mute == 2)
			micI2S10Value = 0x02;
		else
			ret = -EINVAL;
		break;
	case 7:
		if (mute == 0)
			micI2S11Value = 0x00;
		else if (mute == 1)
			micI2S11Value = 0x01;
		else if (mute == 2)
			micI2S11Value = 0x02;
		else
			ret = -EINVAL;
		break;
	case 8:
		if (mute == 0)
			leftFIRfilpValue = 0x0;
		else if (mute == 1)
			leftFIRfilpValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 9:
		if (mute == 0)
			rightFIRfilpValue = 0x0;
		else if (mute == 1)
			rightFIRfilpValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 10:
		if (mute == 0)
			leftFIRValue = 0x0;
		else if (mute == 1)
			leftFIRValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 11:
		if (mute == 0)
			rightFIRValue = 0x0;
		else if (mute == 1)
			rightFIRValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 12:
		if (mute == 0)
			micFIRValue = 0x0;
		else if (mute == 1)
			micFIRValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 13:
		if (mute == 0)
			updateFIRValue = 0x0;
		else if (mute == 1)
			updateFIRValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 14:
		if (mute == 0)
			recLMuteValue = 0x0;
		else if (mute == 1)
			recLMuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 15:
		if (mute == 0)
			recRMuteValue = 0x0;
		else if (mute == 1)
			recRMuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 16:
		if (mute == 0)
			recI2s1LMuteValue = 0x0;
		else if (mute == 1)
			recI2s1LMuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 17:
		if (mute == 0)
			recI2s1RMuteValue = 0x0;
		else if (mute == 1)
			recI2s1RMuteValue = 0x1;
		else
			ret = -EINVAL;
		break;
	case 18:
		if (mute == 0)
			spk2CHTo4CHValue = 0x0;
		else if (mute == 1)
			spk2CHTo4CHValue = 0x1;
		else
			ret = -EINVAL;
		break;
	default:
		ret = -EINVAL;
	}

	if (ret == 0) {
		mutex_lock(&cm7120_codec->dsp_lock);
		dev_dbg(cm7120_codec->dev,
				"%s: value = %d\n", __func__, value);
		switch (value) {
		case 0:
			/* Speaker L1 Mute */
			dspValue &= ~CM7120_CSPK_L1_MUTE_MASK;
			dspValue |= (spkL1MuteValue << CM7120_CSPK_L1_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: CSPKL1MUTE dspValue1 = 0x%08x\n",
				__func__, dspValue);
			break;
		case 1:
			/* Speaker L2 Mute */
			dspValue &= ~CM7120_CSPK_L2_MUTE_MASK;
			dspValue |= (spkL2MuteValue << CM7120_CSPK_L2_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
					"%s: CSPKL2MUTE dspValue1 = 0x%08x\n",
					__func__, dspValue);
			break;
		case 2:
			/* Speaker R1 Mute */
			dspValue &= ~CM7120_CSPK_R1_MUTE_MASK;
			dspValue |= (spkR1MuteValue << CM7120_CSPK_R1_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
					"%s: CSPKR1MUTE dspValue1 = 0x%08x\n",
					__func__, dspValue);
			break;
		case 3:
			/* Speaker R2 Mute */
			dspValue &= ~CM7120_CSPK_R2_MUTE_MASK;
			dspValue |= (spkR2MuteValue << CM7120_CSPK_R2_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
					"%s: CSPKR2MUTE dspValue1 = 0x%08x\n",
					__func__, dspValue);
			break;
		case 4:
			/* MicIDdumpToChannel0 */
			dspValue &= ~CM7120_MIC_ID_DUMP_TO_CHANNEL0_MASK;
			dspValue |= (micChannel0Value <<
					CM7120_MIC_ID_DUMP_TO_CHANNEL0_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: MicIDdumpToChannel0 dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 5:
			/* MicIDdumpToChannel1 */
			dspValue &= ~CM7120_MIC_ID_DUMP_TO_CHANNEL1_MASK;
			dspValue |= (micChannel1Value <<
					CM7120_MIC_ID_DUMP_TO_CHANNEL1_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: MicIDdumpToChannel1 dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 6:
			/* MicIDdumpToI2S10 */
			dspValue &= ~CM7120_MIC_ID_DUMP_TO_I2S10_MASK;
			dspValue |= (micI2S10Value <<
					CM7120_MIC_ID_DUMP_TO_I2S10_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: MicIDdumpToI2S10 dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 7:
			/* MicIDdumpToI2S11 */
			dspValue &= ~CM7120_MIC_ID_DUMP_TO_I2S11_MASK;
			dspValue |= (micI2S11Value <<
					CM7120_MIC_ID_DUMP_TO_I2S11_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: MicIDdumpToI2S11 dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 8:
			/* Left channel high-pass FIR result polarity flip */
			dspValue &= ~CM7120_LEFT_HIGH_FIR_FLIP_MASK;
			dspValue |= (leftFIRfilpValue <<
					CM7120_LEFT_HIGH_FIR_FLIP_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: leftFIRfilpValue dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 9:
			/* Right channel high-pass FIR result polarity flip */
			dspValue &= ~CM7120_RIGHT_HIGH_FIR_FLIP_MASK;
			dspValue |= (rightFIRfilpValue <<
					CM7120_RIGHT_HIGH_FIR_FLIP_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: rightFIRfilpValue dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 10:
			/* LeftFIRonoff */
			dspValue &= ~CM7120_LEFT_FIR_ON_OFF_MASK;
			dspValue |= (leftFIRValue <<
					CM7120_LEFT_FIR_ON_OFF_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: LeftFIRonoff dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 11:
			/* RightFIRonoff */
			dspValue &= ~CM7120_RIGHT_FIR_ON_OFF_MASK;
			dspValue |= (rightFIRValue <<
					CM7120_RIGHT_FIR_ON_OFF_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: RightFIRonoff dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 12:
			/* MicFIRonoff */
			dspValue &= ~CM7120_MIC_FIR_ON_OFF_MASK;
			dspValue |= (micFIRValue <<
					CM7120_MIC_FIR_ON_OFF_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: MicFIRonoff dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 13:
			/* UpdateFIRCoefficient */
			dspValue &= ~CM7120_UPDATE_FIR_COEFFICIENT_MASK;
			dspValue |= (updateFIRValue <<
					CM7120_UPDATE_FIR_COEFFICIENT_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: UpdateFIRCoefficient dspValue = 0x%08x\n",
				__func__, dspValue);
			break;
		case 14:
			/* REC L Mute */
			dspValue &= ~CM7120_CREC_L_MUTE_MASK;
			dspValue |= (recLMuteValue << CM7120_CREC_L_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: CRECLMute dspValue1 = 0x%08x\n",
				__func__, dspValue);
			break;
		case 15:
			/* REC R Mute */
			dspValue &= ~CM7120_CREC_R_MUTE_MASK;
			dspValue |= (recRMuteValue << CM7120_CREC_R_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: CRECRMute dspValue1 = 0x%08x\n",
				__func__, dspValue);
			break;
		case 16:
			/* Rec I2s1 L Mute */
			dspValue &= ~CM7120_CRECI2S1_L_MUTE_MASK;
			dspValue |= (recI2s1LMuteValue <<
					CM7120_CRECI2S1_L_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: CRECI2s1LMute dspValue1 = 0x%08x\n",
				__func__, dspValue);
			break;
		case 17:
			/* Rec I2s1 R Mute */
			dspValue &= ~CM7120_CRECI2S1_R_MUTE_MASK;
			dspValue |= (recI2s1RMuteValue <<
					CM7120_CRECI2S1_R_MUTE_SFT);
			dev_dbg(cm7120_codec->dev,
				"%s: CRECI2s1RMute dspValue1 = 0x%08x\n",
				__func__, dspValue);
			break;
		case 18:
			/* Speaker 2CH to 4CH */
			dspValue &= ~CM7120_CSPK_2CH_TO_4CH_MASK;
			dspValue |= (spk2CHTo4CHValue <<
					CM7120_CSPK_2CH_TO_4CH_SFT);
			dev_dbg(cm7120_codec->dev,
					"%s: CSPK2CHTo4CH dspValue1 = 0x%08x\n",
					__func__, dspValue);
			break;
		}

		dev_dbg(cm7120_codec->dev,
				"%s: after dspValue = 0x%08x\n", __func__,
				dspValue);
		cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap,
				CM7120_DSP_OUT_CONFIG_REG, (u8 *)&dspValue, 4);
		mutex_unlock(&cm7120_codec->dsp_lock);
	}

	if (ret != 0)
		dev_err(cm7120_codec->dev,
			"%s: return failed value = 0x%08x\n", __func__, ret);

	return ret;
}

static int cm7120_set_mic_mute(struct cm7120_priv *cm7120_codec, char item)
{
	switch (item) {
	case 0: /* MIC ADC default */
		regmap_write(cm7120_codec->virt_regmap,
				CM7120_STO2_ADC_MIXER_CTRL, 0x4040);
		regmap_write(cm7120_codec->virt_regmap,
				CM7120_STO1_ADC_MIXER_CTRL, 0x4040);
		break;
	case 1: /* MIC ADC1 (L) mute */
		if (cm7120_codec->bEnableADC1)
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_MIXER_CTRL,
					   CM7120_M_STO2_ADC_L1,
					   CM7120_M_STO2_ADC_L1);
		else
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_MIXER_CTRL,
					   CM7120_M_STO2_ADC_L1, 0);
		break;
	case 2: /* MIC ADC2 (R) mute */
		if (cm7120_codec->bEnableADC2)
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_MIXER_CTRL,
					   CM7120_M_STO2_ADC_R1,
					   CM7120_M_STO2_ADC_R1);
		else
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_MIXER_CTRL,
					   CM7120_M_STO2_ADC_R1, 0);
		break;
	case 3: /* MIC ADC3 (L) mute */
		if (cm7120_codec->bEnableADC3)
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO1_ADC_MIXER_CTRL,
					   CM7120_M_STO1_ADC_L1,
					   CM7120_M_STO1_ADC_L1);
		else
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO1_ADC_MIXER_CTRL,
					   CM7120_M_STO1_ADC_L1, 0);
		break;
	case 4: /* MIC ADC1/2/3 (LR) mute */
		regmap_write(cm7120_codec->virt_regmap,
		CM7120_STO2_ADC_MIXER_CTRL, 0xc0c0);
		regmap_write(cm7120_codec->virt_regmap,
		CM7120_STO1_ADC_MIXER_CTRL, 0xc0c0);
		break;
	}
	return 0;
}

static void cm7120_update_eq_pregain_enable(struct cm7120_priv *cm7120_codec)
{
	u32 EQElement = 0;

	EQElement = cm7120_codec->bEnableSpkPolarFlip |
			(cm7120_codec->bEnableMicEQ << 1) |
			(cm7120_codec->preGainMic << 18) |
			(cm7120_codec->bEnableAGC << 31);
	dev_info(cm7120_codec->dev, "%s EQElement = 0x%08x\n", __func__,
		 EQElement);
	mutex_lock(&cm7120_codec->dsp_lock);
	cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap, 0x5FFC0020,
				      (u8 *)&EQElement, 4);
	mutex_unlock(&cm7120_codec->dsp_lock);
}

static void cm7120_aec_enc_enable(struct cm7120_priv *cm7120_codec)
{
	u32 DSPElement = 0;

	DSPElement = cm7120_codec->bEnableAEC |
			(cm7120_codec->bEnableENC << 1) |
			(cm7120_codec->bEnableWWAEC << 2);
	dev_info(cm7120_codec->dev, "%s DSPElement = 0x%08x\n", __func__,
		 DSPElement);
	mutex_lock(&cm7120_codec->dsp_lock);
	cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap, 0x5FFC0030,
				      (u8 *)&DSPElement, 4);
	mutex_unlock(&cm7120_codec->dsp_lock);
}

static int cm7120_put_vu(struct snd_kcontrol *kcontrol,
			 struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	int adcstr = 0;
	int rc = 0;

	rc = wait_for_completion_timeout(&cm7120_codec->fw_download_complete,
				    FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		pr_err("%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}


	switch (reg) {
	case MIC_EQ_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableMicEQ = false;
		else
			cm7120_codec->bEnableMicEQ = true;

		cm7120_update_eq_pregain_enable(cm7120_codec);
		dev_dbg(cm7120_codec->dev,
			 "%s MIC_EQ_ON_OFF set Value = %ld\n", __func__,
			 ucontrol->value.integer.value[0]);
		break;

	case MIC_EQ_AGC_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableAGC = false;
		else
			cm7120_codec->bEnableAGC = true;

		cm7120_update_eq_pregain_enable(cm7120_codec);
		dev_dbg(cm7120_codec->dev,
			"%s MIC_EQ_AGC_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_DSP_AEC_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableAEC = false;
		else
			cm7120_codec->bEnableAEC = true;

		cm7120_aec_enc_enable(cm7120_codec);
		dev_dbg(cm7120_codec->dev,
			"%s MIC_AEC_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_DSP_ENC_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableENC = false;
		else
			cm7120_codec->bEnableENC = true;

		cm7120_aec_enc_enable(cm7120_codec);
		dev_dbg(cm7120_codec->dev,
			"%s MIC_ENC_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_DSP_WW_AEC_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableWWAEC = false;
		else
			cm7120_codec->bEnableWWAEC = true;

		cm7120_aec_enc_enable(cm7120_codec);
		dev_dbg(cm7120_codec->dev,
			"%s MIC_WW_AEC_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_ADC1_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableADC1 = false;
		else
			cm7120_codec->bEnableADC1 = true;

		adcstr = 1;
		cm7120_set_mic_mute(cm7120_codec, adcstr);
		dev_dbg(cm7120_codec->dev,
			"%s MIC_ADC1_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;
	case MIC_ADC2_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableADC2 = false;
		else
			cm7120_codec->bEnableADC2 = true;

		adcstr = 2;
		cm7120_set_mic_mute(cm7120_codec, adcstr);
		dev_dbg(cm7120_codec->dev,
			"%s MIC_ADC2_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;
	case MIC_ADC3_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableADC3 = false;
		else
			cm7120_codec->bEnableADC3 = true;

		adcstr = 3;
		cm7120_set_mic_mute(cm7120_codec, adcstr);
		dev_dbg(cm7120_codec->dev,
			"%s MIC_ADC3_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_MONITOR_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0) {
			dev_dbg(cm7120_codec->dev,
				"%s MIC_MONITOR_ON_OFF disable\n", __func__);
			cm7120_codec->bEnableMonitor = false;

			/* 0x46 */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_L,
					   CM7120_M_ADDA_MIXER1_L);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_R,
					   CM7120_M_ADDA_MIXER1_R);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_ADDA1_SEL_MASK, 0);

			/* 0x1c, stereo2 adc digital volume */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 8,
					   0xf << 8);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 0,
					   0xf << 0);

			/* SND_SOC_DAPM_POST_PMD: */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC1_HPL,
					   0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC2_HPR,
					   0);
			dev_dbg(component->dev, "HP gpio to low (fake)");

		} else {
			dev_dbg(cm7120_codec->dev,
				"%s MIC_MONITOR_ON_OFF enable\n", __func__);
			cm7120_codec->bEnableMonitor = true;

			/* 0x1c, stereo2_adc_mute set unmute */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL,
					   CM7120_L_MUTE, 0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL,
					   CM7120_R_MUTE, 0);

			/* 0x1c, stereo2 adc digital volume */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 8,
					   0xf << 8);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 0,
					   0xf << 0);

			/* 0x46 */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_L, 0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_R, 0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_ADDA1_SEL_MASK, 1);

			/* 0x20, adc boost gain control for stereo1 / stereo2 */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_ADC_BST_GAIN_CTRL1,
					   CM7120_STO2_ADC_L_BST_MASK,
					   0x1 << CM7120_STO2_ADC_L_BST_SFT);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_ADC_BST_GAIN_CTRL1,
					   CM7120_STO2_ADC_R_BST_MASK,
					   0x1 << CM7120_STO2_ADC_R_BST_SFT);

			/* SND_SOC_DAPM_POST_PMU: */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC1_HPL,
					   CM7120_EN_DAC1_HPL);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC2_HPR,
					   CM7120_EN_DAC2_HPR);
			dev_dbg(component->dev, "HP gpio to high (fake)");
		}
		dev_dbg(cm7120_codec->dev,
			"%s MIC_MONITOR_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case SPK_L1_MUTE:
		cm7120_codec->spkl1mute = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: SPK_L1_MUTE: %d\n", __func__,
				cm7120_codec->spkl1mute);
		cm7120_set_config_register(cm7120_codec, 0,
				cm7120_codec->spkl1mute);
		break;

	case SPK_L2_MUTE:
		cm7120_codec->spkl2mute = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: SPK_L2_MUTE: %d\n", __func__,
				cm7120_codec->spkl2mute);
		cm7120_set_config_register(cm7120_codec, 1,
				cm7120_codec->spkl2mute);
		break;

	case SPK_R1_MUTE:
		cm7120_codec->spkr1mute = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: SPK_R1_MUTE: %d\n", __func__,
				cm7120_codec->spkr1mute);
		cm7120_set_config_register(cm7120_codec, 2,
				cm7120_codec->spkr1mute);
		break;

	case SPK_R2_MUTE:
		cm7120_codec->spkr2mute = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: SPK_R2_MUTE: %d\n", __func__,
				cm7120_codec->spkr2mute);
		cm7120_set_config_register(cm7120_codec, 3,
				cm7120_codec->spkr2mute);
		break;

	case MIC_TO_CHANNEL0:
		cm7120_codec->mictochannel0 = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: MIC_TO_CHANNEL0: %d\n", __func__,
				cm7120_codec->mictochannel0);
		cm7120_set_config_register(cm7120_codec, 4,
				cm7120_codec->mictochannel0);
		break;

	case MIC_TO_CHANNEL1:
		cm7120_codec->mictochannel1 = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: MIC_TO_CHANNEL1: %d\n", __func__,
				cm7120_codec->mictochannel1);
		cm7120_set_config_register(cm7120_codec, 5,
				cm7120_codec->mictochannel1);
		break;

	case MIC_TO_I2S10:
		cm7120_codec->mictoi2s10 = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: MIC_TO_I2S10: %d\n", __func__,
				cm7120_codec->mictoi2s10);
		cm7120_set_config_register(cm7120_codec, 6,
				cm7120_codec->mictoi2s10);
		break;

	case MIC_TO_I2S11:
		cm7120_codec->mictoi2s11 = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: MIC_TO_I2S11: %d\n", __func__,
				cm7120_codec->mictoi2s11);
		cm7120_set_config_register(cm7120_codec, 7,
				cm7120_codec->mictoi2s11);
		break;

	case LEFT_FIR_FLIP:
		cm7120_codec->leftfirflip = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: LEFT_FIR_FLIP: %d\n", __func__,
				cm7120_codec->leftfirflip);
		cm7120_set_config_register(cm7120_codec, 8,
				cm7120_codec->leftfirflip);
		break;

	case RIGHT_FIR_FLIP:
		cm7120_codec->rightfirflip = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: RIGHT_FIR_FLIP: %d\n", __func__,
				cm7120_codec->rightfirflip);
		cm7120_set_config_register(cm7120_codec, 9,
				cm7120_codec->rightfirflip);
		break;

	case LEFT_FIR_ONOFF:
		cm7120_codec->leftfironoff = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: LEFT_FIR_ONOFF: %d\n", __func__,
				cm7120_codec->leftfironoff);
		cm7120_set_config_register(cm7120_codec, 10,
				cm7120_codec->leftfironoff);
		break;

	case RIGHT_FIR_ONOFF:
		cm7120_codec->rightfironoff = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: RIGHT_FIR_ONOFF: %d\n", __func__,
				cm7120_codec->rightfironoff);
		cm7120_set_config_register(cm7120_codec, 11,
				cm7120_codec->rightfironoff);
		break;

	case MIC_FIR_ONOFF:
		cm7120_codec->micfironoff = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: MIC_FIR_ONOFF: %d\n", __func__,
				cm7120_codec->micfironoff);
		cm7120_set_config_register(cm7120_codec, 12,
				cm7120_codec->micfironoff);
		break;

	case UPDATE_FIR_COEFFICIENT:
		cm7120_codec->updateFIR = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: UPDATE_FIR_COEFFICIENT: %d\n", __func__,
				cm7120_codec->updateFIR);
		cm7120_set_config_register(cm7120_codec, 13,
				cm7120_codec->updateFIR);
		break;

	case REC_L_MUTE:
		cm7120_codec->updateFIR = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: REC_L_MUTE: %d\n", __func__,
				cm7120_codec->updateFIR);
		cm7120_set_config_register(cm7120_codec, 14,
				cm7120_codec->updateFIR);
		break;

	case REC_R_MUTE:
		cm7120_codec->updateFIR = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev, "%s: REC_R_MUTE: %d\n", __func__,
				cm7120_codec->updateFIR);
		cm7120_set_config_register(cm7120_codec, 15,
				cm7120_codec->updateFIR);
		break;

	case REC_I2S1L_MUTE:
		cm7120_codec->updateFIR = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: REC_I2S1L_MUTE: %d\n", __func__,
				cm7120_codec->updateFIR);
		cm7120_set_config_register(cm7120_codec, 16,
				cm7120_codec->updateFIR);
		break;

	case REC_I2S1R_MUTE:
		cm7120_codec->updateFIR = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: REC_I2S1R_MUTE: %d\n", __func__,
				cm7120_codec->updateFIR);
		cm7120_set_config_register(cm7120_codec, 17,
				cm7120_codec->updateFIR);
		break;

	case SPK_2CH_TO_4CH:
		cm7120_codec->spk2chto4ch = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
				"%s: SPK_2CH_TO_4CH: %d\n", __func__,
				cm7120_codec->spk2chto4ch);
		cm7120_set_config_register(cm7120_codec, 18,
				cm7120_codec->spk2chto4ch);
		break;

	case MIC_MUTE_STO2:
		cm7120_codec->adcsto2 = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
			"%s: MIC_MUTE_STO2: %d\n",
			__func__, cm7120_codec->adcsto2);
		cm7120_set_mic_mute(cm7120_codec, cm7120_codec->adcsto2);
		break;

	case HP_IMPEDANCE:
		dev_dbg(cm7120_codec->dev, "%s: no function\n", __func__);
		break;
	}

	return 0;
}

static int cm7120_get_vu(struct snd_kcontrol *kcontrol,
			 struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	u32 uData;

	switch (reg) {
	case MIC_MONITOR_ON_OFF:
		if (cm7120_codec->bEnableMonitor)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_MONITOR_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_EQ_AGC_ON_OFF:
		if (cm7120_codec->bEnableAGC)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_EQ_AGC_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_DSP_AEC_ON_OFF:
		if (cm7120_codec->bEnableAEC)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_AEC_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_DSP_ENC_ON_OFF:
		if (cm7120_codec->bEnableENC)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_ENC_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_DSP_WW_AEC_ON_OFF:
		if (cm7120_codec->bEnableWWAEC)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_WW_AEC_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_ADC1_ON_OFF:
		if (cm7120_codec->bEnableADC1)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_ADC1_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;
	case MIC_ADC2_ON_OFF:
		if (cm7120_codec->bEnableADC2)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_ADC2_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case MIC_ADC3_ON_OFF:
		if (cm7120_codec->bEnableADC3)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_ADC3_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case SPK_L1_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->spkl1mute;
		dev_dbg(cm7120_codec->dev, "%s: SPK_L1_MUTE: %d\n", __func__,
			cm7120_codec->spkl1mute);
		break;

	case SPK_L2_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->spkl2mute;
		dev_dbg(cm7120_codec->dev, "%s: SPK_L2_MUTE: %d\n", __func__,
			cm7120_codec->spkl2mute);
		break;

	case SPK_R1_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->spkr1mute;
		dev_dbg(cm7120_codec->dev, "%s: SPK_R1_MUTE: %d\n", __func__,
			cm7120_codec->spkr1mute);
		break;

	case SPK_R2_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->spkr2mute;
		dev_dbg(cm7120_codec->dev, "%s: SPK_R2_MUTE: %d\n", __func__,
			cm7120_codec->spkr2mute);
		break;

	case MIC_TO_CHANNEL0:
		ucontrol->value.integer.value[0] = cm7120_codec->mictochannel0;
		dev_dbg(cm7120_codec->dev, "%s: MIC_TO_CHANNEL0\n", __func__);
		break;

	case MIC_TO_CHANNEL1:
		ucontrol->value.integer.value[0] = cm7120_codec->mictochannel1;
		dev_dbg(cm7120_codec->dev, "%s: MIC_TO_CHANNEL1\n", __func__);
		break;

	case MIC_TO_I2S10:
		ucontrol->value.integer.value[0] = cm7120_codec->mictoi2s10;
		dev_dbg(cm7120_codec->dev, "%s: MIC_TO_I2S10\n", __func__);
		break;

	case MIC_TO_I2S11:
		ucontrol->value.integer.value[0] = cm7120_codec->mictoi2s11;
		dev_dbg(cm7120_codec->dev, "%s: MIC_TO_I2S11\n", __func__);
		break;

	case LEFT_FIR_FLIP:
		ucontrol->value.integer.value[0] = cm7120_codec->leftfirflip;
		dev_dbg(cm7120_codec->dev, "%s: LEFT_FIR_FLIP\n", __func__);
		break;

	case RIGHT_FIR_FLIP:
		ucontrol->value.integer.value[0] = cm7120_codec->rightfirflip;
		dev_dbg(cm7120_codec->dev, "%s: RIGHT_FIR_FLIP\n", __func__);
		break;

	case LEFT_FIR_ONOFF:
		ucontrol->value.integer.value[0] = cm7120_codec->leftfironoff;
		dev_dbg(cm7120_codec->dev, "%s: LEFT_FIR_ONOFF\n", __func__);
		break;

	case RIGHT_FIR_ONOFF:
		ucontrol->value.integer.value[0] = cm7120_codec->rightfironoff;
		dev_dbg(cm7120_codec->dev, "%s: RIGHT_FIR_ONOFF\n", __func__);
		break;

	case MIC_FIR_ONOFF:
		ucontrol->value.integer.value[0] = cm7120_codec->micfironoff;
		dev_dbg(cm7120_codec->dev, "%s: MIC_FIR_ONOFF\n", __func__);
		break;

	case UPDATE_FIR_COEFFICIENT:
		ucontrol->value.integer.value[0] = cm7120_codec->updateFIR;
		dev_dbg(cm7120_codec->dev,
				"%s: UPDATE_FIR_COEFFICIENT\n", __func__);
		break;

	case REC_L_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->updateFIR;
		dev_dbg(cm7120_codec->dev, "%s: REC_L_MUTE\n", __func__);
		break;

	case REC_R_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->updateFIR;
		dev_dbg(cm7120_codec->dev, "%s: REC_R_MUTE\n", __func__);
		break;

	case REC_I2S1L_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->updateFIR;
		dev_dbg(cm7120_codec->dev, "%s: REC_I2S1L_MUTE\n", __func__);
		break;

	case REC_I2S1R_MUTE:
		ucontrol->value.integer.value[0] = cm7120_codec->updateFIR;
		dev_dbg(cm7120_codec->dev, "%s: REC_I2S1R_MUTE\n", __func__);
		break;

	case SPK_2CH_TO_4CH:
		ucontrol->value.integer.value[0] = cm7120_codec->spk2chto4ch;
		dev_dbg(cm7120_codec->dev, "%s: SPK_2CH_TO_4CH\n", __func__);
		break;

	case MIC_MUTE_STO2:
		ucontrol->value.integer.value[0] = cm7120_codec->adcsto2;
		dev_dbg(cm7120_codec->dev, "%s: MIC_MUTE_STO2\n", __func__);
		break;

	case HP_IMPEDANCE:
		uData = cm7120_get_hp_impedance(cm7120_codec);
		dev_dbg(cm7120_codec->dev,
			"%s: Get headphone impedance = 0x%04x\n",
			__func__, uData);
		break;
	}
	return 0;
}

static void cm710x_update_dsp_param(
		struct cm7120_priv *cm7120_codec, char type, long value)
{
	u32 DSPElement = 0;

	DSPElement = cm7120_codec->bEnableAEC |
			cm7120_codec->bEnableENC << 1 |
			cm7120_codec->bEnableWWAEC << 2 |
			0x10 | (type & 0x7) << 5 | (value & 0xFFFFF) << 8;
	dev_dbg(cm7120_codec->dev, "%s DSPElement = 0x%08x\n", __func__,
		 DSPElement);
	usleep_range(30000, 35000);
	mutex_lock(&cm7120_codec->dsp_lock);
	cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap, 0x5FFC0030,
				      (u8 *)&DSPElement, 4);
	mutex_unlock(&cm7120_codec->dsp_lock);
}

static int cm710x_put_dsp_param(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	int rc = 0;
	unsigned int reg = mc->reg;
	u32 q;

	q = ucontrol->value.integer.value[0];
	dev_dbg(cm7120_codec->dev, "%s value = 0x%08x\n", __func__, q);

	rc = wait_for_completion_timeout(&cm7120_codec->fw_download_complete,
			FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		dev_err(cm7120_codec->dev,
			"%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	switch (reg) {
	case MIC_DSP_AEC_MAXNR:
		q = q & 0xFFFF;
		cm710x_update_dsp_param(cm7120_codec, MIC_DSP_AEC_MAXNR, q);
		break;
	case MIC_DSP_ENC_MAXNR:
		q = q & 0xFFFF;
		cm710x_update_dsp_param(cm7120_codec, MIC_DSP_ENC_MAXNR, q);
		break;
	case MIC_DSP_ENC_MODE:
		cm710x_update_dsp_param(cm7120_codec, MIC_DSP_ENC_MODE, q);
		break;
	case MIC_DSP_AEC_TBRR_STATE:
		cm710x_update_dsp_param(cm7120_codec,
				MIC_DSP_AEC_TBRR_STATE, q);
		break;
	case MIC_DSP_NOISE_GATE:
		q = q & 0xFFFFF;
		cm710x_update_dsp_param(cm7120_codec, MIC_DSP_NOISE_GATE, q);
		break;
	case MIC_DSP_REF_DELAY:
		cm710x_update_dsp_param(cm7120_codec, MIC_DSP_REF_DELAY, q);
		break;
	case MIC_DSP_WW_AEC_MAXNR:
		q = q & 0xFFFF;
		cm710x_update_dsp_param(cm7120_codec, MIC_DSP_WW_AEC_MAXNR, q);
		break;
	default:
		break;
	}

	return 0;
}

static int cm710x_get_dsp_param(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	u32 DSPElement = 0;
	u32 dwValue = 0;

	DSPElement = cm7120_codec->bEnableAEC |
			cm7120_codec->bEnableENC << 1 |
			cm7120_codec->bEnableWWAEC << 2 |
			0x10 | (reg & 0x7) << 5 | 0x1 << 31;
	dev_dbg(cm7120_codec->dev, "%s DSPElement = 0x%08x\n", __func__,
		 DSPElement);
	mutex_lock(&cm7120_codec->dsp_lock);
	cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap, 0x5FFC0030,
				      (u8 *)&DSPElement, 4);
	mutex_unlock(&cm7120_codec->dsp_lock);
	usleep_range(100000, 150000);
	mutex_lock(&cm7120_codec->dsp_lock);
	cm7120_dsp_mode_i2c_read_mem(cm7120_codec->real_regmap, 0x5FFC0030,
					     &dwValue);
	mutex_unlock(&cm7120_codec->dsp_lock);
	dwValue = (dwValue & 0x0FFFFF00) >> 8;
	ucontrol->value.integer.value[0] = dwValue;

	return 0;
}



static int cm7120_get_hp_impedance(struct cm7120_priv *cm7120_codec)
{
	u32 dwValue = 0;
	u32 backupValue = 0;

	/*backup 0x0085 value*/
	regmap_read(cm7120_codec->virt_regmap, 0x0085, &backupValue);
	backupValue &= 0xffff;

	regmap_write(cm7120_codec->virt_regmap, 0x0085, 0x0022);
	regmap_write(cm7120_codec->virt_regmap, 0x0066, 0x1682);
	regmap_write(cm7120_codec->virt_regmap, 0x0066, 0x1F82);
	regmap_write(cm7120_codec->virt_regmap, 0x0066, 0xDF82);
	regmap_write(cm7120_codec->virt_regmap, 0x0053, 0x1A00);
	regmap_write(cm7120_codec->virt_regmap, 0x00D4, 0x3300);
	regmap_write(cm7120_codec->virt_regmap, 0x000A, 0x5353);
	regmap_write(cm7120_codec->virt_regmap, 0x0614, 0xB090);
	regmap_write(cm7120_codec->virt_regmap, 0x0060, 0x0078);
	regmap_write(cm7120_codec->virt_regmap, 0x019A, 0x2700);
	regmap_write(cm7120_codec->virt_regmap, 0x019B, 0x1011);
	regmap_write(cm7120_codec->virt_regmap, 0x01A0, 0xC33D);
	usleep_range(100000, 150000);

	regmap_read(cm7120_codec->virt_regmap, 0x01A2, &dwValue);
	dwValue &= 0xffff;
	dev_dbg(cm7120_codec->dev,
		"%s: Register 0x01A2 value = 0x%04x <-----\n",
		__func__, dwValue);

	/*restore*/
	regmap_write(cm7120_codec->virt_regmap, 0x0085, backupValue);
	regmap_write(cm7120_codec->virt_regmap, 0x0066, 0xDF82);
	regmap_write(cm7120_codec->virt_regmap, 0x0053, 0x1E00);
	regmap_write(cm7120_codec->virt_regmap, 0x00D4, 0xB300);
	regmap_write(cm7120_codec->virt_regmap, 0x000A, 0x5455);
	regmap_write(cm7120_codec->virt_regmap, 0x0614, 0xA490);
	regmap_write(cm7120_codec->virt_regmap, 0x0060, 0x0078);
	regmap_write(cm7120_codec->virt_regmap, 0x019A, 0x0000);
	regmap_write(cm7120_codec->virt_regmap, 0x019B, 0x0003);
	regmap_write(cm7120_codec->virt_regmap, 0x01A0, 0x433D);
	msleep(600);

	return dwValue;
}

static int cm7120_hw_params(struct snd_pcm_substream *substream,
			    struct snd_pcm_hw_params *params,
			    struct snd_soc_dai *dai)
{
	struct snd_soc_component *component = dai->component;
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	unsigned int val_len = 0;
	u32 resetvalue = 0x80000000;
	int rc = 0;

	rc = wait_for_completion_timeout(&cm7120->fw_download_complete,
					 FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		dev_err(component->dev,
			"%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	cm7120->sampleRate = params_rate(params);

	if (cm7120->sampleRate != 48000)
		return -EINVAL;

	switch (params_format(params)) {
	case SNDRV_PCM_FORMAT_S16_LE:
		break;

	case SNDRV_PCM_FORMAT_S20_3LE:
		val_len |= CM7120_I2S_DL_20;
		break;

	case SNDRV_PCM_FORMAT_S24_LE:
	case SNDRV_PCM_FORMAT_S32_LE:
		val_len |= CM7120_I2S_DL_24;
		break;

	default:
		return -EINVAL;
	}

	if (dai->name && !strcmp(dai->name, "cm7120-aif1"))
		regmap_update_bits(cm7120->virt_regmap, CM7120_I2S3_SDP,
				CM7120_I2S_DL_MASK, val_len);
	else if (dai->name && !strcmp(dai->name, "cm7120-aif2")) {
		regmap_update_bits(cm7120->virt_regmap, CM7120_I2S2_SDP,
				CM7120_I2S_DL_MASK, val_len);
		/* PCM Mode A data format */
		regmap_update_bits(cm7120->virt_regmap, CM7120_I2S2_SDP,
				CM7120_I2S_DF_MASK, 0x2);
	}

	pr_info("%s: val_len: 0x%04x\n", __func__, val_len);

	/* clean inbound */
	mutex_lock(&cm7120->dsp_lock);
	cm7120_dsp_mode_i2c_write_mem(cm7120->real_regmap, 0x5FFC0000,
			(u8 *)&resetvalue, 4);
	mutex_unlock(&cm7120->dsp_lock);

	return 0;
}

static int
cm7120_microphone_in_enum_ext_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_component *component =
		snd_soc_dapm_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	int rc = 0;

	rc = wait_for_completion_timeout(&cm7120->fw_download_complete,
					 FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		dev_err(component->dev,
			"%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	ucontrol->value.integer.value[0] = cm7120->microphoneSrc;
	dev_dbg(cm7120->dev, "%s microphoneSrc = %d\n", __func__,
		 cm7120->microphoneSrc);

	return 0;
}

static int
cm7120_microphone_in_enum_ext_put(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_component *component =
		snd_soc_dapm_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	int ret = 0;

	ret = wait_for_completion_timeout(&cm7120->fw_download_complete,
					FW_DOWNLOAD_TIMEOUT);
	if (ret == 0) {
		dev_err(component->dev,
			"%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	cm7120->microphoneSrc = ucontrol->value.integer.value[0];
	dev_dbg(cm7120->dev, "%s microphone Src select %d\n", __func__,
		 cm7120->microphoneSrc);
	switch (cm7120->microphoneSrc) {
	/* ADC1(L) */
	case 0:
		regmap_update_bits(cm7120->virt_regmap,
				CM7120_STO2_ADC_MIXER_CTRL,
				CM7120_SEL_STO2_ANA_ADC, 0);
		break;
	/* ADC2(R) */
	case 1:
		regmap_update_bits(cm7120->virt_regmap,
				CM7120_STO2_ADC_MIXER_CTRL,
				CM7120_SEL_STO2_ANA_ADC,
				1 << CM7120_SEL_STO2_ANA_ADC_SFT);
		break;
	/* ADC3(L) */
	case 2:
		regmap_update_bits(cm7120->virt_regmap,
				CM7120_STO2_ADC_MIXER_CTRL,
				CM7120_SEL_STO1_ANA_ADC, 0);
		break;
	default:
		dev_err(cm7120->dev, "%s EINVAL\n", __func__);
		ret = -EINVAL;
		break;
	}
	return ret;
}

static int HP_dapm_power_event(struct snd_soc_dapm_widget *w,
			       struct snd_kcontrol *kcontrol, int event)
{
	struct snd_soc_component *component =
		snd_soc_dapm_to_component(w->dapm);
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	int rc = 0;

	rc = wait_for_completion_timeout(&cm7120->fw_download_complete,
					 FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		dev_err(component->dev, "%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	switch (event) {
	case SND_SOC_DAPM_POST_PMU:
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC1_HPL, CM7120_EN_DAC1_HPL);
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC2_HPR, CM7120_EN_DAC2_HPR);
		dev_info(component->dev, "HP gpio to high\n");
		break;
	case SND_SOC_DAPM_POST_PMD:
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC1_HPL, 0);
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC2_HPR, 0);
		dev_info(component->dev, "HP gpio to low\n");
		break;
	default:
		dev_err(component->dev,
			"Unhandled dapm widget event %d from %s\n", event,
			w->name);
	}
	return 0;
}

static int SPK_dapm_power_event(struct snd_soc_dapm_widget *w,
				struct snd_kcontrol *kcontrol, int event)
{
	struct snd_soc_component *component =
		snd_soc_dapm_to_component(w->dapm);
	struct cm7120_priv *cm7120_codec =
			snd_soc_component_get_drvdata(component);
	int rc;

	dev_dbg(component->dev, "SPK wait for cm7120 FW download complete\n");
	rc = wait_for_completion_timeout(&cm7120_codec->fw_download_complete,
						 FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		dev_err(component->dev, "%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	switch (event) {
	case SND_SOC_DAPM_POST_PMU:
		dev_dbg(component->dev, "SPK gpio to high\n");
		rc = pinctrl_select_state(cm7120_codec->pinctrl,
				cm7120_codec->pin_spk_en);
		if (rc)
			dev_err(cm7120_codec->dev,
				"pinctrl_select_state error");
		break;
	case SND_SOC_DAPM_POST_PMD:
		dev_dbg(component->dev, "SPK gpio to low\n");
		rc = pinctrl_select_state(cm7120_codec->pinctrl,
				cm7120_codec->pin_spk_suspend);
		if (rc)
			dev_err(cm7120_codec->dev,
				"pinctrl_select_state error");
		break;
	default:
		dev_err(component->dev,
			"Unhandled dapm widget event %d from %s\n", event,
			w->name);
	}
	return 0;
}

/*Output Mixer*/
static const struct snd_kcontrol_new output_mix[] = {
	SOC_DAPM_SINGLE("HP Switch", SND_SOC_NOPM, 0, 1, 0),
	SOC_DAPM_SINGLE("SPK Switch", SND_SOC_NOPM, 0, 1, 0),
};

/* Playback Input Source */
static const char *const cm7120_adcin_src[] = { "ADC1/2", "ADC3/4" };

static SOC_ENUM_SINGLE_EXT_DECL(cm7120_microphone_in_enum, cm7120_adcin_src);

static const struct snd_kcontrol_new cm7120_microphone_in_mux =
	SOC_DAPM_ENUM_EXT("Microphone From", cm7120_microphone_in_enum,
			cm7120_microphone_in_enum_ext_get,
			cm7120_microphone_in_enum_ext_put);

static const struct snd_soc_dapm_widget cm7120_dapm_widgets[] = {
	SND_SOC_DAPM_OUTPUT("OUTL"),
	SND_SOC_DAPM_OUTPUT("OUTR"),
	SND_SOC_DAPM_INPUT("IN1"),
	SND_SOC_DAPM_INPUT("IN2"),
	SND_SOC_DAPM_INPUT("IN3"),
	SND_SOC_DAPM_INPUT("IN4"),

	SND_SOC_DAPM_ADC("ADC1/2", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_ADC("ADC3/4", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_DAC("DAC1", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_DAC("DAC2", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_DAC("DAC3", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_PGA("DAC1PGA", CM7120_LOUT, 15, 1, NULL, 0),
	SND_SOC_DAPM_PGA("DAC2PGA", CM7120_LOUT, 7, 1, NULL, 0),
	SND_SOC_DAPM_PGA("DAC3PGA", CM7120_LOUT, 7, 1, NULL, 0),
	SND_SOC_DAPM_OUT_DRV_E("HP Driver", SND_SOC_NOPM, 0, 0, NULL, 0,
			       HP_dapm_power_event,
			       SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),
	SND_SOC_DAPM_OUT_DRV_E("SPK Driver", SND_SOC_NOPM, 0, 0, NULL, 0,
			       SPK_dapm_power_event,
			       SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),

	SND_SOC_DAPM_MIXER("OUTPUT MIX", SND_SOC_NOPM, 0, 0, output_mix,
			   ARRAY_SIZE(output_mix)),
	SND_SOC_DAPM_MUX("Microphone From Mux", SND_SOC_NOPM, 0, 0,
			 &cm7120_microphone_in_mux),

	SND_SOC_DAPM_AIF_IN("AIF2RX", "AIF2 Playback", 0,
				SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_AIF_OUT("AIF2TX", "AIF2 Capture", 0,
				SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_MICBIAS("I2S3PWR", CM7120_PWR_DIG1,
				CM7120_PWR_I2S3_BIT, 0),
	SND_SOC_DAPM_MICBIAS("I2S4PWR", CM7120_PWR_DIG1,
				CM7120_PWR_I2S4_BIT, 0),
	SND_SOC_DAPM_AIF_IN("AIF1RX", "AIF1 Playback", 0,
				SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_AIF_OUT("AIF1TX", "AIF1 Capture", 0,
				SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_MICBIAS("I2S1PWR", CM7120_PWR_DIG1,
				CM7120_PWR_I2S1_BIT, 0),

};

static const struct snd_soc_dapm_route cm7120_dapm_routes[] = {
	{ "ADC1/2", NULL, "IN1" },
	{ "ADC1/2", NULL, "IN2" },
	{ "ADC3/4", NULL, "IN3" },
	{ "ADC3/4", NULL, "IN4" },
	{ "Microphone From Mux", "ADC1/2", "ADC1/2" },
	{ "Microphone From Mux", "ADC3/4", "ADC3/4" },
	{ "DAC1PGA", NULL, "AIF2RX" },
	{ "DAC2PGA", NULL, "AIF2RX" },
	{ "DAC3PGA", NULL, "AIF1RX" },
	{ "I2S3PWR", NULL, "AIF2RX" },
	{ "I2S3PWR", NULL, "AIF1RX" },
	{ "I2S1PWR", NULL, "AIF1RX" },
	{ "I2S4PWR", NULL, "I2S3PWR" },
	{ "DAC1", NULL, "DAC1PGA" },
	{ "DAC2", NULL, "DAC2PGA" },
	{ "DAC3", NULL, "DAC3PGA" },
	{ "HP Driver", NULL, "DAC1" },
	{ "HP Driver", NULL, "DAC2" },
	{ "HP Driver", NULL, "DAC3" },
	{ "SPK Driver", NULL, "I2S4PWR" },
	{ "SPK Driver", NULL, "I2S1PWR" },
	{ "OUTPUT MIX", "HP Switch", "HP Driver" },
	{ "OUTPUT MIX", "SPK Switch", "SPK Driver" },
	{ "OUTL", NULL, "OUTPUT MIX" },
	{ "OUTR", NULL, "OUTPUT MIX" },
	{ "AIF2TX", NULL, "Microphone From Mux" },
	{ "I2S1PWR", NULL, "Microphone From Mux" },
	{ "I2S3PWR", NULL, "Microphone From Mux" },
	{ "AIF1TX", NULL, "I2S1PWR" },
	{ "AIF1TX", NULL, "I2S3PWR" },
	{ "AIF1 Capture", NULL, "AIF1TX" },
	{ "AIF2 Capture", NULL, "AIF2TX" },
};

static ssize_t cm7120_is_dsp_mode_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);

	return snprintf(buf, 3, "%c\n", cm7120->is_dsp_mode ? 'Y' : 'N');
}
static DEVICE_ATTR(is_dsp_mode, 0444, cm7120_is_dsp_mode_show, NULL);

static u32 param_parsing(char *buf, u32 Count, u32 *dwAddr, u32 *dwData)
{
	char *p = NULL, *ptr = NULL;
	char *Param[2] = { 0 };
	int err = 0;
	u32 dwIdx = 0, dwParamCount = 0;
	*dwAddr = 0;
	*dwData = 0;

	p = buf;
	do {
		for (; dwIdx < Count; dwIdx++) {
			ptr = strnchr(hextext, strlen(hextext), *p);
			if (ptr)
				break;
			p++;
		}

		if (dwIdx == Count)
			break;
		if (dwParamCount < 2)
			Param[dwParamCount] = p;

		dwParamCount++;
		for (; dwIdx < Count; dwIdx++) {
			ptr = strnchr(hextext, strlen(hextext), *p);
			if (ptr == NULL) {
				*p = 0;
				p++;
				dwIdx++;
				break;
			}
			*p = tolower(*p);
			p++;
		}
	} while (dwIdx < Count);

	if (Param[0]) {
		if (Param[0][0] == '0' && Param[0][1] == 'x')
			err = kstrtou32(Param[0], 16, dwAddr);
		else
			err = kstrtou32(Param[0], 10, dwAddr);

		if (err)
			return err;

		pr_debug("%s Param[0] = %s dwAddr = %d\n", __func__, Param[0],
			 *dwAddr);
	}

	if (Param[1]) {
		if (Param[1][0] == '0' && Param[1][1] == 'x')
			err = kstrtou32(Param[1], 16, dwData);
		else
			err = kstrtou32(Param[1], 10, dwData);

		if (err)
			return err;

		pr_debug("%s Param[1] = %s dwData = %d\n", __func__, Param[1],
			 *dwData);
	}

	return dwParamCount;
}

static ssize_t cm7120_Codec_Reg_Show(struct device *dev,
				     struct device_attribute *attr, char *buf)
{
	struct cm7120_priv *cm7120 = dev_get_drvdata(dev);
	u32 dwValue = 0;

	if (cm7120->is_dsp_mode)
		cm7120_dsp_mode_i2c_read(cm7120, CodecAddr, &dwValue);
	else
		regmap_read(cm7120->real_regmap, CodecAddr, &dwValue);

	dwValue = dwValue & 0xFFFF;
	return scnprintf(buf, PAGE_SIZE, "0x%04x\n", dwValue);
}

static ssize_t cm7120_Codec_Reg_Set(struct device *dev,
				    struct device_attribute *attr,
				    const char *buf, size_t count)
{
	struct cm7120_priv *cm7120 = dev_get_drvdata(dev);
	u32 dwAddr = 0, dwData = 0;
	u32 dwParamCount;
	u32 dwValue = 0;

	dwParamCount = param_parsing((char *)buf, (u32)count, &dwAddr, &dwData);
	dwAddr = dwAddr & 0xFFFF;
	dwData = dwData & 0xFFFF;

	cm7120_dsp_mode_i2c_read(cm7120, 0x00fe, &dwValue);
	dwValue = dwValue & 0xFFFF;

	if (dwValue == 0x0000)
		cm7120->is_dsp_mode = false;
	else
		cm7120->is_dsp_mode = true;

	if (dwParamCount == 1)
		CodecAddr = dwAddr;
	else if (dwParamCount == 2) {
		CodecAddr = dwAddr;
		if (cm7120->is_dsp_mode)
			cm7120_dsp_mode_i2c_write(cm7120, CodecAddr, dwData);
		else
			regmap_write(cm7120->real_regmap, CodecAddr, dwData);
	}

	pr_debug("%s %s BufLen=%zu dwParamCount = %d\n", __func__, buf, count,
		 dwParamCount);

	return count;
}

static int cm7120_dsp_mode_i2c_read_mem(struct regmap *regmap, u32 uAddr,
					u32 *Data)
{
	u32 AddrRegL;
	u32 AddrRegH;
	u32 DataReg;
	int ret = -EIO;

	if (uAddr & 0x03)
		return ret;

	ret = 0;
	AddrRegL = uAddr & 0xffff;
	AddrRegH = uAddr >> 16;
	regmap_write(regmap, 0x01, AddrRegL);
	regmap_write(regmap, 0x02, AddrRegH);
	regmap_write(regmap, 0x00, 0x02);
	regmap_read(regmap, 0x03, &DataReg);
	*Data = DataReg & 0xFFFF;
	regmap_read(regmap, 0x04, &DataReg);
	*Data |= (DataReg & 0xFFFF) << 16;

	return ret;
}

static int cm7120_dsp_mode_i2c_write_mem(struct regmap *regmap, u32 uAddr,
					 u8 *Data, int len)
{
	int count, idx;
	u32 AddrRegL;
	u32 AddrRegH;
	u32 DataRegL;
	u32 DataRegH;
	int ret = 0;

	if (0 == (uAddr & 0x03)) {
		if (0 != (len & 0x03)) {
			count = len >> 2;
			for (idx = 0; idx < count; idx++) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = Data[2] | (Data[3] << 8);
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
				uAddr += 4;
				Data += 4;
			}
		} else {
			count = len >> 2;
			for (idx = 0; idx < count; idx++) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = Data[2] | (Data[3] << 8);
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
				uAddr += 4;
				Data += 4;
			}
			if (1 == (len & 0x03)) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0];
				DataRegH = 0;
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
			} else if (2 == (len & 0x03)) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = 0;
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
			} else if (3 == (len & 0x03)) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = Data[2];
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
			}
		}
	} else
		ret = -EIO;

	return ret;
}

static ssize_t cm7120_Dsp_Mem_Show(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	struct cm7120_priv *cm7120 = dev_get_drvdata(dev);
	u32 dwValue = 0;

	if (cm7120->is_dsp_mode) {
		mutex_lock(&cm7120->dsp_lock);
		cm7120_dsp_mode_i2c_read_mem(cm7120->real_regmap, DspAddr,
					     &dwValue);
		mutex_unlock(&cm7120->dsp_lock);
	}

	return scnprintf(buf, PAGE_SIZE, "0x%08x\n", dwValue);
}

static ssize_t cm7120_Dsp_Mem_Set(struct device *dev,
				  struct device_attribute *attr,
				  const char *buf, size_t count)
{
	struct cm7120_priv *cm7120_codec = dev_get_drvdata(dev);
	u32 dwAddr = 0, dwData = 0;
	u32 dwParamCount;

	dwParamCount = param_parsing((char *)buf, (u32)count, &dwAddr, &dwData);

	if (dwParamCount == 1) {
		DspAddr = dwAddr;
	} else if (dwParamCount == 2) {
		DspAddr = dwAddr;
		if (cm7120_codec->is_dsp_mode) {
			mutex_lock(&cm7120_codec->dsp_lock);
			cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap,
					DspAddr, (u8 *) &dwData, 4);
			mutex_unlock(&cm7120_codec->dsp_lock);
		}
	}

	pr_debug("%s %s BufLen=%zu dwParamCount = %d\n", __func__, buf,
		count, dwParamCount);

	return count;
}

static DEVICE_ATTR(cm7120codec, 0664, cm7120_Codec_Reg_Show,
		   cm7120_Codec_Reg_Set);
static DEVICE_ATTR(cm7120dsp, 0644, cm7120_Dsp_Mem_Show, cm7120_Dsp_Mem_Set);

static int cm7120_set_bias_level(struct snd_soc_component *component,
				 enum snd_soc_bias_level level)
{
	switch (level) {
	case SND_SOC_BIAS_ON:
		break;

	case SND_SOC_BIAS_PREPARE:
		break;

	case SND_SOC_BIAS_STANDBY:
		break;

	case SND_SOC_BIAS_OFF:
		break;

	default:
		break;
	}
	component->dapm.bias_level = level;

	return 0;
}

static int cm7120_pm_notify(struct notifier_block *nb,
				unsigned long mode, void *_unused)
{
	struct cm7120_priv *cm7120_codec =
			container_of(nb, struct cm7120_priv, pm_nb);
	u32 version = 0;

	cm7120_dsp_mode_i2c_read_addr(cm7120_codec,
			CM7120_DSP_CHECK_VERSION_REG, &version);

	switch (mode) {
	case PM_SUSPEND_PREPARE:
		cancel_work_sync(&cm7120_codec->fw_download_work);
		break;
	case PM_POST_SUSPEND:
		if (version == 0)
			schedule_work(&cm7120_codec->fw_download_work);
		break;
	default:
		break;
	}
	return 0;
}

static void cm7120_hp_det_report(struct work_struct *work)
{
	int i;
	bool value = false;
	struct delayed_work *dwork;
	struct cm7120_priv *cm7120_codec;

	dwork = to_delayed_work(work);
	cm7120_codec = container_of(dwork, struct cm7120_priv, hp_det_dwork);

	for (i = 0; i < cm7120_codec->hp_count; i++) {
		value |= !gpio_get_value(cm7120_codec->hp_irq_gpios[i]);
		dev_dbg(cm7120_codec->dev,
			       "%s gpio value = %d\n", __func__, value);
	}

	if (cm7120_codec->hp_inserted && !value) {
		snd_soc_jack_report(&cm7120_codec->jack, 0, CM7120_JACK_MASK);
		cm7120_codec->hp_inserted = false;
	} else if (!cm7120_codec->hp_inserted && value) {
		snd_soc_jack_report(&cm7120_codec->jack,
				SND_JACK_HEADPHONE, CM7120_JACK_MASK);
		cm7120_codec->hp_inserted = true;
	}
}

static irqreturn_t cm7120_headset_det_irq_thread(int irq, void *data)
{
	struct cm7120_priv *cm7120_codec;

	cm7120_codec = (struct cm7120_priv *)data;
	cancel_delayed_work_sync(&cm7120_codec->hp_det_dwork);
	schedule_delayed_work(&cm7120_codec->hp_det_dwork,
			msecs_to_jiffies(500));

	return IRQ_HANDLED;
}

static int cm7120_parse_dt_hp_det(struct cm7120_priv *cm7120_codec)
{
	struct device *dev;
	struct device_node *np;
	int i, rc;

	dev = cm7120_codec->dev;
	np = dev->of_node;
	cm7120_codec->card = cm7120_codec->component->card;

	if (!np)
		return -EINVAL;

	cm7120_codec->hp_count = of_gpio_named_count(dev->of_node,
						"cm7120,headphone-det-gpios");
	if (cm7120_codec->hp_count < 0) {
		dev_warn(dev, "Audio jack detection is not supported.\n");
		return 0;
	}

	cm7120_codec->hp_irq_gpios = devm_kcalloc(dev,
		cm7120_codec->hp_count, sizeof(*cm7120_codec->hp_irq_gpios),
		GFP_KERNEL);
	if (!cm7120_codec->hp_irq_gpios) {
		dev_err(dev, "Cannot allocate hp irq gpios array");
		rc = -ENOMEM;
		goto error;
	}

	cm7120_codec->hp_irqs = devm_kcalloc(dev,
		     cm7120_codec->hp_count, sizeof(*cm7120_codec->hp_irqs),
		     GFP_KERNEL);
	if (!cm7120_codec->hp_irqs) {
		dev_err(dev, "Cannot allocate hp irq array");
		rc = -ENOMEM;
		goto error;
	}

	for (i = 0; i < cm7120_codec->hp_count; i++) {
		rc = of_get_named_gpio(np, "cm7120,headphone-det-gpios", i);
		if (!gpio_is_valid(rc)) {
			dev_err(dev, "gpio %d is invalid\n", i);
			rc = -EINVAL;
			goto error;
		}
		cm7120_codec->hp_irq_gpios[i] = rc;

		rc = devm_gpio_request(dev, cm7120_codec->hp_irq_gpios[i],
				"cm7120-hp-det");
		if (rc) {
			dev_err(dev, "cm7120-hp-det gpio request fail\n");
			rc = -EINVAL;
			goto error;
		}

		rc = gpio_direction_input(cm7120_codec->hp_irq_gpios[i]);
		if (rc) {
			dev_err(dev, "cm7120-hp-det input fail\n");
			rc = -EINVAL;
			goto error;
		}

		cm7120_codec->hp_irqs[i] =
			gpio_to_irq(cm7120_codec->hp_irq_gpios[i]);
		rc = devm_request_threaded_irq(dev, cm7120_codec->hp_irqs[i],
			NULL, cm7120_headset_det_irq_thread,
			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
			IRQF_ONESHOT, "cm7120-hp-det", cm7120_codec);
		if (rc != 0) {
			dev_err(dev, "Failed to request IRQ %d: %d\n",
				cm7120_codec->hp_irqs[i], rc);
			rc = -EINVAL;
			goto error;
		}

		rc = enable_irq_wake(cm7120_codec->hp_irqs[i]);
		if (rc) {
			dev_err(dev,
				"Failed to set wake interrupt on IRQ %d: %d\n",
				cm7120_codec->hp_irqs[i], rc);
			rc = -EINVAL;
			goto error;
		}
	}

	INIT_DELAYED_WORK(&cm7120_codec->hp_det_dwork, cm7120_hp_det_report);
	rc = snd_soc_card_jack_new(cm7120_codec->card, "CM7120 Headphone",
		CM7120_JACK_MASK, &cm7120_codec->jack, NULL, 0);
	if (rc < 0) {
		dev_err(dev, "Cannot create jack\n");
		rc = -EINVAL;
		goto error;
	}

	schedule_delayed_work(&cm7120_codec->hp_det_dwork,
			msecs_to_jiffies(200));
	return 0;

error:
	return rc;
}

static int cm7120_probe(struct snd_soc_component *component)
{
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	const char *firmware_name;
	int ret = 0;

	dev_info(cm7120->dev, "Codec driver version %s\n", VERSION);

	cm7120->component = component;

	ret = cm7120_parse_dt_hp_det(cm7120);
	if (ret < 0) {
		dev_err(cm7120->dev, "cm7120_parse_dt_hp_det error\n");
		return ret;
	}

	ret = of_property_read_string(cm7120->dev->of_node,
			"cm7120,firmware-name", &firmware_name);
	if (!ret) {
		cm7120->fw_name = devm_kstrdup(cm7120->dev,
				firmware_name, GFP_KERNEL);
		dev_dbg(cm7120->dev, "CM7120 firmware: %s\n", firmware_name);
	} else {
		dev_err(cm7120->dev, "get CM7120 firmware name failed\n");
		return ret;
	}

	/* enable clock */
	cm7120->mclk = clk_get(cm7120->dev, "cm7120_mclk");
	if (IS_ERR(cm7120->mclk)) {
		dev_err(cm7120->dev, "get CM7120 MCLK error, %p\n",
			PTR_ERR(cm7120->mclk));
		return PTR_ERR(cm7120->mclk);
	}

	ret = clk_prepare_enable(cm7120->mclk);
	if (ret < 0) {
		dev_err(cm7120->dev, "enable CM7120 MCLK error\n");
		return ret;
	}

	dev_info(cm7120->dev, "enable CM7120 MCLK success\n");
	msleep(20);

	mutex_init(&cm7120->dsp_lock);

	ret = device_create_file(component->dev, &dev_attr_cm7120codec);
	if (ret) {
		dev_err(component->dev, "error creating codec sysfs files\n");
		return ret;
	}

	ret = device_create_file(component->dev, &dev_attr_cm7120dsp);
	if (ret) {
		dev_err(component->dev, "error creating dsp sysfs files\n");
		return ret;
	}

	ret = device_create_file(component->dev, &dev_attr_is_dsp_mode);
	if (ret != 0) {
		dev_err(component->dev,
			"Failed to create is_dsp_mode sysfs files: %d\n", ret);
		return ret;
	}

	cm7120_set_bias_level(component, SND_SOC_BIAS_OFF);

	cm7120->pm_nb.notifier_call = cm7120_pm_notify;
	register_pm_notifier(&cm7120->pm_nb);

	ret = cm7120_download_firmware(cm7120);

	complete_all(&cm7120->fw_download_complete);

	pr_info("%s: finished.\n", __func__);

	return ret;
}

static void cm7120_remove(struct snd_soc_component *component)
{
	cm7120_set_bias_level(component, SND_SOC_BIAS_OFF);

	device_remove_file(component->dev, &dev_attr_cm7120dsp);
	device_remove_file(component->dev, &dev_attr_cm7120codec);
	device_remove_file(component->dev, &dev_attr_is_dsp_mode);
}

#ifdef CONFIG_PM
static int cm7120_suspend(struct snd_soc_component *component)
{
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	int ret;

	regmap_write(cm7120_codec->virt_regmap, CM7120_RESET, 0x10ec);

	clk_disable_unprepare(cm7120_codec->mclk);
	ret = pinctrl_select_state(cm7120_codec->pinctrl,
				cm7120_codec->pin_spk_suspend);
	if (ret)
		dev_err(cm7120_codec->dev, "pin_spk_suspend error");
	ret = pinctrl_select_state(cm7120_codec->pinctrl,
				cm7120_codec->pin_suspend);
	if (ret)
		dev_err(cm7120_codec->dev, "pin_suspend error");
	usleep_range(1000, 1100);

	ret = regulator_disable(cm7120_codec->codec_3v3);
	if (ret < 0)
		dev_err(cm7120_codec->dev, "codec_3v3 disable failed\n");

	usleep_range(1000, 1100);

	ret = regulator_disable(cm7120_codec->codec_1v8);
	if (ret < 0)
		dev_err(cm7120_codec->dev, "codec_1v8 disable failed\n");

	cm7120_codec->is_dsp_mode = false;

	/*
	* Reinitialize completion since powering off regulators requires
	* a firmware reload before any audio playback function will work.
	*/
	reinit_completion(&cm7120_codec->fw_download_complete);

	return 0;
}

static int cm7120_resume(struct snd_soc_component *component)
{
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	int ret;

	ret = regulator_enable(cm7120_codec->codec_1v8);
	if (ret < 0)
		dev_err(cm7120_codec->dev, "codec_1v8 enable failed\n");
	usleep_range(1000, 1100);

	ret = regulator_enable(cm7120_codec->codec_3v3);
	if (ret < 0)
		dev_err(cm7120_codec->dev, "codec_3v3 enable failed\n");
	usleep_range(1000, 1100);

	ret = pinctrl_select_state(cm7120_codec->pinctrl,
				cm7120_codec->pin_active);
	if (ret)
		dev_err(cm7120_codec->dev, "pin_active error");

	clk_prepare_enable(cm7120_codec->mclk);
	usleep_range(2000, 2100);
	regmap_write(cm7120_codec->real_regmap, CM7120_RESET, 0x10ec);

	return 0;
}
#else
#define cm7120_suspend NULL
#define cm7120_resume NULL
#endif

static int cm7120_i2c_read(void *context, unsigned int reg, unsigned int *val)
{
	struct i2c_client *client = context;
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);

	if (cm7120->is_dsp_mode)
#ifndef DSP_MODE_USE_SPI
		cm7120_dsp_mode_i2c_read(cm7120, reg, val);
#else
		cm7120_spi_read(0x1800c000 + reg * 2, val, 2);
#endif
	else
		regmap_read(cm7120->real_regmap, reg, val);

	return 0;
}

static int cm7120_i2c_write(void *context, unsigned int reg, unsigned int val)
{
	struct i2c_client *client = context;
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);

	if (cm7120->is_dsp_mode)
#ifndef DSP_MODE_USE_SPI
		cm7120_dsp_mode_i2c_write(cm7120, reg, val);
#else
		cm7120_spi_write(0x1800c000 + reg * 2, val, 2);
#endif
	else
		regmap_write(cm7120->real_regmap, reg, val);

	return 0;
}

#define CM7120_STEREO_RATES SNDRV_PCM_RATE_48000
#define CM7120_FORMATS                                                         \
	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |                  \
	 SNDRV_PCM_FMTBIT_S24_LE)

struct snd_soc_dai_ops cm7120_aif_dai_ops = {
	.hw_params = cm7120_hw_params,
};

struct snd_soc_dai_driver cm7120_dai[] = {
	{
		.name = "cm7120-aif2",
		.id = CM7120_AIF2,
		.playback = {
			.stream_name = "AIF2 Playback",
			.channels_min = 1,
			.channels_max = 2,
			.rates = CM7120_STEREO_RATES,
			.formats = CM7120_FORMATS,
		},
		.capture = {
			.stream_name = "AIF2 Capture",
			.channels_min = 1,
			.channels_max = 2,
			.rates = CM7120_STEREO_RATES,
			.formats = CM7120_FORMATS,
		},
		.ops = &cm7120_aif_dai_ops,
		.symmetric_rates = 1,
	},
	{
		.name = "cm7120-aif1",
		.id = 0,
		.base = CM7120_AIF1,
		.playback = {
			.stream_name = "AIF1 Playback",
			.channels_min = 1,
			.channels_max = 2,
			.rates = CM7120_STEREO_RATES,
			.formats = CM7120_FORMATS,
		},
		.capture = {
			.stream_name = "AIF1 Capture",
			.channels_min = 1,
			.channels_max = 2,
			.rates = CM7120_STEREO_RATES,
			.formats = CM7120_FORMATS,
		},
		.ops = &cm7120_aif_dai_ops,
		.symmetric_rates = 1,
	},
};

static struct snd_soc_component_driver soc_component_dev_cm7120 = {
	.name = "cm7120",
	.probe = cm7120_probe,
	.remove = cm7120_remove,
	.suspend = cm7120_suspend,
	.resume = cm7120_resume,
	.set_bias_level = cm7120_set_bias_level,
	.controls = cm7120_snd_controls,
	.num_controls = ARRAY_SIZE(cm7120_snd_controls),
	.dapm_widgets = cm7120_dapm_widgets,
	.num_dapm_widgets = ARRAY_SIZE(cm7120_dapm_widgets),
	.dapm_routes = cm7120_dapm_routes,
	.num_dapm_routes = ARRAY_SIZE(cm7120_dapm_routes),
};

static const struct regmap_config cm7120_regmap_physical = {
	.name = "physical",
	.reg_bits = 16,
	.val_bits = 16,

	.max_register = CM7120_DUMMY_REG_4,
	.readable_reg = cm7120_readable_register,

	.cache_type = REGCACHE_NONE,
};

static const struct regmap_config cm7120_regmap = {
	.reg_bits = 16,
	.val_bits = 16,

	.max_register = CM7120_DUMMY_REG_4,
	.volatile_reg = cm7120_volatile_register,
	.readable_reg = cm7120_readable_register,
	.reg_read = cm7120_i2c_read,
	.reg_write = cm7120_i2c_write,

	.cache_type = REGCACHE_RBTREE,
	.reg_defaults = cm7120_reg,
	.num_reg_defaults = ARRAY_SIZE(cm7120_reg),
};

static const struct i2c_device_id cm7120_i2c_id[] = {
	{ "cm7120", 1 /* CM7120 */ },
	{}
};
MODULE_DEVICE_TABLE(i2c, cm7120_i2c_id);

#if defined(CONFIG_OF)
static const struct of_device_id cm7120_of_match[] = {
	{.compatible = "C-Media,cm7120",},
	{},
};
MODULE_DEVICE_TABLE(of, cm7120_of_match);
#endif

static int cm7120_download_firmware(struct cm7120_priv *cm7120_codec)
{
	u32 version = 0;
	int ret = 0;

	dev_info(cm7120_codec->dev, "%s entry\n", __func__);

	ret = request_firmware(&cm7120_codec->fw, cm7120_codec->fw_name,
			       cm7120_codec->dev);
	if (ret) {
		dev_err(cm7120_codec->dev, "%s: request_firmware failed: %d\n",
			__func__, ret);
		return ret;
	}

	dev_info(cm7120_codec->dev,
		 "%s(): ready to parser, bin file size = %d\n", __func__,
		 cm7120_codec->fw->size);

	ret = cm7120_firmware_parsing(cm7120_codec,
				      (void *)cm7120_codec->fw->data,
				      cm7120_codec->fw->size);
	release_firmware(cm7120_codec->fw);
	if (ret) {
		dev_err(cm7120_codec->dev,
			"%s: cm7120_firmware_parsing failed: %d\n", __func__,
			ret);
		return ret;
	}

	msleep(30);

	/* trigger DSP FW run */
	/* bit-0 is 0 */
	regmap_update_bits(cm7120_codec->virt_regmap, CM7120_PWR_DSP, 0x1, 0x0);
	msleep(30);

	cm7120_dsp_mode_i2c_read_addr(cm7120_codec,
			CM7120_DSP_CHECK_VERSION_REG, &version);
	pr_info("%s (%d): DSP version = 0x%08x\n", __func__, __LINE__, version);

	return 0;
}

static int cm7120_write_firmware_romcode(struct cm7120_priv *cm7120,
					 u8 *binFile, int blockNum)
{
	u32 blockAddr;
	u32 blockSize;
	u32 tmpBlockSize;
	int i, ret;
	const int headerBlockInfo = 8;

	u8 *fwHeader = binFile + 0x1e000 + headerBlockInfo;
	u8 *fwData = binFile + 0x1e000 + headerBlockInfo + (8 * blockNum);

	/* multifunction SPI select */
	/* 0x00c1 */
	regmap_write(cm7120->virt_regmap, CM7120_MF_PIN_CTRL2, 0x1e01);

	for (i = 0; i < blockNum; i++) {
		blockAddr = *(fwHeader + (i * 8) + 0) << 0 |
			*(fwHeader + (i * 8) + 1) << 8 |
			*(fwHeader + (i * 8) + 2) << 16 |
			*(fwHeader + (i * 8) + 3) << 24;
		pr_info("block[%d] address = 0x%08x\n", i, blockAddr);

		blockSize = *(fwHeader + (i * 8) + 4) << 0 |
			*(fwHeader + (i * 8) + 5) << 8 |
			*(fwHeader + (i * 8) + 6) << 16 |
			*(fwHeader + (i * 8) + 7) << 24;
		pr_info("block[%d] size = 0x%08x\n", i, blockSize);

		tmpBlockSize = blockSize; /* Backup */
		if (blockSize % 8) {
			blockSize = 8 * ((blockSize / 8) + 1);
			pr_info("block[%d] isn't multiple of 8, new size = 0x%08x\n",
			i, blockSize);
		}

		ret = cm7120_spi_burst_write(blockAddr, fwData, blockSize);
		if (ret < 0) {
			pr_err("%s: cm7120_spi_burst_write() failed!!!\n",
			       __func__);
			return ret;
		}
		pr_info("block[%d] ---- write successfully ----\n", i);

		blockSize = tmpBlockSize; /* Restore */
		fwData += blockSize;
	}

	return 0;
}

static int cm7120_write_firmware_codec_cmd(struct cm7120_priv *cm7120,
					   u8 *ConfigData, int count)
{
	u16 uAddr;
	u16 uValue;
	u8 uRegDelay;

	int i;
	int ret = 0;

	pr_info("%s: register count = %d\n", __func__, count);

	for (i = 0; i < count; i++) {
		uAddr = ConfigData[i * 5 + 0] | ConfigData[i * 5 + 1] << 8;
		uValue = ConfigData[i * 5 + 2] | ConfigData[i * 5 + 3] << 8;
		uRegDelay = ConfigData[i * 5 + 4];

		ret = regmap_write(cm7120->virt_regmap, uAddr, uValue);
		if (ret < 0) {
			pr_err("%s: Codec Init Failed in I2C failed in Command (%d)\n",
					__func__, i);
			return ret;
		}

		if (uRegDelay >= 20)
			msleep(uRegDelay);
		else
			usleep_range(uRegDelay * 1000, uRegDelay * 1000 + 500);

		/* the last one i2c cmd is for enable DSP for flash load code */
		if ((i == 0) || (i == (count - 1)))
			pr_info("[%d]: uAddr = 0x%04x, uValue = 0x%04x, uDelay = 0x%02x\n",
				i, uAddr, uValue, uRegDelay);
	}

	return 0;
}

static int cm7120_firmware_checksum(void *FirmwareData, u8 checksum, size_t len)
{
	u8  *fwData = FirmwareData;
	u8  uSum = 0;
	int i;

	for (i = 0; i < len; i++)
		uSum += fwData[i];
	checksum = checksum - 1 + uSum;
	checksum = ~checksum;

	return (checksum == 0);
}

static int cm7120_firmware_parsing(struct cm7120_priv *cm7120,
				   void *FirmwareData, size_t len)
{
	u8 *fwData = FirmwareData;
	u32 regAddr = 0;

	int ret;
	int count;
	int i, lSize;
	u8  *fwPtr;

	/* check header of block */
	/* offset [3:0] = 0x0a, 0x1c, 0x56, 0x79 */
	regAddr = 0x7A000;
	dev_info(cm7120->dev, "%s: Factory Register Setting: addr = 0x%08x\n",
		 __func__, regAddr);

	/* register number: 0x7A000 offset [5:4], little endian */
	count = *(fwData + regAddr + 4) | *(fwData + regAddr + 5) << 8;
	pr_info("register count = %d\n", count);

	if (!cm7120_firmware_checksum(fwData + regAddr + 8,
				*(fwData + regAddr + 6), count*5)) {
		pr_err("%s: Register Setting checksum failed!\n", __func__);
		return -EINVAL;
	}

	/* offset [4:5] = register number count */
	/* offset [6:7] = checksum */
	/* offset [8:N] = register pair data */
	ret = cm7120_write_firmware_codec_cmd(cm7120, fwData + regAddr + 8,
					      count);

	if (ret == 0)
		cm7120->is_dsp_mode = true;

	/* Factory Hifi-3 Firmware / DSP code */
	regAddr = 0x1E000;
	dev_info(cm7120->dev,
		 "%s: Factory Hifi-3 Firmware / DSP code: addr = 0x%08x\n",
		 __func__, regAddr);

	/* block number: 0x1E000 offset [5:4], little endian */
	count = *(fwData + regAddr + 4) | *(fwData + regAddr + 5) << 8;
	pr_info("block number = %d\n", count);

	lSize = 0;
	fwPtr = fwData + regAddr + 8;
	for (i = 0; i < count; i++) {
		lSize += *(fwPtr + 4) | (*(fwPtr + 5) << 8) |
			(*(fwPtr + 6) << 16) | (*(fwPtr + 7) << 24);
		lSize += 8;
		fwPtr += 8;
	}

	if (!cm7120_firmware_checksum(fwData + regAddr + 8,
				*(fwData + regAddr + 6), lSize)) {
		pr_err("%s: Hifi-3 dsp code checksum failed!\n", __func__);
		return -EINVAL;
	}

	ret = cm7120_write_firmware_romcode(cm7120, fwData, count);

	pr_info("%s: cm7120_write_firmware_romcode() dsp load code successfully.\n",
			__func__);

	return 0;
}

static void cm7120_firmware_download_work(struct work_struct *work)
{
	struct cm7120_priv *cm7120_codec =
		container_of(work, struct cm7120_priv, fw_download_work);
	int ret = 0;

	dev_info(cm7120_codec->dev, "%s entry\n", __func__);

	ret = cm7120_download_firmware(cm7120_codec);

	complete_all(&cm7120_codec->fw_download_complete);
}
static int get_pin_control(struct cm7120_priv *cm7120)
{
	int rc = 0;

	if (!cm7120)
		return -EINVAL;

	cm7120->pinctrl = devm_pinctrl_get(cm7120->dev);
	if (IS_ERR_OR_NULL(cm7120->pinctrl)) {
		rc = PTR_ERR(cm7120->pinctrl);
		dev_err(cm7120->dev, "failed to get pinctrl, %d\n", rc);
		goto error;
	}

	cm7120->pin_active = pinctrl_lookup_state(cm7120->pinctrl, "active");
	if (IS_ERR_OR_NULL(cm7120->pin_active)) {
		rc = PTR_ERR(cm7120->pin_active);
		dev_err(cm7120->dev, "failed to get pinctrl active state\n");
		goto free_pinctrl;
	}

	cm7120->pin_suspend = pinctrl_lookup_state(cm7120->pinctrl, "suspend");
	if (IS_ERR_OR_NULL(cm7120->pin_suspend)) {
		rc = -EINVAL;
		dev_err(cm7120->dev, "failed to look up suspend pin state");
		goto free_pinctrl;
	}

	cm7120->pin_spk_en = pinctrl_lookup_state(cm7120->pinctrl, "spk_en");
	if (IS_ERR_OR_NULL(cm7120->pin_spk_en)) {
		rc = PTR_ERR(cm7120->pin_spk_en);
		dev_err(cm7120->dev, "failed to get spk_en pin state\n");
		goto free_pinctrl;
	}

	cm7120->pin_spk_suspend =
		pinctrl_lookup_state(cm7120->pinctrl, "spk_suspend");
	if (IS_ERR_OR_NULL(cm7120->pin_spk_suspend)) {
		rc = PTR_ERR(cm7120->pin_spk_suspend);
		dev_err(cm7120->dev, "failed to get spk_suspend pin state\n");
		goto free_pinctrl;
	}

	rc = pinctrl_select_state(cm7120->pinctrl, cm7120->pin_active);
	if (rc) {
		dev_err(cm7120->dev, "failed to set pinctrl active, %d\n", rc);
		goto free_pinctrl;
	}

	rc = pinctrl_select_state(cm7120->pinctrl, cm7120->pin_spk_suspend);
	if (rc) {
		dev_err(cm7120->dev, "failed to set spk pin suspend, %d\n", rc);
		goto free_pinctrl;
	}
	return rc;

free_pinctrl:
	devm_pinctrl_put(cm7120->pinctrl);
error:
	return rc;
}

static int cm7120_i2c_probe(struct i2c_client *i2c,
			    const struct i2c_device_id *id)
{
	struct cm7120_priv *cm7120;
	int count = 10;
	int ret;
	char *i2c_dev_name;

	dev_info(&i2c->dev, "%s entry\n", __func__);

	cm7120 =
		devm_kzalloc(&i2c->dev, sizeof(struct cm7120_priv), GFP_KERNEL);

	if (cm7120 == NULL)
		return -ENOMEM;

	cm7120->real_regmap =
		devm_regmap_init_i2c(i2c, &cm7120_regmap_physical);
	if (IS_ERR(cm7120->real_regmap)) {
		ret = PTR_ERR(cm7120->real_regmap);
		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
			ret);
		return ret;
	}
	cm7120->virt_regmap =
		devm_regmap_init(&i2c->dev, NULL, i2c, &cm7120_regmap);
	if (IS_ERR(cm7120->virt_regmap)) {
		ret = PTR_ERR(cm7120->virt_regmap);
		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
			ret);
		return ret;
	}
	cm7120->dev = &i2c->dev;
	i2c_set_clientdata(i2c, cm7120);

	/* regulator codec_1v8 */
	cm7120->codec_1v8 = regulator_get(cm7120->dev, "cm7120,codec_1v8");
	if (IS_ERR(cm7120->codec_1v8))
		dev_err(cm7120->dev, "codec_1v8 regulator_get error\n");

	ret = regulator_set_voltage(cm7120->codec_1v8, 1800000, 1800000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_1v8 set_voltage failed\n");

	ret = regulator_set_load(cm7120->codec_1v8, 300000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_1v8 set_load failed\n");

	ret = regulator_enable(cm7120->codec_1v8);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_1v8 regulator_enable failed\n");

	usleep_range(1000, 1100);

	/* regulator codec_3v3 */
	cm7120->codec_3v3 = regulator_get(cm7120->dev, "cm7120,codec_3v3");
	if (IS_ERR(cm7120->codec_3v3))
		dev_err(cm7120->dev, "codec_3v3 regulator_get error\n");

	ret = regulator_set_voltage(cm7120->codec_3v3, 3100000, 3100000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_3v3 set_voltage failed\n");

	ret = regulator_set_load(cm7120->codec_3v3, 300000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_3v3 set_load failed\n");

	ret = regulator_enable(cm7120->codec_3v3);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_3v3 regulator_enable failed\n");

	usleep_range(1000, 1100);

	ret = get_pin_control(cm7120);
	if (ret != 0) {
		dev_err(cm7120->dev, "Failed to get pin control\n");
		return ret;
	}

	while (count--) {
		regmap_read(cm7120->virt_regmap, CM7120_VENDOR_ID2, &ret);
		if (ret == CM7120_DEVICE_ID)
			break;

		if (!count) {
			dev_err(&i2c->dev,
				"Device with ID register %x is not cm7120\n",
				ret);
			return -ENODEV;
		}

		usleep_range(1000, 1500);
	}

	mutex_init(&cm7120->dsp_lock);

	regmap_write(cm7120->real_regmap, CM7120_RESET, 0x10ec);

	/* firmware download */
	INIT_WORK(&cm7120->fw_download_work, cm7120_firmware_download_work);
	init_completion(&cm7120->fw_download_complete);
	usleep_range(10000, 15000);

	/* Save I2C device name */
	i2c_dev_name = kstrdup(dev_name(&i2c->dev), GFP_KERNEL);
	/* Replace I2C device name with component name. This component name
	 * should be consistent with the codec name specified in the DAI link.
	 * In this way, the codec name no longer depends on the
	 * I2C bus-addr format like "1-002d".
	 */
	dev_set_name(&i2c->dev, "cm7120");
	ret = snd_soc_register_component(&i2c->dev, &soc_component_dev_cm7120,
					  cm7120_dai, ARRAY_SIZE(cm7120_dai));
	if (ret)
		dev_err(&i2c->dev, "Failed to register componet: %d\n", ret);
	/* Restore I2C device name. When requesting firmware later, the name
	 * of the I2C device will be used as the path to load the firmware
	 * through the kobject uevent of sysfs, for example:
	 * "devices/platform/soc/a80000.i2c/i2c-1/1-002d/firmware/CM7120.bin"
	 */
	dev_set_name(&i2c->dev, i2c_dev_name);
	kfree(i2c_dev_name);

	return ret;
}

static int cm7120_i2c_remove(struct i2c_client *i2c)
{
	snd_soc_unregister_component(&i2c->dev);

	return 0;
}

void cm7120_i2c_shutdown(struct i2c_client *client)
{
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);
	struct snd_soc_component *component = cm7120->component;

	if (component != NULL)
		cm7120_set_bias_level(component, SND_SOC_BIAS_OFF);

	clk_disable_unprepare(cm7120->mclk);
	pinctrl_select_state(cm7120->pinctrl, cm7120->pin_suspend);
	usleep_range(1000, 1100);
	regulator_disable(cm7120->codec_3v3);
	usleep_range(1000, 1100);
	regulator_disable(cm7120->codec_1v8);
}

struct i2c_driver cm7120_i2c_driver = {
	.driver = {
		.name = "cm7120",
		.of_match_table = cm7120_of_match,
	},
	.probe = cm7120_i2c_probe,
	.remove = cm7120_i2c_remove,
	.shutdown = cm7120_i2c_shutdown,
	.id_table = cm7120_i2c_id,
};
module_i2c_driver(cm7120_i2c_driver);

MODULE_DESCRIPTION("CM7120 CODEC driver");
MODULE_AUTHOR("Support <sales@cmedia.com.tw>");
MODULE_LICENSE("GPL v2");

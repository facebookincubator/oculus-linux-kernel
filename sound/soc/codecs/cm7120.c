/*
 * cm7120.c  --  CM7120 ALSA SoC audio component driver
 *
 * Author: Support <sales@cmedia.com.tw>
 *		Copyright 2019
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#include <linux/acpi.h>
#include <linux/fs.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/regmap.h>
#include <linux/i2c.h>
#include <linux/spi/spi.h>
#include <linux/platform_device.h>
#include <linux/firmware.h>
#include <linux/of_device.h>
#include <linux/gpio.h>
#include <linux/of_gpio.h>
#include <linux/clk.h>
#include <linux/regulator/consumer.h>
#include <linux/pinctrl/consumer.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/soc-dapm.h>
#include <sound/tlv.h>
#include <sound/jack.h>

#include "cm7120.h"
#include "cm7120-spi.h"

//#define DSP_MODE_USE_SPI

#define VERSION "0.0.6"
#define CM7120_FIRMWARE "CM7120.bin"
#define FW_DOWNLOAD_TIMEOUT (1 * HZ)

static u32 DspAddr = 0x5ffc001C;
static u32 CodecAddr = 0x3C;
static const char hextext[] = "0123456789abcdefxABCDEFX";

/* declare */
static int cm7120_download_firmware(struct cm7120_priv *cm7120_codec);
static void cm7120_firmware_download_work(struct work_struct *work);
static int cm7120_firmware_parsing(struct cm7120_priv *cm7120,
				   void *FirmwareData, size_t len);
static int cm7120_write_firmware_codec_cmd(struct cm7120_priv *cm7120,
					   u8 *I2CCommand, int count);
static int cm7120_write_firmware_romcode(struct cm7120_priv *cm7120,
					 u8 *RomCodeData, int count);

static int cm7120_dsp_mode_i2c_read_mem(struct regmap *regmap, u32 uAddr,
					u32 *Data);
static int cm7120_dsp_mode_i2c_write_mem(struct regmap *regmap, u32 uAddr,
					 u8 *Data, int len);
static void cm7120_update_eq_pregain_enable(struct cm7120_priv *cm7120_codec);
static int cm7120_get_vu(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_put_vu(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_get_eq_freq(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_put_eq_freq(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_get_eq_gain(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_put_eq_gain(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol);
static int cm7120_set_eqspk_value(struct cm7120_priv *cm7120_codec,
		struct EQSpkParam *pEQSpkParam, u32 uAddr);
static int cm7120_set_spktest_value(struct cm7120_priv *cm7120_codec,
		char i2s34, char mute);
static int cm7120_hw_params(struct snd_pcm_substream *substream,
		struct snd_pcm_hw_params *params,
		struct snd_soc_dai *dai);

static const struct reg_default cm7120_reg[] = {
	{ CM7120_RESET, 0x0000 },
	{ CM7120_LOUT, 0x8080 },
	{ CM7120_HP_OUT, 0x0000 },
	{ CM7120_MONO_OUT, 0x0000 },
	{ CM7120_BST12_CTRL, 0x0000 },
	{ CM7120_BST34_CTRL, 0x0000 },
	{ CM7120_VAD_INBUF_CTRL, 0x0005 },
	{ CM7120_CAL_ADC_MIXER_CTRL, 0x5455 },
	{ CM7120_MICBIAS1_CTRL1, 0x0091 },
	{ CM7120_MICBIAS1_CTRL2, 0x0000 },
	{ CM7120_DAC1_POST_DIG_VOL, 0x5757 },
	{ CM7120_DAC1_DIG_VOL, 0xafaf },
	{ CM7120_DAC2_DIG_VOL, 0xafaf },
	{ CM7120_DAC3_DIG_VOL, 0xafaf },
	{ CM7120_STO1_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_MONO_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_STO2_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_STO3_ADC_DIG_VOL, 0x2f2f },
	{ CM7120_ADC_BST_GAIN_CTRL1, 0x0000 },
	{ CM7120_ADC_BST_GAIN_CTRL2, 0x0000 },
	{ CM7120_ADC_BST_GAIN_CTRL3, 0x0000 },
	{ CM7120_SPDIF_IN_CTRL, 0x6000 },
	{ CM7120_IF3_DATA_CTRL, 0x0000 },
	{ CM7120_IF4_DATA_CTRL, 0x0000 },
	{ CM7120_IF5_DATA_CTRL, 0x0000 },
	{ CM7120_TDM1_CTRL1, 0x00f0 },
	{ CM7120_TDM1_CTRL2, 0x0000 },
	{ CM7120_TDM1_CTRL3, 0x0000 },
	{ CM7120_TDM1_CTRL4, 0x0000 },
	{ CM7120_TDM1_CTRL5, 0x0123 },
	{ CM7120_TDM1_CTRL6, 0x4567 },
	{ CM7120_TDM1_CTRL7, 0x8003 },
	{ CM7120_TDM2_CTRL1, 0x00f0 },
	{ CM7120_TDM2_CTRL2, 0x0000 },
	/* CM7120_TDM2_CTRL3 set to 0xc as the same with config */
	{ CM7120_TDM2_CTRL3, 0x000c },
	{ CM7120_TDM2_CTRL4, 0x0000 },
	{ CM7120_TDM2_CTRL5, 0x0123 },
	{ CM7120_TDM2_CTRL6, 0x4567 },
	{ CM7120_TDM2_CTRL7, 0x8003 },
	{ CM7120_STO1_DAC_MIXER_CTRL1, 0xcaaa },
	{ CM7120_STO1_DAC_MIXER_CTRL2, 0xaa00 },
	{ CM7120_MONO_DAC_MIXER_CTRL1, 0xcaaa },
	{ CM7120_MONO_DAC_MIXER_CTRL2, 0xaa00 },
	{ CM7120_DD_MIXER_CTRL1, 0xaaaa },
	{ CM7120_DD_MIXER_CTRL2, 0xaa00 },
	{ CM7120_DAC1_MIXER_CTRL, 0xb080 },
	{ CM7120_DAC2_MIXER_CTRL, 0x0000 },
	{ CM7120_DAC3_MIXER_CTRL, 0x0000 },
	{ CM7120_DAC_SOURCE_CTRL, 0x0000 },
	{ CM7120_STO1_ADC_MIXER_CTRL, 0xc0c0 },
	{ CM7120_MONO_ADC_MIXER_CTRL1, 0xc0c0 },
	{ CM7120_MONO_ADC_MIXER_CTRL2, 0x0000 },
	{ CM7120_STO2_ADC_MIXER_CTRL, 0xc0c0 },
	{ CM7120_STO3_ADC_MIXER_CTRL, 0xc0c0 },
	{ CM7120_DMIC_CTRL1, 0x0550 },
	{ CM7120_DMIC_CTRL2, 0x0055 },
	{ CM7120_HPF_CTRL1, 0x1e00 },
	{ CM7120_SV_ZCD_CTRL1, 0x0009 },
	{ CM7120_PWR_ADC, 0x0000 },
	{ CM7120_PWR_DIG1, 0x0000 },
	{ CM7120_PWR_DIG2, 0x0000 },
	{ CM7120_PWR_ANA1, 0x0040 },
	{ CM7120_PWR_ANA2, 0x0000 },
	{ CM7120_PWR_DSP, 0x0181 },
	{ CM7120_PWR_LDO1, 0x0000 },
	{ CM7120_PWR_LDO2, 0x0002 },
	{ CM7120_PWR_LDO3, 0x3703 },
	{ CM7120_PWR_LDO4, 0x0100 },
	{ CM7120_PWR_LDO5, 0x0000 },
	{ CM7120_I2S1_SDP, 0x8000 },
	{ CM7120_I2S2_SDP, 0x8000 },
	{ CM7120_I2S3_SDP, 0x8000 },
	{ CM7120_I2S4_SDP, 0x8000 },
	{ CM7120_I2S5_SDP, 0x8000 },
	{ CM7120_I2S_LRCK_BCLK_SOURCE, 0x0000 },
	{ CM7120_CLK_TREE_CTRL1, 0x7777 },
	{ CM7120_CLK_TREE_CTRL2, 0x7777 },
	{ CM7120_CLK_TREE_CTRL3, 0x7000 },
	{ CM7120_CLK_TREE_CTRL4, 0x3000 },
	{ CM7120_PLL1_CTRL1, 0x0000 },
	{ CM7120_PLL1_CTRL2, 0x0000 },
	{ CM7120_PLL2_CTRL1, 0x0000 },
	{ CM7120_PLL2_CTRL2, 0x0000 },
	{ CM7120_DSP_CLK_SOURCE1, 0x0111 },
	{ CM7120_DSP_CLK_SOURCE2, 0x0333 },
	{ CM7120_GLB_CLK1, 0x0000 },
	{ CM7120_GLB_CLK2, 0x0000 },
	{ CM7120_ASRC1, 0x0000 },
	{ CM7120_ASRC2, 0x0000 },
	{ CM7120_ASRC3, 0x0000 },
	{ CM7120_ASRC4, 0x0000 },
	{ CM7120_ASRC5, 0x0000 },
	{ CM7120_ASRC6, 0x0000 },
	{ CM7120_ASRC7, 0x0000 },
	{ CM7120_ASRC8, 0x0000 },
	{ CM7120_ASRC9, 0x0000 },
	{ CM7120_ASRC10, 0x0000 },
	{ CM7120_ASRC11, 0x0000 },
	{ CM7120_ASRC12, 0x0008 },
	{ CM7120_ASRC13, 0x0000 },
	{ CM7120_ASRC14, 0x0000 },
	{ CM7120_ASRC15, 0x0000 },
	{ CM7120_ASRC16, 0x0000 },
	{ CM7120_ASRC17, 0x0000 },
	{ CM7120_ASRC18, 0x0000 },
	{ CM7120_ASRC19, 0x0000 },
	{ CM7120_ASRC20, 0x0000 },
	{ CM7120_ASRC21, 0x0000 },
	{ CM7120_ASRC22, 0x0000 },
	{ CM7120_ASRC23, 0x0000 },
	{ CM7120_ASRC24, 0x0000 },
	{ CM7120_ASRC25, 0x000c },
	{ CM7120_FRAC_DIV_CTRL1, 0x0002 },
	{ CM7120_FRAC_DIV_CTRL2, 0x0001 },
	{ CM7120_JACK_MIC_DET_CTRL1, 0x7080 },
	{ CM7120_JACK_MIC_DET_CTRL2, 0x4a00 },
	{ CM7120_JACK_MIC_DET_CTRL3, 0x4e01 },
	{ CM7120_JACK_MIC_DET_CTRL4, 0xa000 },
	{ CM7120_JACK_DET_CTRL1, 0x0000 },
	{ CM7120_JACK_DET_CTRL2, 0x0000 },
	{ CM7120_JACK_DET_CTRL3, 0x0000 },
	{ CM7120_JACK_DET_CTRL4, 0x0000 },
	{ CM7120_JACK_DET_CTRL5, 0x0000 },
	{ CM7120_IRQ_ST1, 0x0000 },
	{ CM7120_IRQ_ST2, 0x0000 },
	{ CM7120_IRQ_CTRL1, 0x0000 },
	{ CM7120_IRQ_CTRL2, 0x0000 },
	{ CM7120_IRQ_CTRL3, 0x0000 },
	{ CM7120_IRQ_CTRL4, 0x0000 },
	{ CM7120_IRQ_CTRL5, 0x0000 },
	{ CM7120_IRQ_CTRL6, 0x0000 },
	{ CM7120_IRQ_CTRL7, 0x0000 },
	{ CM7120_IRQ_CTRL8, 0x0000 },
	{ CM7120_IRQ_CTRL9, 0x0000 },
	{ CM7120_MF_PIN_CTRL1, 0x2008 },
	{ CM7120_MF_PIN_CTRL2, 0x8600 },
	{ CM7120_MF_PIN_CTRL3, 0x0000 },
	{ CM7120_GPIO_CTRL1, 0x0000 },
	{ CM7120_GPIO_CTRL2, 0x0000 },
	{ CM7120_GPIO_CTRL3, 0x0000 },
	{ CM7120_GPIO_CTRL4, 0x0000 },
	{ CM7120_GPIO_CTRL5, 0x0000 },
	{ CM7120_GPIO_CTRL6, 0x0000 },
	{ CM7120_GPIO_ST1, 0x0000 },
	{ CM7120_GPIO_ST2, 0x0000 },
	{ CM7120_LP_DET_CTRL, 0x0300 },
	{ CM7120_STO1_ADC_HPF_CTRL1, 0xb320 },
	{ CM7120_STO1_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_MONO_ADC_HPF_CTRL1, 0xb300 },
	{ CM7120_MONO_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_STO2_ADC_HPF_CTRL1, 0xb300 },
	{ CM7120_STO2_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_STO3_ADC_HPF_CTRL1, 0xb300 },
	{ CM7120_STO3_ADC_HPF_CTRL2, 0x0000 },
	{ CM7120_ZCD_CTRL, 0x0000 },
	{ CM7120_IL_CMD1, 0x0008 },
	{ CM7120_IL_CMD2, 0x00c0 },
	{ CM7120_IL_CMD3, 0x6724 },
	{ CM7120_IL_CMD4, 0x3131 },
	{ CM7120_4BTN_IL_CMD1, 0x0008 },
	{ CM7120_4BTN_IL_CMD2, 0x4000 },
	{ CM7120_4BTN_IL_CMD3, 0x3131 },
	{ CM7120_PS_IL_CMD1, 0x402c },
	{ CM7120_DSP_OUTB_0123_MIXER_CTRL, 0xf8f8 },
	{ CM7120_DSP_OUTB_45_MIXER_CTRL, 0xf8f8 },
	{ CM7120_DSP_OUTB_67_MIXER_CTRL, 0xf8f8 },
	{ CM7120_MCLK_GATING_CTRL, 0x0000 },
	{ CM7120_VENDOR_ID, 0x0000 },
	{ CM7120_VENDOR_ID1, 0x10ec },
	{ CM7120_VENDOR_ID2, 0x6385 },
	{ CM7120_PDM_OUTPUT_CTRL, 0xc0c0 },
	{ CM7120_PDM1_CTRL1, 0x0000 },
	{ CM7120_PDM1_CTRL2, 0x0000 },
	{ CM7120_PDM1_CTRL3, 0x0000 },
	{ CM7120_PDM1_CTRL4, 0x0000 },
	{ CM7120_PDM1_CTRL5, 0x0000 },
	{ CM7120_PDM2_CTRL1, 0x0000 },
	{ CM7120_PDM2_CTRL2, 0x0000 },
	{ CM7120_PDM2_CTRL3, 0x0000 },
	{ CM7120_PDM2_CTRL4, 0x0000 },
	{ CM7120_PDM2_CTRL5, 0x0000 },
	{ CM7120_STO_DAC_POST_VOL_CTRL, 0xe400 },
	{ CM7120_ST_CTRL, 0x000b },
	{ CM7120_MCLK_DET_PROTECT_CTRL, 0x0000 },
	{ CM7120_STO_HP_NG2_CTRL1, 0x1d22 },
	{ CM7120_STO_HP_NG2_CTRL2, 0x0003 },
	{ CM7120_STO_HP_NG2_CTRL3, 0x0003 },
	{ CM7120_STO_HP_NG2_CTRL4, 0x0020 },
	{ CM7120_STO_HP_NG2_CTRL5, 0x0080 },
	{ CM7120_STO_HP_NG2_CTRL6, 0x0800 },
	{ CM7120_STO_HP_NG2_ST1, 0x0000 },
	{ CM7120_STO_HP_NG2_ST2, 0x0000 },
	{ CM7120_STO_HP_NG2_ST3, 0x0000 },
	{ CM7120_NG2_ENV_DITHER_CTRL, 0x0000 },
	{ CM7120_MONO_AMP_NG2_CTRL1, 0x1d1f },
	{ CM7120_MONO_AMP_NG2_CTRL2, 0x0000 },
	{ CM7120_MONO_AMP_NG2_CTRL3, 0x0020 },
	{ CM7120_MONO_AMP_NG2_CTRL4, 0x0080 },
	{ CM7120_MONO_AMP_NG2_CTRL5, 0x0800 },
	{ CM7120_MONO_AMP_NG2_ST1, 0x0000 },
	{ CM7120_MONO_AMP_NG2_ST2, 0x0000 },
	{ CM7120_IF_INPUT_DET_ST1, 0x0000 },
	{ CM7120_IF_INPUT_DET_ST2, 0x0000 },
	{ CM7120_IF_INPUT_DET_ST3, 0x0000 },
	{ CM7120_STO_DAC_SIL_DET_CTRL, 0x4131 },
	{ CM7120_MONO_DACL_SIL_DET_CTRL, 0x4131 },
	{ CM7120_MONO_DACR_SIL_DET_CTRL, 0x4131 },
	{ CM7120_DD_MIXERL_SIL_DET_CTRL, 0x4131 },
	{ CM7120_DD_MIXERR_SIL_DET_CTRL, 0x4131 },
	{ CM7120_SIL_DET_CTRLOUTPUT1, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT2, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT3, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT4, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT5, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT6, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT7, 0x0000 },
	{ CM7120_SIL_DET_CTRLOUTPUT8, 0x0000 },
	{ CM7120_ADC_EQ_CTRL1, 0x6000 },
	{ CM7120_ADC_EQ_CTRL2, 0x0000 },
	{ CM7120_DAC_EQ_CTRL1, 0xc000 },
	{ CM7120_DAC_EQ_CTRL2, 0x0000 },
	{ CM7120_DAC_EQ_CTRL3, 0x0000 },
	{ CM7120_DAC_EQ_CTRL4, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL1, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL2, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL3, 0x0000 },
	{ CM7120_I2S_MASTER_CLK_CTRL4, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL5, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL6, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL7, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL8, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL9, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL10, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL11, 0x0001 },
	{ CM7120_I2S_MASTER_CLK_CTRL12, 0x0002 },
	{ CM7120_I2S_MASTER_CLK_CTRL13, 0x0001 },
	{ CM7120_HP_DECR_DECOUP_CTRL1, 0x4b38 },
	{ CM7120_HP_DECR_DECOUP_CTRL2, 0x0000 },
	{ CM7120_HP_DECR_DECOUP_CTRL3, 0x0000 },
	{ CM7120_HP_DECR_DECOUP_CTRL4, 0x0030 },
	{ CM7120_VAD_ADC_FILTER_CTRL1, 0x882f },
	{ CM7120_VAD_ADC_FILTER_CTRL2, 0x0000 },
	{ CM7120_VAD_CLK_SETTING1, 0x0700 },
	{ CM7120_VAD_CLK_SETTING2, 0x0242 },
	{ CM7120_VAD_ADC_PLL3_CTRL1, 0x0e22 },
	{ CM7120_VAD_ADC_PLL3_CTRL2, 0x0001 },
	{ CM7120_HP_BL_CTRL1, 0x0000 },
	{ CM7120_HP_BL_CTRL2, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL1, 0x433d },
	{ CM7120_HP_IMP_SENS_CTRL2, 0x02a0 },
	{ CM7120_HP_IMP_SENS_CTRL3, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL4, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL5, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL6, 0x0009 },
	{ CM7120_HP_IMP_SENS_CTRL7, 0x0018 },
	{ CM7120_HP_IMP_SENS_CTRL8, 0x002a },
	{ CM7120_HP_IMP_SENS_CTRL9, 0x004c },
	{ CM7120_HP_IMP_SENS_CTRL10, 0x0097 },
	{ CM7120_HP_IMP_SENS_CTRL11, 0x01c3 },
	{ CM7120_HP_IMP_SENS_CTRL12, 0x03e9 },
	{ CM7120_HP_IMP_SENS_CTRL13, 0x1389 },
	{ CM7120_HP_IMP_SENS_CTRL14, 0xc351 },
	{ CM7120_HP_IMP_SENS_CTRL15, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL16, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL17, 0x0000 },
	{ CM7120_HP_IMP_SENS_CTRL18, 0x0000 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL1, 0x40af },
	{ CM7120_HP_IMP_SENS_DIG_CTRL2, 0x0702 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL3, 0x0000 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL4, 0x0000 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL5, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL6, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL7, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL8, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL9, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL10, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL11, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL12, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL13, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL14, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL15, 0x003c },
	{ CM7120_HP_IMP_SENS_DIG_CTRL16, 0x5757 },
	{ CM7120_HP_IMP_SENS_DIG_CTRL17, 0x0000 },
	{ CM7120_ALC_PGA_CTRL1, 0x5334 },
	{ CM7120_ALC_PGA_CTRL2, 0x18e0 },
	{ CM7120_ALC_PGA_CTRL3, 0x8728 },
	{ CM7120_ALC_PGA_CTRL4, 0x7418 },
	{ CM7120_ALC_PGA_CTRL5, 0x901f },
	{ CM7120_ALC_PGA_CTRL6, 0x4500 },
	{ CM7120_ALC_PGA_CTRL7, 0x5100 },
	{ CM7120_ALC_PGA_ST1, 0x0000 },
	{ CM7120_ALC_PGA_ST2, 0x0000 },
	{ CM7120_ALC_PGA_ST3, 0x0000 },
	{ CM7120_ALC_PGA_SOURCE_CTRL1, 0x0501 },
	{ CM7120_HAPTIC_GEN_CTRL1, 0x0111 },
	{ CM7120_HAPTIC_GEN_CTRL2, 0x0064 },
	{ CM7120_HAPTIC_GEN_CTRL3, 0xef0e },
	{ CM7120_HAPTIC_GEN_CTRL4, 0xf0f0 },
	{ CM7120_HAPTIC_GEN_CTRL5, 0xef0e },
	{ CM7120_HAPTIC_GEN_CTRL6, 0xf0f0 },
	{ CM7120_HAPTIC_GEN_CTRL7, 0xef0e },
	{ CM7120_HAPTIC_GEN_CTRL8, 0xf0f0 },
	{ CM7120_HAPTIC_GEN_CTRL9, 0xf000 },
	{ CM7120_HAPTIC_GEN_CTRL10, 0x0000 },
	{ CM7120_AUTO_RC_CLK_CTRL1, 0x0000 },
	{ CM7120_AUTO_RC_CLK_CTRL2, 0x0000 },
	{ CM7120_AUTO_RC_CLK_CTRL3, 0x0000 },
	{ CM7120_DAC_L_EQ_LPF1_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_LPF1_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_LPF1_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_LPF1_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_LPF2_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_LPF2_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_LPF2_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_LPF2_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF1_A1, 0xc882 },
	{ CM7120_DAC_L_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF1_A1, 0xc882 },
	{ CM7120_DAC_R_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF2_A1, 0xc882 },
	{ CM7120_DAC_L_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF2_A1, 0xc882 },
	{ CM7120_DAC_R_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF3_A1, 0xe904 },
	{ CM7120_DAC_L_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF3_A1, 0xe904 },
	{ CM7120_DAC_R_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF4_A1, 0xe904 },
	{ CM7120_DAC_L_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF4_A1, 0xe904 },
	{ CM7120_DAC_R_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_BPF5_A1, 0xe904 },
	{ CM7120_DAC_L_EQ_BPF5_A2, 0x1c10 },
	{ CM7120_DAC_L_EQ_BPF5_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_BPF5_A1, 0xe904 },
	{ CM7120_DAC_R_EQ_BPF5_A2, 0x1c10 },
	{ CM7120_DAC_R_EQ_BPF5_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_DAC_L_EQ_HPF2_A1, 0x2000 },
	{ CM7120_DAC_L_EQ_HPF2_A2, 0x0000 },
	{ CM7120_DAC_L_EQ_HPF2_H0, 0x2000 },
	{ CM7120_DAC_R_EQ_HPF2_A1, 0x2000 },
	{ CM7120_DAC_R_EQ_HPF2_A2, 0x0000 },
	{ CM7120_DAC_R_EQ_HPF2_H0, 0x2000 },
	{ CM7120_DAC_L_EQ_HPF3_A1, 0x1c10 },
	{ CM7120_DAC_L_EQ_HPF3_H0, 0x01f4 },
	{ CM7120_DAC_R_EQ_HPF3_A1, 0x1c10 },
	{ CM7120_DAC_R_EQ_HPF3_H0, 0x01f4 },
	{ CM7120_DAC_L_BI_EQ_H0_1, 0x0200 },
	{ CM7120_DAC_L_BI_EQ_H0_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B1_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B1_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B2_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_B2_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A1_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A1_2, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A2_1, 0x0000 },
	{ CM7120_DAC_L_BI_EQ_A2_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_H0_1, 0x0200 },
	{ CM7120_DAC_R_BI_EQ_H0_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B1_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B1_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B2_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_B2_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A1_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A1_2, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A2_1, 0x0000 },
	{ CM7120_DAC_R_BI_EQ_A2_2, 0x0000 },
	{ CM7120_DAC_L_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_DAC_R_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_DAC_L_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_DAC_R_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_L_EQ_LPF_A1, 0x1c10 },
	{ CM7120_ADC_L_EQ_LPF_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_LPF_A1, 0x1c10 },
	{ CM7120_ADC_R_EQ_LPF_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF1_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF1_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF1_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF1_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF2_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF2_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF2_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF2_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF3_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF3_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF3_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF3_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_BPF4_A1, 0xe904 },
	{ CM7120_ADC_L_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_ADC_L_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_BPF4_A1, 0xe904 },
	{ CM7120_ADC_R_EQ_BPF4_A2, 0x1c10 },
	{ CM7120_ADC_R_EQ_BPF4_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_ADC_L_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_ADC_R_EQ_HPF1_A1, 0x1c10 },
	{ CM7120_ADC_R_EQ_HPF1_H0, 0x01f4 },
	{ CM7120_ADC_L_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_R_EQ_PRE_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_L_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_ADC_R_EQ_POST_VOL_CTRL, 0x0800 },
	{ CM7120_PITCH_HELLO_DET_CTRL1, 0x7681 },
	{ CM7120_PITCH_HELLO_DET_CTRL2, 0x0020 },
	{ CM7120_PITCH_HELLO_DET_CTRL3, 0x7851 },
	{ CM7120_PITCH_HELLO_DET_CTRL4, 0x01f3 },
	{ CM7120_PITCH_HELLO_DET_CTRL5, 0x00fa },
	{ CM7120_PITCH_HELLO_DET_CTRL6, 0x0129 },
	{ CM7120_PITCH_HELLO_DET_CTRL7, 0x0602 },
	{ CM7120_PITCH_HELLO_DET_CTRL8, 0x0114 },
	{ CM7120_PITCH_HELLO_DET_CTRL9, 0x0010 },
	{ CM7120_PITCH_HELLO_DET_CTRL10, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL11, 0x120d },
	{ CM7120_PITCH_HELLO_DET_CTRL12, 0x0040 },
	{ CM7120_PITCH_HELLO_DET_CTRL13, 0x0040 },
	{ CM7120_PITCH_HELLO_DET_CTRL14, 0x0505 },
	{ CM7120_PITCH_HELLO_DET_CTRL15, 0x1322 },
	{ CM7120_PITCH_HELLO_DET_CTRL16, 0x2110 },
	{ CM7120_PITCH_HELLO_DET_CTRL17, 0x3040 },
	{ CM7120_PITCH_HELLO_DET_CTRL18, 0x6414 },
	{ CM7120_PITCH_HELLO_DET_CTRL19, 0x2000 },
	{ CM7120_PITCH_HELLO_DET_CTRL20, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL21, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL22, 0x0000 },
	{ CM7120_PITCH_HELLO_DET_CTRL23, 0x0000 },
	{ CM7120_OK_DET_CTRL1, 0x4089 },
	{ CM7120_OK_DET_CTRL2, 0x0000 },
	{ CM7120_OK_DET_CTRL3, 0x0008 },
	{ CM7120_OK_DET_CTRL4, 0x0010 },
	{ CM7120_OK_DET_CTRL5, 0x0596 },
	{ CM7120_OK_DET_CTRL6, 0x0506 },
	{ CM7120_OK_DET_CTRL7, 0x0806 },
	{ CM7120_OK_DET_CTRL8, 0x1a00 },
	{ CM7120_OK_DET_CTRL9, 0x0705 },
	{ CM7120_OK_DET_CTRL10, 0x052d },
	{ CM7120_OK_DET_CTRL11, 0x180d },
	{ CM7120_OK_DET_CTRL12, 0x0009 },
	{ CM7120_OK_DET_CTRL13, 0x140a },
	{ CM7120_OK_DET_CTRL14, 0x0e4b },
	{ CM7120_OK_DET_CTRL15, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL1, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL2, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL3, 0x8060 },
	{ CM7120_DFLL_CAL_CTRL4, 0x0040 },
	{ CM7120_DFLL_CAL_CTRL5, 0x0001 },
	{ CM7120_DFLL_CAL_CTRL6, 0x0001 },
	{ CM7120_DFLL_CAL_CTRL7, 0x0400 },
	{ CM7120_DFLL_CAL_CTRL8, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL9, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL10, 0x4022 },
	{ CM7120_DFLL_CAL_CTRL11, 0x0002 },
	{ CM7120_DFLL_CAL_CTRL12, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL13, 0x0000 },
	{ CM7120_DFLL_CAL_CTRL14, 0x0000 },
	{ CM7120_VAD_FUNCTION_CTRL1, 0x802c },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL1, 0x7fff },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL2, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL3, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL4, 0x006a },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL5, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL6, 0x0000 },
	{ CM7120_DELAY_BUFFER_SRAM_CTRL7, 0x0000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL1, 0x6000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL2, 0x4040 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL3, 0x4000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL4, 0x0000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL5, 0xc350 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL6, 0x0064 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL7, 0x0040 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL8, 0x0000 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL9, 0x5280 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL10, 0x0001 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL11, 0x86a0 },
	{ CM7120_DMIC_CLK_ON_OFF_CTRL12, 0x0fd3 },
	{ CM7120_DAC_MULTI_DRC_MISC_CTRL, 0x3c10 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL1, 0x7dc2 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL2, 0xa178 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL3, 0x5383 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL4, 0x003e },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL5, 0x02c1 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL6, 0xd37d },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL7, 0x68d3 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL8, 0x82f6 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL9, 0xcd3b },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL10, 0x0035 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL11, 0xebf4 },
	{ CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL12, 0x2d6e },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL1, 0x5254 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL2, 0x0300 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL4, 0x133e },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL5, 0x32ff },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL6, 0x040c },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL7, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL8, 0x1800 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL10, 0x0045 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL11, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_HB_CTRL12, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL1, 0x5254 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL2, 0x0300 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL4, 0x133e },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL5, 0x32ff },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL6, 0x040c },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL7, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL8, 0x1800 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL10, 0x0045 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL11, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_MB_CTRL12, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL1, 0x5254 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL2, 0x0300 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL4, 0x133e },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL5, 0x32ff },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL6, 0x040c },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL7, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL8, 0x1800 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL10, 0x0045 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL11, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_BB_CTRL12, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL1, 0x4951 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL2, 0x1860 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL3, 0x5f5f },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL4, 0x0032 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL5, 0x0450 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL6, 0x00ff },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL7, 0x040c },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL8, 0x7418 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL9, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL10, 0x8596 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL11, 0x0075 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL12, 0x0080 },
	{ CM7120_DAC_MULTI_DRC_POS_CTRL13, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_ST1, 0x0000 },
	{ CM7120_DAC_MULTI_DRC_POS_ST2, 0x0000 },
	{ CM7120_ADC_ALC_CTRL1, 0x4905 },
	{ CM7120_ADC_ALC_CTRL2, 0xe150 },
	{ CM7120_ADC_ALC_CTRL3, 0x0100 },
	{ CM7120_ADC_ALC_CTRL4, 0x5f5f },
	{ CM7120_ADC_ALC_CTRL5, 0x0603 },
	{ CM7120_ADC_ALC_CTRL6, 0x0022 },
	{ CM7120_ADC_ALC_CTRL7, 0x45ff },
	{ CM7120_ADC_ALC_CTRL8, 0x040c },
	{ CM7120_ADC_ALC_CTRL9, 0x7418 },
	{ CM7120_ADC_ALC_CTRL10, 0x0000 },
	{ CM7120_ADC_ALC_CTRL11, 0x0000 },
	{ CM7120_ADC_ALC_CTRL12, 0x8700 },
	{ CM7120_ADC_ALC_CTRL13, 0x5080 },
	{ CM7120_ADC_ALC_CTRL14, 0x0000 },
	{ CM7120_ADC_ALC_ST1, 0x0000 },
	{ CM7120_ADC_ALC_ST2, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL1, 0x7f08 },
	{ CM7120_HP_DC_CAL_CTRL2, 0x0030 },
	{ CM7120_HP_DC_CAL_CTRL3, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL4, 0x0261 },
	{ CM7120_HP_DC_CAL_CTRL5, 0x1c3c },
	{ CM7120_HP_DC_CAL_CTRL6, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL7, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL8, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL9, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL10, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL11, 0x0000 },
	{ CM7120_HP_DC_CAL_CTRL12, 0x0000 },
	{ CM7120_HP_DC_CAL_ST1, 0x0000 },
	{ CM7120_HP_DC_CAL_ST2, 0x0000 },
	{ CM7120_HP_DC_CAL_ST3, 0x0000 },
	{ CM7120_HP_DC_CAL_ST4, 0x0000 },
	{ CM7120_HP_DC_CAL_ST5, 0x0000 },
	{ CM7120_HP_DC_CAL_ST6, 0x0000 },
	{ CM7120_HP_DC_CAL_ST7, 0x0000 },
	{ CM7120_HP_DC_CAL_ST8, 0x0000 },
	{ CM7120_HP_DC_CAL_ST9, 0x0000 },
	{ CM7120_HP_DC_CAL_ST10, 0x0000 },
	{ CM7120_HP_DC_CAL_ST11, 0x0000 },
	{ CM7120_HP_DC_CAL_ST12, 0x0000 },
	{ CM7120_HP_DC_CAL_ST13, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL1, 0x7914 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL2, 0x0261 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL3, 0x6000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL4, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL5, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL6, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_CTRL7, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_ST1, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_ST2, 0x0000 },
	{ CM7120_MONO_AMP_DC_CAL_ST3, 0x0000 },
	{ CM7120_DSP_IB_CTRL1, 0x0000 },
	{ CM7120_DSP_IB_CTRL2, 0x0000 },
	{ CM7120_DSP_IN_OB_CTRL, 0x0000 },
	{ CM7120_DSP_OB01_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_OB23_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_OB45_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_OB67_DIG_VOL, 0x2f2f },
	{ CM7120_MINI_DSP_OB01_DIG_VOL, 0x2f2f },
	{ CM7120_DSP_IB1_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_IB1_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_IB1_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_IB1_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_IB2_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_IB2_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_IB2_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_IB2_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_IB3_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_IB3_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_IB3_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_IB3_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_OB1_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_OB1_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_OB1_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_OB1_SRC_CTRL4, 0x0800 },
	{ CM7120_DSP_OB2_SRC_CTRL1, 0x1800 },
	{ CM7120_DSP_OB2_SRC_CTRL2, 0x0000 },
	{ CM7120_DSP_OB2_SRC_CTRL3, 0x0000 },
	{ CM7120_DSP_OB2_SRC_CTRL4, 0x0800 },
	{ CM7120_HIFI_MINI_DSP_CTRL_ST, 0x0041 },
	{ CM7120_SPI_SLAVE_CRC_CHECK_CTRL, 0x0000 },
	{ CM7120_EFUSE_CTRL1, 0x0000 },
	{ CM7120_EFUSE_CTRL2, 0x0000 },
	{ CM7120_EFUSE_CTRL3, 0x0000 },
	{ CM7120_EFUSE_CTRL4, 0x0000 },
	{ CM7120_EFUSE_CTRL5, 0x0000 },
	{ CM7120_EFUSE_CTRL6, 0x0000 },
	{ CM7120_EFUSE_CTRL7, 0x0000 },
	{ CM7120_EFUSE_CTRL8, 0x0000 },
	{ CM7120_EFUSE_CTRL9, 0x0000 },
	{ CM7120_EFUSE_CTRL10, 0x0000 },
	{ CM7120_EFUSE_CTRL11, 0x0000 },
	{ CM7120_I2C_AND_SPI_SCRAM_CTRL, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY1_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY1_LSB, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY2_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_WRITE_KEY2_LSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY1_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY1_LSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY2_MSB, 0x0000 },
	{ CM7120_I2C_SCRAM_READ_KEY2_LSB, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_1, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_2, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_3, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY1_4, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_1, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_2, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_3, 0x0000 },
	{ CM7120_SPI_SCRAM_WRITE_KEY2_4, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_1, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_2, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_3, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY1_4, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_1, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_2, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_3, 0x0000 },
	{ CM7120_SPI_SCRAM_READ_KEY2_4, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL1, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL2, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL3, 0x0000 },
	{ CM7120_GPIO1_TEST_OUTPUT_SEL4, 0x0000 },
	{ CM7120_PR_REG_MONO_AMP_BIAS_CTRL, 0x8a69 },
	{ CM7120_PR_REG_BIAS_CTRL1, 0xaa66 },
	{ CM7120_PR_REG_BIAS_CTRL2, 0x00aa },
	{ CM7120_PR_REG_BIAS_CTRL3, 0x0666 },
	{ CM7120_PR_REG_BIAS_CTRL4, 0xaaa6 },
	{ CM7120_PR_REG_BIAS_CTRL5, 0xaaaa },
	{ CM7120_PR_REG_BIAS_CTRL6, 0xaaaa },
	{ CM7120_PR_REG_BIAS_CTRL7, 0xa666 },
	{ CM7120_PR_REG_BIAS_CTRL8, 0x4000 },
	{ CM7120_PR_REG_BIAS_CTRL9, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL10, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL11, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL12, 0x4444 },
	{ CM7120_PR_REG_BIAS_CTRL13, 0xa860 },
	{ CM7120_PR_REG_ADC12_CLK_CTRL, 0xa490 },
	{ CM7120_PR_REG_ADC34_CLK_CTRL, 0xa490 },
	{ CM7120_PR_REG_ADC5_CLK_CTRL1, 0x0410 },
	{ CM7120_PR_REG_ADC5_CLK_CTRL2, 0x0000 },
	{ CM7120_PR_REG_ADC67_CLK_CTRL, 0xa490 },
	{ CM7120_PR_REG_PLL1_CTRL1, 0x3303 },
	{ CM7120_PR_REG_PLL1_CTRL2, 0x0054 },
	{ CM7120_PR_REG_PLL2_CTRL1, 0x3303 },
	{ CM7120_PR_REG_PLL2_CTRL2, 0x0054 },
	{ CM7120_PR_REG_VREF_CTRL1, 0x045f },
	{ CM7120_PR_REG_VREF_CTRL2, 0x081f },
	{ CM7120_PR_REG_BST1_CTRL, 0x0095 },
	{ CM7120_PR_REG_BST2_CTRL, 0x0095 },
	{ CM7120_PR_REG_BST3_CTRL, 0x0095 },
	{ CM7120_PR_REG_BST4_CTRL, 0x0095 },
	{ CM7120_DAC_ADC_DIG_VOL1, 0xaaa0 },
	{ CM7120_DAC_ADC_DIG_VOL2, 0xaaaa },
	{ CM7120_VAD_SRAM_TEST, 0x0000 },
	{ CM7120_PAD_DRIVING_CTRL1, 0x0000 },
	{ CM7120_PAD_DRIVING_CTRL2, 0x0000 },
	{ CM7120_PAD_DRIVING_CTRL3, 0x0003 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL1, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL2, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL3, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL4, 0x0000 },
	{ CM7120_DIG_INPUT_PIN_ST_CTRL5, 0x0000 },
	{ CM7120_TEST_MODE_CTRL1, 0x3002 },
	{ CM7120_TEST_MODE_CTRL2, 0x0000 },
	{ CM7120_GPIO1_GPIO3_TEST_MODE_CTRL, 0x0000 },
	{ CM7120_GPIO5_GPIO6_TEST_MODE_CTRL, 0x0000 },
	{ CM7120_GPIO6_GPIO7_TEST_MODE_CTRL, 0x0000 },
	{ CM7120_CODEC_DOMAIN_REG_RW_CTRL, 0x0000 },
	{ CM7120_DAC1_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC2_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC3_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC4_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC5_CLK_AND_CHOPPER_CTRL, 0x0010 },
	{ CM7120_DAC1_DAC2_DUMMY_REG, 0x0000 },
	{ CM7120_HP_CTRL1, 0x0000 },
	{ CM7120_HP_CTRL2, 0x30c2 },
	{ CM7120_HP_CTRL3, 0x0803 },
	{ CM7120_HP_CTRL4, 0xaaaa },
	{ CM7120_HP_CTRL5, 0x1100 },
	{ CM7120_HP_CTRL6, 0x0a54 },
	{ CM7120_LDO6_PR_CTRL1, 0x0000 },
	{ CM7120_LDO6_PR_CTRL2, 0x0002 },
	{ CM7120_LDO6_PR_CTRL3, 0x0002 },
	{ CM7120_LDO6_PR_CTRL4, 0x0000 },
	{ CM7120_LDO_AVDD1_PR_CTRL, 0x0114 },
	{ CM7120_LDO_HV2_PR_CTRL, 0x0010 },
	{ CM7120_LDO_HV3_PR_CTRL, 0x0210 },
	{ CM7120_LDO1_LDO3_LDO4_PR_CTRL, 0x0067 },
	{ CM7120_LDO8_LDO9_PR_CTRL, 0x0711 },
	{ CM7120_VREF5_L_PR_CTRL, 0x1024 },
	{ CM7120_VREF5_R_PR_CTRL, 0x1024 },
	{ CM7120_SLIMBUS_PARAMETER, 0x0000 },
	{ CM7120_SLIMBUS_RX, 0x0000 },
	{ CM7120_SLIMBUS_CTRL, 0x0000 },
	{ CM7120_LOUT_CTRL, 0x0055 },
	{ CM7120_DUMMY_REG_1, 0x0020 },
	{ CM7120_DUMMY_REG_2, 0x0000 },
	{ CM7120_DUMMY_REG_3, 0x0000 },
	{ CM7120_DUMMY_REG_4, 0x0000 },
};

/**
 * cm7120_dsp_mode_i2c_write_addr - Write value to address on DSP mode.
 * @cm7120: Private Data.
 * @addr: Address index.
 * @value: Address data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_write_addr(struct cm7120_priv *cm7120,
					  unsigned int addr, unsigned int value,
					  unsigned int opcode)
{
	struct snd_soc_component *component = cm7120->component;
	int ret;

	mutex_lock(&cm7120->dsp_lock);

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_MSB,
			   addr >> 16);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr msb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_LSB,
			   addr & 0xffff);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr lsb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_DATA_MSB,
			   value >> 16);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set data msb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_DATA_LSB,
			   value & 0xffff);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set data lsb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_OP_CODE, opcode);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set op code value: %d\n",
			ret);
		goto err;
	}

err:
	mutex_unlock(&cm7120->dsp_lock);

	return ret;
}

/**
 * cm7120_dsp_mode_i2c_read_addr - Read value from address on DSP mode.
 * cm7120: Private Data.
 * @addr: Address index.
 * @value: Address data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_read_addr(struct cm7120_priv *cm7120,
					 unsigned int addr, unsigned int *value)
{
	struct snd_soc_component *component = cm7120->component;
	int ret;
	unsigned int msb, lsb;

	mutex_lock(&cm7120->dsp_lock);

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_MSB,
			   addr >> 16);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr msb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_ADDR_LSB,
			   addr & 0xffff);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set addr lsb value: %d\n",
			ret);
		goto err;
	}

	ret = regmap_write(cm7120->real_regmap, CM7120_DSP_I2C_OP_CODE, 0x0002);
	if (ret < 0) {
		dev_err(component->dev, "Failed to set op code value: %d\n",
			ret);
		goto err;
	}

	regmap_read(cm7120->real_regmap, CM7120_DSP_I2C_DATA_MSB, &msb);
	regmap_read(cm7120->real_regmap, CM7120_DSP_I2C_DATA_LSB, &lsb);
	*value = (msb << 16) | lsb;

err:
	mutex_unlock(&cm7120->dsp_lock);

	return ret;
}

/**
 * cm7120_dsp_mode_i2c_write - Write register on DSP mode.
 * cm7120: Private Data.
 * @reg: Register index.
 * @value: Register data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_write(struct cm7120_priv *cm7120,
				     unsigned int reg, unsigned int value)
{
	return cm7120_dsp_mode_i2c_write_addr(cm7120, 0x1800c000 + reg * 2,
					      value << 16 | value, 0x1);
}

/**
 * cm7120_dsp_mode_i2c_read - Read register on DSP mode.
 * @component: SoC audio component device.
 * @reg: Register index.
 * @value: Register data.
 *
 *
 * Returns 0 for success or negative error code.
 */
static int cm7120_dsp_mode_i2c_read(struct cm7120_priv *cm7120,
				    unsigned int reg, unsigned int *value)
{
	int ret = cm7120_dsp_mode_i2c_read_addr(cm7120, 0x1800c000 + reg * 2,
						value);

	*value &= 0xffff;

	return ret;
}

static bool cm7120_volatile_register(struct device *dev, unsigned int reg)
{
	switch (reg) {
	case CM7120_RESET:
	case CM7120_SPDIF_IN_CTRL:
	case CM7120_FRAC_DIV_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL4:
	case CM7120_IRQ_ST1:
	case CM7120_IRQ_ST2:
	case CM7120_GPIO_ST1:
	case CM7120_GPIO_ST2:
	case CM7120_IL_CMD1:
	case CM7120_4BTN_IL_CMD1:
	case CM7120_PS_IL_CMD1:
	case CM7120_VENDOR_ID:
	case CM7120_VENDOR_ID1:
	case CM7120_VENDOR_ID2:
	case CM7120_PDM1_CTRL1:
	case CM7120_PDM1_CTRL2:
	case CM7120_PDM1_CTRL5:
	case CM7120_PDM2_CTRL1:
	case CM7120_PDM2_CTRL2:
	case CM7120_PDM2_CTRL5:
	case CM7120_MCLK_DET_PROTECT_CTRL:
	case CM7120_STO_HP_NG2_ST1 ... CM7120_STO_HP_NG2_ST3:
	case CM7120_MONO_AMP_NG2_ST1:
	case CM7120_MONO_AMP_NG2_ST2:
	case CM7120_IF_INPUT_DET_ST1 ... CM7120_IF_INPUT_DET_ST3:
	case CM7120_STO_DAC_SIL_DET_CTRL ... CM7120_DD_MIXERR_SIL_DET_CTRL:
	case CM7120_ADC_EQ_CTRL1:
	case CM7120_DAC_EQ_CTRL1:
	case CM7120_DAC_EQ_CTRL2:
	case CM7120_I2S_MASTER_CLK_CTRL5:
	case CM7120_I2S_MASTER_CLK_CTRL7:
	case CM7120_I2S_MASTER_CLK_CTRL9:
	case CM7120_I2S_MASTER_CLK_CTRL11:
	case CM7120_I2S_MASTER_CLK_CTRL13:
	case CM7120_VAD_CLK_SETTING1:
	case CM7120_VAD_ADC_PLL3_CTRL2:
	case CM7120_HP_IMP_SENS_CTRL1:
	case CM7120_HP_IMP_SENS_CTRL3 ... CM7120_HP_IMP_SENS_CTRL5:
	case CM7120_HP_IMP_SENS_DIG_CTRL2:
	case CM7120_HP_IMP_SENS_DIG_CTRL16:
	case CM7120_HP_IMP_SENS_DIG_CTRL17:
	case CM7120_ALC_PGA_ST1 ... CM7120_ALC_PGA_ST3:
	case CM7120_HAPTIC_GEN_CTRL1:
	case CM7120_HAPTIC_GEN_CTRL2:
	case CM7120_PITCH_HELLO_DET_CTRL1:
	case CM7120_PITCH_HELLO_DET_CTRL19:
	case CM7120_PITCH_HELLO_DET_CTRL20:
	case CM7120_PITCH_HELLO_DET_CTRL22:
	case CM7120_PITCH_HELLO_DET_CTRL23:
	case CM7120_OK_DET_CTRL1:
	case CM7120_OK_DET_CTRL2:
	case CM7120_OK_DET_CTRL15:
	case CM7120_DFLL_CAL_CTRL2:
	case CM7120_DFLL_CAL_CTRL10:
	case CM7120_DFLL_CAL_CTRL12 ... CM7120_DFLL_CAL_CTRL14:
	case CM7120_VAD_FUNCTION_CTRL1:
	case CM7120_DELAY_BUFFER_SRAM_CTRL2:
	case CM7120_DELAY_BUFFER_SRAM_CTRL3:
	case CM7120_DELAY_BUFFER_SRAM_CTRL5:
	case CM7120_DELAY_BUFFER_SRAM_CTRL6:
	case CM7120_DMIC_CLK_ON_OFF_CTRL12:
	case CM7120_DAC_MULTI_DRC_HB_CTRL9:
	case CM7120_DAC_MULTI_DRC_HB_CTRL11:
	case CM7120_DAC_MULTI_DRC_HB_CTRL12:
	case CM7120_DAC_MULTI_DRC_MB_CTRL9:
	case CM7120_DAC_MULTI_DRC_MB_CTRL11:
	case CM7120_DAC_MULTI_DRC_MB_CTRL12:
	case CM7120_DAC_MULTI_DRC_BB_CTRL9:
	case CM7120_DAC_MULTI_DRC_BB_CTRL11:
	case CM7120_DAC_MULTI_DRC_BB_CTRL12:
	case CM7120_DAC_MULTI_DRC_POS_ST1:
	case CM7120_DAC_MULTI_DRC_POS_ST2:
	case CM7120_ADC_ALC_ST1:
	case CM7120_ADC_ALC_ST2:
	case CM7120_HP_DC_CAL_CTRL1:
	case CM7120_HP_DC_CAL_CTRL10:
	case CM7120_HP_DC_CAL_ST1 ... CM7120_HP_DC_CAL_ST13:
	case CM7120_MONO_AMP_DC_CAL_CTRL1:
	case CM7120_MONO_AMP_DC_CAL_CTRL5:
	case CM7120_MONO_AMP_DC_CAL_ST1 ... CM7120_MONO_AMP_DC_CAL_ST3:
	case CM7120_HIFI_MINI_DSP_CTRL_ST:
	case CM7120_SPI_SLAVE_CRC_CHECK_CTRL:
	case CM7120_EFUSE_CTRL1:
	case CM7120_EFUSE_CTRL6 ... CM7120_EFUSE_CTRL9:
	case CM7120_EFUSE_CTRL11:
	case CM7120_SLIMBUS_PARAMETER:
	case CM7120_DUMMY_REG_1:
		return true;

	default:
		return false;
	}
}

static bool cm7120_readable_register(struct device *dev, unsigned int reg)
{
	switch (reg) {
	case CM7120_RESET:
	case CM7120_LOUT:
	case CM7120_HP_OUT:
	case CM7120_MONO_OUT:
	case CM7120_BST12_CTRL:
	case CM7120_BST34_CTRL:
	case CM7120_VAD_INBUF_CTRL:
	case CM7120_CAL_ADC_MIXER_CTRL:
	case CM7120_MICBIAS1_CTRL1:
	case CM7120_MICBIAS1_CTRL2:
	case CM7120_DAC1_POST_DIG_VOL:
	case CM7120_DAC1_DIG_VOL:
	case CM7120_DAC2_DIG_VOL:
	case CM7120_DAC3_DIG_VOL:
	case CM7120_STO1_ADC_DIG_VOL:
	case CM7120_MONO_ADC_DIG_VOL:
	case CM7120_STO2_ADC_DIG_VOL:
	case CM7120_STO3_ADC_DIG_VOL:
	case CM7120_ADC_BST_GAIN_CTRL1:
	case CM7120_ADC_BST_GAIN_CTRL2:
	case CM7120_ADC_BST_GAIN_CTRL3:
	case CM7120_SPDIF_IN_CTRL:
	case CM7120_IF3_DATA_CTRL:
	case CM7120_IF4_DATA_CTRL:
	case CM7120_IF5_DATA_CTRL:
	case CM7120_TDM1_CTRL1:
	case CM7120_TDM1_CTRL2:
	case CM7120_TDM1_CTRL3:
	case CM7120_TDM1_CTRL4:
	case CM7120_TDM1_CTRL5:
	case CM7120_TDM1_CTRL6:
	case CM7120_TDM1_CTRL7:
	case CM7120_TDM2_CTRL1:
	case CM7120_TDM2_CTRL2:
	case CM7120_TDM2_CTRL3:
	case CM7120_TDM2_CTRL4:
	case CM7120_TDM2_CTRL5:
	case CM7120_TDM2_CTRL6:
	case CM7120_TDM2_CTRL7:
	case CM7120_STO1_DAC_MIXER_CTRL1:
	case CM7120_STO1_DAC_MIXER_CTRL2:
	case CM7120_MONO_DAC_MIXER_CTRL1:
	case CM7120_MONO_DAC_MIXER_CTRL2:
	case CM7120_DD_MIXER_CTRL1:
	case CM7120_DD_MIXER_CTRL2:
	case CM7120_DAC1_MIXER_CTRL:
	case CM7120_DAC2_MIXER_CTRL:
	case CM7120_DAC3_MIXER_CTRL:
	case CM7120_DAC_SOURCE_CTRL:
	case CM7120_STO1_ADC_MIXER_CTRL:
	case CM7120_MONO_ADC_MIXER_CTRL1:
	case CM7120_MONO_ADC_MIXER_CTRL2:
	case CM7120_STO2_ADC_MIXER_CTRL:
	case CM7120_STO3_ADC_MIXER_CTRL:
	case CM7120_DMIC_CTRL1:
	case CM7120_DMIC_CTRL2:
	case CM7120_HPF_CTRL1:
	case CM7120_SV_ZCD_CTRL1:
	case CM7120_PWR_ADC:
	case CM7120_PWR_DIG1:
	case CM7120_PWR_DIG2:
	case CM7120_PWR_ANA1:
	case CM7120_PWR_ANA2:
	case CM7120_PWR_DSP:
	case CM7120_PWR_LDO1:
	case CM7120_PWR_LDO2:
	case CM7120_PWR_LDO3:
	case CM7120_PWR_LDO4:
	case CM7120_PWR_LDO5:
	case CM7120_I2S1_SDP:
	case CM7120_I2S2_SDP:
	case CM7120_I2S3_SDP:
	case CM7120_I2S4_SDP:
	case CM7120_I2S5_SDP:
	case CM7120_I2S_LRCK_BCLK_SOURCE:
	case CM7120_CLK_TREE_CTRL1:
	case CM7120_CLK_TREE_CTRL2:
	case CM7120_CLK_TREE_CTRL3:
	case CM7120_CLK_TREE_CTRL4:
	case CM7120_PLL1_CTRL1:
	case CM7120_PLL1_CTRL2:
	case CM7120_PLL2_CTRL1:
	case CM7120_PLL2_CTRL2:
	case CM7120_DSP_CLK_SOURCE1:
	case CM7120_DSP_CLK_SOURCE2:
	case CM7120_GLB_CLK1:
	case CM7120_GLB_CLK2:
	case CM7120_ASRC1:
	case CM7120_ASRC2:
	case CM7120_ASRC3:
	case CM7120_ASRC4:
	case CM7120_ASRC5:
	case CM7120_ASRC6:
	case CM7120_ASRC7:
	case CM7120_ASRC8:
	case CM7120_ASRC9:
	case CM7120_ASRC10:
	case CM7120_ASRC11:
	case CM7120_ASRC12:
	case CM7120_ASRC13:
	case CM7120_ASRC14:
	case CM7120_ASRC15:
	case CM7120_ASRC16:
	case CM7120_ASRC17:
	case CM7120_ASRC18:
	case CM7120_ASRC19:
	case CM7120_ASRC20:
	case CM7120_ASRC21:
	case CM7120_ASRC22:
	case CM7120_ASRC23:
	case CM7120_ASRC24:
	case CM7120_ASRC25:
	case CM7120_FRAC_DIV_CTRL1:
	case CM7120_FRAC_DIV_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL1:
	case CM7120_JACK_MIC_DET_CTRL2:
	case CM7120_JACK_MIC_DET_CTRL3:
	case CM7120_JACK_MIC_DET_CTRL4:
	case CM7120_JACK_DET_CTRL1:
	case CM7120_JACK_DET_CTRL2:
	case CM7120_JACK_DET_CTRL3:
	case CM7120_JACK_DET_CTRL4:
	case CM7120_JACK_DET_CTRL5:
	case CM7120_IRQ_ST1:
	case CM7120_IRQ_ST2:
	case CM7120_IRQ_CTRL1:
	case CM7120_IRQ_CTRL2:
	case CM7120_IRQ_CTRL3:
	case CM7120_IRQ_CTRL4:
	case CM7120_IRQ_CTRL5:
	case CM7120_IRQ_CTRL6:
	case CM7120_IRQ_CTRL7:
	case CM7120_IRQ_CTRL8:
	case CM7120_IRQ_CTRL9:
	case CM7120_MF_PIN_CTRL1:
	case CM7120_MF_PIN_CTRL2:
	case CM7120_MF_PIN_CTRL3:
	case CM7120_GPIO_CTRL1:
	case CM7120_GPIO_CTRL2:
	case CM7120_GPIO_CTRL3:
	case CM7120_GPIO_CTRL4:
	case CM7120_GPIO_CTRL5:
	case CM7120_GPIO_CTRL6:
	case CM7120_GPIO_ST1:
	case CM7120_GPIO_ST2:
	case CM7120_LP_DET_CTRL:
	case CM7120_STO1_ADC_HPF_CTRL1:
	case CM7120_STO1_ADC_HPF_CTRL2:
	case CM7120_MONO_ADC_HPF_CTRL1:
	case CM7120_MONO_ADC_HPF_CTRL2:
	case CM7120_STO2_ADC_HPF_CTRL1:
	case CM7120_STO2_ADC_HPF_CTRL2:
	case CM7120_STO3_ADC_HPF_CTRL1:
	case CM7120_STO3_ADC_HPF_CTRL2:
	case CM7120_ZCD_CTRL:
	case CM7120_IL_CMD1:
	case CM7120_IL_CMD2:
	case CM7120_IL_CMD3:
	case CM7120_IL_CMD4:
	case CM7120_4BTN_IL_CMD1:
	case CM7120_4BTN_IL_CMD2:
	case CM7120_4BTN_IL_CMD3:
	case CM7120_PS_IL_CMD1:
	case CM7120_DSP_OUTB_0123_MIXER_CTRL:
	case CM7120_DSP_OUTB_45_MIXER_CTRL:
	case CM7120_DSP_OUTB_67_MIXER_CTRL:
	case CM7120_MCLK_GATING_CTRL:
	case CM7120_VENDOR_ID:
	case CM7120_VENDOR_ID1:
	case CM7120_VENDOR_ID2:
	case CM7120_PDM_OUTPUT_CTRL:
	case CM7120_PDM1_CTRL1:
	case CM7120_PDM1_CTRL2:
	case CM7120_PDM1_CTRL3:
	case CM7120_PDM1_CTRL4:
	case CM7120_PDM1_CTRL5:
	case CM7120_PDM2_CTRL1:
	case CM7120_PDM2_CTRL2:
	case CM7120_PDM2_CTRL3:
	case CM7120_PDM2_CTRL4:
	case CM7120_PDM2_CTRL5:
	case CM7120_STO_DAC_POST_VOL_CTRL:
	case CM7120_ST_CTRL:
	case CM7120_MCLK_DET_PROTECT_CTRL:
	case CM7120_STO_HP_NG2_CTRL1:
	case CM7120_STO_HP_NG2_CTRL2:
	case CM7120_STO_HP_NG2_CTRL3:
	case CM7120_STO_HP_NG2_CTRL4:
	case CM7120_STO_HP_NG2_CTRL5:
	case CM7120_STO_HP_NG2_CTRL6:
	case CM7120_STO_HP_NG2_ST1:
	case CM7120_STO_HP_NG2_ST2:
	case CM7120_STO_HP_NG2_ST3:
	case CM7120_NG2_ENV_DITHER_CTRL:
	case CM7120_MONO_AMP_NG2_CTRL1:
	case CM7120_MONO_AMP_NG2_CTRL2:
	case CM7120_MONO_AMP_NG2_CTRL3:
	case CM7120_MONO_AMP_NG2_CTRL4:
	case CM7120_MONO_AMP_NG2_CTRL5:
	case CM7120_MONO_AMP_NG2_ST1:
	case CM7120_MONO_AMP_NG2_ST2:
	case CM7120_IF_INPUT_DET_ST1:
	case CM7120_IF_INPUT_DET_ST2:
	case CM7120_IF_INPUT_DET_ST3:
	case CM7120_STO_DAC_SIL_DET_CTRL:
	case CM7120_MONO_DACL_SIL_DET_CTRL:
	case CM7120_MONO_DACR_SIL_DET_CTRL:
	case CM7120_DD_MIXERL_SIL_DET_CTRL:
	case CM7120_DD_MIXERR_SIL_DET_CTRL:
	case CM7120_SIL_DET_CTRLOUTPUT1:
	case CM7120_SIL_DET_CTRLOUTPUT2:
	case CM7120_SIL_DET_CTRLOUTPUT3:
	case CM7120_SIL_DET_CTRLOUTPUT4:
	case CM7120_SIL_DET_CTRLOUTPUT5:
	case CM7120_SIL_DET_CTRLOUTPUT6:
	case CM7120_SIL_DET_CTRLOUTPUT7:
	case CM7120_SIL_DET_CTRLOUTPUT8:
	case CM7120_ADC_EQ_CTRL1:
	case CM7120_ADC_EQ_CTRL2:
	case CM7120_DAC_EQ_CTRL1:
	case CM7120_DAC_EQ_CTRL2:
	case CM7120_DAC_EQ_CTRL3:
	case CM7120_DAC_EQ_CTRL4:
	case CM7120_I2S_MASTER_CLK_CTRL1:
	case CM7120_I2S_MASTER_CLK_CTRL2:
	case CM7120_I2S_MASTER_CLK_CTRL3:
	case CM7120_I2S_MASTER_CLK_CTRL4:
	case CM7120_I2S_MASTER_CLK_CTRL5:
	case CM7120_I2S_MASTER_CLK_CTRL6:
	case CM7120_I2S_MASTER_CLK_CTRL7:
	case CM7120_I2S_MASTER_CLK_CTRL8:
	case CM7120_I2S_MASTER_CLK_CTRL9:
	case CM7120_I2S_MASTER_CLK_CTRL10:
	case CM7120_I2S_MASTER_CLK_CTRL11:
	case CM7120_I2S_MASTER_CLK_CTRL12:
	case CM7120_I2S_MASTER_CLK_CTRL13:
	case CM7120_HP_DECR_DECOUP_CTRL1:
	case CM7120_HP_DECR_DECOUP_CTRL2:
	case CM7120_HP_DECR_DECOUP_CTRL3:
	case CM7120_HP_DECR_DECOUP_CTRL4:
	case CM7120_VAD_ADC_FILTER_CTRL1:
	case CM7120_VAD_ADC_FILTER_CTRL2:
	case CM7120_VAD_CLK_SETTING1:
	case CM7120_VAD_CLK_SETTING2:
	case CM7120_VAD_ADC_PLL3_CTRL1:
	case CM7120_VAD_ADC_PLL3_CTRL2:
	case CM7120_HP_BL_CTRL1:
	case CM7120_HP_BL_CTRL2:
	case CM7120_HP_IMP_SENS_CTRL1:
	case CM7120_HP_IMP_SENS_CTRL2:
	case CM7120_HP_IMP_SENS_CTRL3:
	case CM7120_HP_IMP_SENS_CTRL4:
	case CM7120_HP_IMP_SENS_CTRL5:
	case CM7120_HP_IMP_SENS_CTRL6:
	case CM7120_HP_IMP_SENS_CTRL7:
	case CM7120_HP_IMP_SENS_CTRL8:
	case CM7120_HP_IMP_SENS_CTRL9:
	case CM7120_HP_IMP_SENS_CTRL10:
	case CM7120_HP_IMP_SENS_CTRL11:
	case CM7120_HP_IMP_SENS_CTRL12:
	case CM7120_HP_IMP_SENS_CTRL13:
	case CM7120_HP_IMP_SENS_CTRL14:
	case CM7120_HP_IMP_SENS_CTRL15:
	case CM7120_HP_IMP_SENS_CTRL16:
	case CM7120_HP_IMP_SENS_CTRL17:
	case CM7120_HP_IMP_SENS_CTRL18:
	case CM7120_HP_IMP_SENS_DIG_CTRL1:
	case CM7120_HP_IMP_SENS_DIG_CTRL2:
	case CM7120_HP_IMP_SENS_DIG_CTRL3:
	case CM7120_HP_IMP_SENS_DIG_CTRL4:
	case CM7120_HP_IMP_SENS_DIG_CTRL5:
	case CM7120_HP_IMP_SENS_DIG_CTRL6:
	case CM7120_HP_IMP_SENS_DIG_CTRL7:
	case CM7120_HP_IMP_SENS_DIG_CTRL8:
	case CM7120_HP_IMP_SENS_DIG_CTRL9:
	case CM7120_HP_IMP_SENS_DIG_CTRL10:
	case CM7120_HP_IMP_SENS_DIG_CTRL11:
	case CM7120_HP_IMP_SENS_DIG_CTRL12:
	case CM7120_HP_IMP_SENS_DIG_CTRL13:
	case CM7120_HP_IMP_SENS_DIG_CTRL14:
	case CM7120_HP_IMP_SENS_DIG_CTRL15:
	case CM7120_HP_IMP_SENS_DIG_CTRL16:
	case CM7120_HP_IMP_SENS_DIG_CTRL17:
	case CM7120_ALC_PGA_CTRL1:
	case CM7120_ALC_PGA_CTRL2:
	case CM7120_ALC_PGA_CTRL3:
	case CM7120_ALC_PGA_CTRL4:
	case CM7120_ALC_PGA_CTRL5:
	case CM7120_ALC_PGA_CTRL6:
	case CM7120_ALC_PGA_CTRL7:
	case CM7120_ALC_PGA_ST1:
	case CM7120_ALC_PGA_ST2:
	case CM7120_ALC_PGA_ST3:
	case CM7120_ALC_PGA_SOURCE_CTRL1:
	case CM7120_HAPTIC_GEN_CTRL1:
	case CM7120_HAPTIC_GEN_CTRL2:
	case CM7120_HAPTIC_GEN_CTRL3:
	case CM7120_HAPTIC_GEN_CTRL4:
	case CM7120_HAPTIC_GEN_CTRL5:
	case CM7120_HAPTIC_GEN_CTRL6:
	case CM7120_HAPTIC_GEN_CTRL7:
	case CM7120_HAPTIC_GEN_CTRL8:
	case CM7120_HAPTIC_GEN_CTRL9:
	case CM7120_HAPTIC_GEN_CTRL10:
	case CM7120_AUTO_RC_CLK_CTRL1:
	case CM7120_AUTO_RC_CLK_CTRL2:
	case CM7120_AUTO_RC_CLK_CTRL3:
	case CM7120_DAC_L_EQ_LPF1_A1:
	case CM7120_DAC_L_EQ_LPF1_H0:
	case CM7120_DAC_R_EQ_LPF1_A1:
	case CM7120_DAC_R_EQ_LPF1_H0:
	case CM7120_DAC_L_EQ_LPF2_A1:
	case CM7120_DAC_L_EQ_LPF2_H0:
	case CM7120_DAC_R_EQ_LPF2_A1:
	case CM7120_DAC_R_EQ_LPF2_H0:
	case CM7120_DAC_L_EQ_BPF1_A1:
	case CM7120_DAC_L_EQ_BPF1_A2:
	case CM7120_DAC_L_EQ_BPF1_H0:
	case CM7120_DAC_R_EQ_BPF1_A1:
	case CM7120_DAC_R_EQ_BPF1_A2:
	case CM7120_DAC_R_EQ_BPF1_H0:
	case CM7120_DAC_L_EQ_BPF2_A1:
	case CM7120_DAC_L_EQ_BPF2_A2:
	case CM7120_DAC_L_EQ_BPF2_H0:
	case CM7120_DAC_R_EQ_BPF2_A1:
	case CM7120_DAC_R_EQ_BPF2_A2:
	case CM7120_DAC_R_EQ_BPF2_H0:
	case CM7120_DAC_L_EQ_BPF3_A1:
	case CM7120_DAC_L_EQ_BPF3_A2:
	case CM7120_DAC_L_EQ_BPF3_H0:
	case CM7120_DAC_R_EQ_BPF3_A1:
	case CM7120_DAC_R_EQ_BPF3_A2:
	case CM7120_DAC_R_EQ_BPF3_H0:
	case CM7120_DAC_L_EQ_BPF4_A1:
	case CM7120_DAC_L_EQ_BPF4_A2:
	case CM7120_DAC_L_EQ_BPF4_H0:
	case CM7120_DAC_R_EQ_BPF4_A1:
	case CM7120_DAC_R_EQ_BPF4_A2:
	case CM7120_DAC_R_EQ_BPF4_H0:
	case CM7120_DAC_L_EQ_BPF5_A1:
	case CM7120_DAC_L_EQ_BPF5_A2:
	case CM7120_DAC_L_EQ_BPF5_H0:
	case CM7120_DAC_R_EQ_BPF5_A1:
	case CM7120_DAC_R_EQ_BPF5_A2:
	case CM7120_DAC_R_EQ_BPF5_H0:
	case CM7120_DAC_L_EQ_HPF1_A1:
	case CM7120_DAC_L_EQ_HPF1_H0:
	case CM7120_DAC_R_EQ_HPF1_A1:
	case CM7120_DAC_R_EQ_HPF1_H0:
	case CM7120_DAC_L_EQ_HPF2_A1:
	case CM7120_DAC_L_EQ_HPF2_A2:
	case CM7120_DAC_L_EQ_HPF2_H0:
	case CM7120_DAC_R_EQ_HPF2_A1:
	case CM7120_DAC_R_EQ_HPF2_A2:
	case CM7120_DAC_R_EQ_HPF2_H0:
	case CM7120_DAC_L_EQ_HPF3_A1:
	case CM7120_DAC_L_EQ_HPF3_H0:
	case CM7120_DAC_R_EQ_HPF3_A1:
	case CM7120_DAC_R_EQ_HPF3_H0:
	case CM7120_DAC_L_BI_EQ_H0_1:
	case CM7120_DAC_L_BI_EQ_H0_2:
	case CM7120_DAC_L_BI_EQ_B1_1:
	case CM7120_DAC_L_BI_EQ_B1_2:
	case CM7120_DAC_L_BI_EQ_B2_1:
	case CM7120_DAC_L_BI_EQ_B2_2:
	case CM7120_DAC_L_BI_EQ_A1_1:
	case CM7120_DAC_L_BI_EQ_A1_2:
	case CM7120_DAC_L_BI_EQ_A2_1:
	case CM7120_DAC_L_BI_EQ_A2_2:
	case CM7120_DAC_R_BI_EQ_H0_1:
	case CM7120_DAC_R_BI_EQ_H0_2:
	case CM7120_DAC_R_BI_EQ_B1_1:
	case CM7120_DAC_R_BI_EQ_B1_2:
	case CM7120_DAC_R_BI_EQ_B2_1:
	case CM7120_DAC_R_BI_EQ_B2_2:
	case CM7120_DAC_R_BI_EQ_A1_1:
	case CM7120_DAC_R_BI_EQ_A1_2:
	case CM7120_DAC_R_BI_EQ_A2_1:
	case CM7120_DAC_R_BI_EQ_A2_2:
	case CM7120_DAC_L_EQ_PRE_VOL_CTRL:
	case CM7120_DAC_R_EQ_PRE_VOL_CTRL:
	case CM7120_DAC_L_EQ_POST_VOL_CTRL:
	case CM7120_DAC_R_EQ_POST_VOL_CTRL:
	case CM7120_ADC_L_EQ_LPF_A1:
	case CM7120_ADC_L_EQ_LPF_H0:
	case CM7120_ADC_R_EQ_LPF_A1:
	case CM7120_ADC_R_EQ_LPF_H0:
	case CM7120_ADC_L_EQ_BPF1_A1:
	case CM7120_ADC_L_EQ_BPF1_A2:
	case CM7120_ADC_L_EQ_BPF1_H0:
	case CM7120_ADC_R_EQ_BPF1_A1:
	case CM7120_ADC_R_EQ_BPF1_A2:
	case CM7120_ADC_R_EQ_BPF1_H0:
	case CM7120_ADC_L_EQ_BPF2_A1:
	case CM7120_ADC_L_EQ_BPF2_A2:
	case CM7120_ADC_L_EQ_BPF2_H0:
	case CM7120_ADC_R_EQ_BPF2_A1:
	case CM7120_ADC_R_EQ_BPF2_A2:
	case CM7120_ADC_R_EQ_BPF2_H0:
	case CM7120_ADC_L_EQ_BPF3_A1:
	case CM7120_ADC_L_EQ_BPF3_A2:
	case CM7120_ADC_L_EQ_BPF3_H0:
	case CM7120_ADC_R_EQ_BPF3_A1:
	case CM7120_ADC_R_EQ_BPF3_A2:
	case CM7120_ADC_R_EQ_BPF3_H0:
	case CM7120_ADC_L_EQ_BPF4_A1:
	case CM7120_ADC_L_EQ_BPF4_A2:
	case CM7120_ADC_L_EQ_BPF4_H0:
	case CM7120_ADC_R_EQ_BPF4_A1:
	case CM7120_ADC_R_EQ_BPF4_A2:
	case CM7120_ADC_R_EQ_BPF4_H0:
	case CM7120_ADC_L_EQ_HPF1_A1:
	case CM7120_ADC_L_EQ_HPF1_H0:
	case CM7120_ADC_R_EQ_HPF1_A1:
	case CM7120_ADC_R_EQ_HPF1_H0:
	case CM7120_ADC_L_EQ_PRE_VOL_CTRL:
	case CM7120_ADC_R_EQ_PRE_VOL_CTRL:
	case CM7120_ADC_L_EQ_POST_VOL_CTRL:
	case CM7120_ADC_R_EQ_POST_VOL_CTRL:
	case CM7120_PITCH_HELLO_DET_CTRL1:
	case CM7120_PITCH_HELLO_DET_CTRL2:
	case CM7120_PITCH_HELLO_DET_CTRL3:
	case CM7120_PITCH_HELLO_DET_CTRL4:
	case CM7120_PITCH_HELLO_DET_CTRL5:
	case CM7120_PITCH_HELLO_DET_CTRL6:
	case CM7120_PITCH_HELLO_DET_CTRL7:
	case CM7120_PITCH_HELLO_DET_CTRL8:
	case CM7120_PITCH_HELLO_DET_CTRL9:
	case CM7120_PITCH_HELLO_DET_CTRL10:
	case CM7120_PITCH_HELLO_DET_CTRL11:
	case CM7120_PITCH_HELLO_DET_CTRL12:
	case CM7120_PITCH_HELLO_DET_CTRL13:
	case CM7120_PITCH_HELLO_DET_CTRL14:
	case CM7120_PITCH_HELLO_DET_CTRL15:
	case CM7120_PITCH_HELLO_DET_CTRL16:
	case CM7120_PITCH_HELLO_DET_CTRL17:
	case CM7120_PITCH_HELLO_DET_CTRL18:
	case CM7120_PITCH_HELLO_DET_CTRL19:
	case CM7120_PITCH_HELLO_DET_CTRL20:
	case CM7120_PITCH_HELLO_DET_CTRL21:
	case CM7120_PITCH_HELLO_DET_CTRL22:
	case CM7120_PITCH_HELLO_DET_CTRL23:
	case CM7120_OK_DET_CTRL1:
	case CM7120_OK_DET_CTRL2:
	case CM7120_OK_DET_CTRL3:
	case CM7120_OK_DET_CTRL4:
	case CM7120_OK_DET_CTRL5:
	case CM7120_OK_DET_CTRL6:
	case CM7120_OK_DET_CTRL7:
	case CM7120_OK_DET_CTRL8:
	case CM7120_OK_DET_CTRL9:
	case CM7120_OK_DET_CTRL10:
	case CM7120_OK_DET_CTRL11:
	case CM7120_OK_DET_CTRL12:
	case CM7120_OK_DET_CTRL13:
	case CM7120_OK_DET_CTRL14:
	case CM7120_OK_DET_CTRL15:
	case CM7120_DFLL_CAL_CTRL1:
	case CM7120_DFLL_CAL_CTRL2:
	case CM7120_DFLL_CAL_CTRL3:
	case CM7120_DFLL_CAL_CTRL4:
	case CM7120_DFLL_CAL_CTRL5:
	case CM7120_DFLL_CAL_CTRL6:
	case CM7120_DFLL_CAL_CTRL7:
	case CM7120_DFLL_CAL_CTRL8:
	case CM7120_DFLL_CAL_CTRL9:
	case CM7120_DFLL_CAL_CTRL10:
	case CM7120_DFLL_CAL_CTRL11:
	case CM7120_DFLL_CAL_CTRL12:
	case CM7120_DFLL_CAL_CTRL13:
	case CM7120_DFLL_CAL_CTRL14:
	case CM7120_VAD_FUNCTION_CTRL1:
	case CM7120_DELAY_BUFFER_SRAM_CTRL1:
	case CM7120_DELAY_BUFFER_SRAM_CTRL2:
	case CM7120_DELAY_BUFFER_SRAM_CTRL3:
	case CM7120_DELAY_BUFFER_SRAM_CTRL4:
	case CM7120_DELAY_BUFFER_SRAM_CTRL5:
	case CM7120_DELAY_BUFFER_SRAM_CTRL6:
	case CM7120_DELAY_BUFFER_SRAM_CTRL7:
	case CM7120_DMIC_CLK_ON_OFF_CTRL1:
	case CM7120_DMIC_CLK_ON_OFF_CTRL2:
	case CM7120_DMIC_CLK_ON_OFF_CTRL3:
	case CM7120_DMIC_CLK_ON_OFF_CTRL4:
	case CM7120_DMIC_CLK_ON_OFF_CTRL5:
	case CM7120_DMIC_CLK_ON_OFF_CTRL6:
	case CM7120_DMIC_CLK_ON_OFF_CTRL7:
	case CM7120_DMIC_CLK_ON_OFF_CTRL8:
	case CM7120_DMIC_CLK_ON_OFF_CTRL9:
	case CM7120_DMIC_CLK_ON_OFF_CTRL10:
	case CM7120_DMIC_CLK_ON_OFF_CTRL11:
	case CM7120_DMIC_CLK_ON_OFF_CTRL12:
	case CM7120_DAC_MULTI_DRC_MISC_CTRL:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL1:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL2:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL3:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL4:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL5:
	case CM7120_DAC_MULTI_DRC_COEF_FB1_CTRL6:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL7:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL8:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL9:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL10:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL11:
	case CM7120_DAC_MULTI_DRC_COEF_FB2_CTRL12:
	case CM7120_DAC_MULTI_DRC_HB_CTRL1:
	case CM7120_DAC_MULTI_DRC_HB_CTRL2:
	case CM7120_DAC_MULTI_DRC_HB_CTRL3:
	case CM7120_DAC_MULTI_DRC_HB_CTRL4:
	case CM7120_DAC_MULTI_DRC_HB_CTRL5:
	case CM7120_DAC_MULTI_DRC_HB_CTRL6:
	case CM7120_DAC_MULTI_DRC_HB_CTRL7:
	case CM7120_DAC_MULTI_DRC_HB_CTRL8:
	case CM7120_DAC_MULTI_DRC_HB_CTRL9:
	case CM7120_DAC_MULTI_DRC_HB_CTRL10:
	case CM7120_DAC_MULTI_DRC_HB_CTRL11:
	case CM7120_DAC_MULTI_DRC_HB_CTRL12:
	case CM7120_DAC_MULTI_DRC_MB_CTRL1:
	case CM7120_DAC_MULTI_DRC_MB_CTRL2:
	case CM7120_DAC_MULTI_DRC_MB_CTRL3:
	case CM7120_DAC_MULTI_DRC_MB_CTRL4:
	case CM7120_DAC_MULTI_DRC_MB_CTRL5:
	case CM7120_DAC_MULTI_DRC_MB_CTRL6:
	case CM7120_DAC_MULTI_DRC_MB_CTRL7:
	case CM7120_DAC_MULTI_DRC_MB_CTRL8:
	case CM7120_DAC_MULTI_DRC_MB_CTRL9:
	case CM7120_DAC_MULTI_DRC_MB_CTRL10:
	case CM7120_DAC_MULTI_DRC_MB_CTRL11:
	case CM7120_DAC_MULTI_DRC_MB_CTRL12:
	case CM7120_DAC_MULTI_DRC_BB_CTRL1:
	case CM7120_DAC_MULTI_DRC_BB_CTRL2:
	case CM7120_DAC_MULTI_DRC_BB_CTRL3:
	case CM7120_DAC_MULTI_DRC_BB_CTRL4:
	case CM7120_DAC_MULTI_DRC_BB_CTRL5:
	case CM7120_DAC_MULTI_DRC_BB_CTRL6:
	case CM7120_DAC_MULTI_DRC_BB_CTRL7:
	case CM7120_DAC_MULTI_DRC_BB_CTRL8:
	case CM7120_DAC_MULTI_DRC_BB_CTRL9:
	case CM7120_DAC_MULTI_DRC_BB_CTRL10:
	case CM7120_DAC_MULTI_DRC_BB_CTRL11:
	case CM7120_DAC_MULTI_DRC_BB_CTRL12:
	case CM7120_DAC_MULTI_DRC_POS_CTRL1:
	case CM7120_DAC_MULTI_DRC_POS_CTRL2:
	case CM7120_DAC_MULTI_DRC_POS_CTRL3:
	case CM7120_DAC_MULTI_DRC_POS_CTRL4:
	case CM7120_DAC_MULTI_DRC_POS_CTRL5:
	case CM7120_DAC_MULTI_DRC_POS_CTRL6:
	case CM7120_DAC_MULTI_DRC_POS_CTRL7:
	case CM7120_DAC_MULTI_DRC_POS_CTRL8:
	case CM7120_DAC_MULTI_DRC_POS_CTRL9:
	case CM7120_DAC_MULTI_DRC_POS_CTRL10:
	case CM7120_DAC_MULTI_DRC_POS_CTRL11:
	case CM7120_DAC_MULTI_DRC_POS_CTRL12:
	case CM7120_DAC_MULTI_DRC_POS_CTRL13:
	case CM7120_DAC_MULTI_DRC_POS_ST1:
	case CM7120_DAC_MULTI_DRC_POS_ST2:
	case CM7120_ADC_ALC_CTRL1:
	case CM7120_ADC_ALC_CTRL2:
	case CM7120_ADC_ALC_CTRL3:
	case CM7120_ADC_ALC_CTRL4:
	case CM7120_ADC_ALC_CTRL5:
	case CM7120_ADC_ALC_CTRL6:
	case CM7120_ADC_ALC_CTRL7:
	case CM7120_ADC_ALC_CTRL8:
	case CM7120_ADC_ALC_CTRL9:
	case CM7120_ADC_ALC_CTRL10:
	case CM7120_ADC_ALC_CTRL11:
	case CM7120_ADC_ALC_CTRL12:
	case CM7120_ADC_ALC_CTRL13:
	case CM7120_ADC_ALC_CTRL14:
	case CM7120_ADC_ALC_ST1:
	case CM7120_ADC_ALC_ST2:
	case CM7120_HP_DC_CAL_CTRL1:
	case CM7120_HP_DC_CAL_CTRL2:
	case CM7120_HP_DC_CAL_CTRL3:
	case CM7120_HP_DC_CAL_CTRL4:
	case CM7120_HP_DC_CAL_CTRL5:
	case CM7120_HP_DC_CAL_CTRL6:
	case CM7120_HP_DC_CAL_CTRL7:
	case CM7120_HP_DC_CAL_CTRL8:
	case CM7120_HP_DC_CAL_CTRL9:
	case CM7120_HP_DC_CAL_CTRL10:
	case CM7120_HP_DC_CAL_CTRL11:
	case CM7120_HP_DC_CAL_CTRL12:
	case CM7120_HP_DC_CAL_ST1:
	case CM7120_HP_DC_CAL_ST2:
	case CM7120_HP_DC_CAL_ST3:
	case CM7120_HP_DC_CAL_ST4:
	case CM7120_HP_DC_CAL_ST5:
	case CM7120_HP_DC_CAL_ST6:
	case CM7120_HP_DC_CAL_ST7:
	case CM7120_HP_DC_CAL_ST8:
	case CM7120_HP_DC_CAL_ST9:
	case CM7120_HP_DC_CAL_ST10:
	case CM7120_HP_DC_CAL_ST11:
	case CM7120_HP_DC_CAL_ST12:
	case CM7120_HP_DC_CAL_ST13:
	case CM7120_MONO_AMP_DC_CAL_CTRL1:
	case CM7120_MONO_AMP_DC_CAL_CTRL2:
	case CM7120_MONO_AMP_DC_CAL_CTRL3:
	case CM7120_MONO_AMP_DC_CAL_CTRL4:
	case CM7120_MONO_AMP_DC_CAL_CTRL5:
	case CM7120_MONO_AMP_DC_CAL_CTRL6:
	case CM7120_MONO_AMP_DC_CAL_CTRL7:
	case CM7120_MONO_AMP_DC_CAL_ST1:
	case CM7120_MONO_AMP_DC_CAL_ST2:
	case CM7120_MONO_AMP_DC_CAL_ST3:
	case CM7120_DSP_IB_CTRL1:
	case CM7120_DSP_IB_CTRL2:
	case CM7120_DSP_IN_OB_CTRL:
	case CM7120_DSP_OB01_DIG_VOL:
	case CM7120_DSP_OB23_DIG_VOL:
	case CM7120_DSP_OB45_DIG_VOL:
	case CM7120_DSP_OB67_DIG_VOL:
	case CM7120_MINI_DSP_OB01_DIG_VOL:
	case CM7120_DSP_IB1_SRC_CTRL1:
	case CM7120_DSP_IB1_SRC_CTRL2:
	case CM7120_DSP_IB1_SRC_CTRL3:
	case CM7120_DSP_IB1_SRC_CTRL4:
	case CM7120_DSP_IB2_SRC_CTRL1:
	case CM7120_DSP_IB2_SRC_CTRL2:
	case CM7120_DSP_IB2_SRC_CTRL3:
	case CM7120_DSP_IB2_SRC_CTRL4:
	case CM7120_DSP_IB3_SRC_CTRL1:
	case CM7120_DSP_IB3_SRC_CTRL2:
	case CM7120_DSP_IB3_SRC_CTRL3:
	case CM7120_DSP_IB3_SRC_CTRL4:
	case CM7120_DSP_OB1_SRC_CTRL1:
	case CM7120_DSP_OB1_SRC_CTRL2:
	case CM7120_DSP_OB1_SRC_CTRL3:
	case CM7120_DSP_OB1_SRC_CTRL4:
	case CM7120_DSP_OB2_SRC_CTRL1:
	case CM7120_DSP_OB2_SRC_CTRL2:
	case CM7120_DSP_OB2_SRC_CTRL3:
	case CM7120_DSP_OB2_SRC_CTRL4:
	case CM7120_HIFI_MINI_DSP_CTRL_ST:
	case CM7120_SPI_SLAVE_CRC_CHECK_CTRL:
	case CM7120_EFUSE_CTRL1:
	case CM7120_EFUSE_CTRL2:
	case CM7120_EFUSE_CTRL3:
	case CM7120_EFUSE_CTRL4:
	case CM7120_EFUSE_CTRL5:
	case CM7120_EFUSE_CTRL6:
	case CM7120_EFUSE_CTRL7:
	case CM7120_EFUSE_CTRL8:
	case CM7120_EFUSE_CTRL9:
	case CM7120_EFUSE_CTRL10:
	case CM7120_EFUSE_CTRL11:
	case CM7120_I2C_AND_SPI_SCRAM_CTRL:
	case CM7120_I2C_SCRAM_WRITE_KEY1_MSB:
	case CM7120_I2C_SCRAM_WRITE_KEY1_LSB:
	case CM7120_I2C_SCRAM_WRITE_KEY2_MSB:
	case CM7120_I2C_SCRAM_WRITE_KEY2_LSB:
	case CM7120_I2C_SCRAM_READ_KEY1_MSB:
	case CM7120_I2C_SCRAM_READ_KEY1_LSB:
	case CM7120_I2C_SCRAM_READ_KEY2_MSB:
	case CM7120_I2C_SCRAM_READ_KEY2_LSB:
	case CM7120_SPI_SCRAM_WRITE_KEY1_1:
	case CM7120_SPI_SCRAM_WRITE_KEY1_2:
	case CM7120_SPI_SCRAM_WRITE_KEY1_3:
	case CM7120_SPI_SCRAM_WRITE_KEY1_4:
	case CM7120_SPI_SCRAM_WRITE_KEY2_1:
	case CM7120_SPI_SCRAM_WRITE_KEY2_2:
	case CM7120_SPI_SCRAM_WRITE_KEY2_3:
	case CM7120_SPI_SCRAM_WRITE_KEY2_4:
	case CM7120_SPI_SCRAM_READ_KEY1_1:
	case CM7120_SPI_SCRAM_READ_KEY1_2:
	case CM7120_SPI_SCRAM_READ_KEY1_3:
	case CM7120_SPI_SCRAM_READ_KEY1_4:
	case CM7120_SPI_SCRAM_READ_KEY2_1:
	case CM7120_SPI_SCRAM_READ_KEY2_2:
	case CM7120_SPI_SCRAM_READ_KEY2_3:
	case CM7120_SPI_SCRAM_READ_KEY2_4:
	case CM7120_GPIO1_TEST_OUTPUT_SEL1:
	case CM7120_GPIO1_TEST_OUTPUT_SEL2:
	case CM7120_GPIO1_TEST_OUTPUT_SEL3:
	case CM7120_GPIO1_TEST_OUTPUT_SEL4:
	case CM7120_PR_REG_MONO_AMP_BIAS_CTRL:
	case CM7120_PR_REG_BIAS_CTRL1:
	case CM7120_PR_REG_BIAS_CTRL2:
	case CM7120_PR_REG_BIAS_CTRL3:
	case CM7120_PR_REG_BIAS_CTRL4:
	case CM7120_PR_REG_BIAS_CTRL5:
	case CM7120_PR_REG_BIAS_CTRL6:
	case CM7120_PR_REG_BIAS_CTRL7:
	case CM7120_PR_REG_BIAS_CTRL8:
	case CM7120_PR_REG_BIAS_CTRL9:
	case CM7120_PR_REG_BIAS_CTRL10:
	case CM7120_PR_REG_BIAS_CTRL11:
	case CM7120_PR_REG_BIAS_CTRL12:
	case CM7120_PR_REG_BIAS_CTRL13:
	case CM7120_PR_REG_ADC12_CLK_CTRL:
	case CM7120_PR_REG_ADC34_CLK_CTRL:
	case CM7120_PR_REG_ADC5_CLK_CTRL1:
	case CM7120_PR_REG_ADC5_CLK_CTRL2:
	case CM7120_PR_REG_ADC67_CLK_CTRL:
	case CM7120_PR_REG_PLL1_CTRL1:
	case CM7120_PR_REG_PLL1_CTRL2:
	case CM7120_PR_REG_PLL2_CTRL1:
	case CM7120_PR_REG_PLL2_CTRL2:
	case CM7120_PR_REG_VREF_CTRL1:
	case CM7120_PR_REG_VREF_CTRL2:
	case CM7120_PR_REG_BST1_CTRL:
	case CM7120_PR_REG_BST2_CTRL:
	case CM7120_PR_REG_BST3_CTRL:
	case CM7120_PR_REG_BST4_CTRL:
	case CM7120_DAC_ADC_DIG_VOL1:
	case CM7120_DAC_ADC_DIG_VOL2:
	case CM7120_VAD_SRAM_TEST:
	case CM7120_PAD_DRIVING_CTRL1:
	case CM7120_PAD_DRIVING_CTRL2:
	case CM7120_PAD_DRIVING_CTRL3:
	case CM7120_DIG_INPUT_PIN_ST_CTRL1:
	case CM7120_DIG_INPUT_PIN_ST_CTRL2:
	case CM7120_DIG_INPUT_PIN_ST_CTRL3:
	case CM7120_DIG_INPUT_PIN_ST_CTRL4:
	case CM7120_DIG_INPUT_PIN_ST_CTRL5:
	case CM7120_TEST_MODE_CTRL1:
	case CM7120_TEST_MODE_CTRL2:
	case CM7120_GPIO1_GPIO3_TEST_MODE_CTRL:
	case CM7120_GPIO5_GPIO6_TEST_MODE_CTRL:
	case CM7120_GPIO6_GPIO7_TEST_MODE_CTRL:
	case CM7120_CODEC_DOMAIN_REG_RW_CTRL:
	case CM7120_DAC1_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC2_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC3_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC4_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC5_CLK_AND_CHOPPER_CTRL:
	case CM7120_DAC1_DAC2_DUMMY_REG:
	case CM7120_HP_CTRL1:
	case CM7120_HP_CTRL2:
	case CM7120_HP_CTRL3:
	case CM7120_HP_CTRL4:
	case CM7120_HP_CTRL5:
	case CM7120_HP_CTRL6:
	case CM7120_LDO6_PR_CTRL1:
	case CM7120_LDO6_PR_CTRL2:
	case CM7120_LDO6_PR_CTRL3:
	case CM7120_LDO6_PR_CTRL4:
	case CM7120_LDO_AVDD1_PR_CTRL:
	case CM7120_LDO_HV2_PR_CTRL:
	case CM7120_LDO_HV3_PR_CTRL:
	case CM7120_LDO1_LDO3_LDO4_PR_CTRL:
	case CM7120_LDO8_LDO9_PR_CTRL:
	case CM7120_VREF5_L_PR_CTRL:
	case CM7120_VREF5_R_PR_CTRL:
	case CM7120_SLIMBUS_PARAMETER:
	case CM7120_SLIMBUS_RX:
	case CM7120_SLIMBUS_CTRL:
	case CM7120_LOUT_CTRL:
	case CM7120_DUMMY_REG_1:
	case CM7120_DUMMY_REG_2:
	case CM7120_DUMMY_REG_3:
	case CM7120_DUMMY_REG_4:
	case CM7120_DSP_I2C_DATA_MSB:
		return true;

	default:
		return false;
	}
}

static int cm7120_hp_vol_put(struct snd_kcontrol *kcontrol,
			     struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
	int ret = snd_soc_put_volsw(kcontrol, ucontrol);

	if (snd_soc_component_read32(component, CM7120_STO_HP_NG2_CTRL1) &
	    0x8000) {
		snd_soc_component_update_bits(
			component, CM7120_STO_HP_NG2_CTRL1, 0x8000, 0x0000);
		snd_soc_component_update_bits(
			component, CM7120_STO_HP_NG2_CTRL1, 0x8000, 0x8000);
	}

	return ret;
}

static const DECLARE_TLV_DB_SCALE(ng2_vol_tlv, -2325, 75, 0);
/* 0x16, min = -65.625dB, step = 0.375dB */
static const DECLARE_TLV_DB_SCALE(dachp_vol_tlv, -65625, 375, 0);
/* 0x0505, min = -17.625dB, step = 0.375dB */
static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -17625, 375, 0);
static const DECLARE_TLV_DB_SCALE(bst_tlv, -1200, 75, 0);
static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -17625, 375, 0);
static const DECLARE_TLV_DB_SCALE(adc_bst_tlv, 0, 1200, 0);
static const DECLARE_TLV_DB_SCALE(eq_pre_tlv, -1200, 100, 0);
static const DECLARE_TLV_DB_SCALE(eq_vol_tlv, -2000, 100, 0);

static const struct snd_kcontrol_new cm7120_snd_controls[] = {
	/* Headphone Output Volume */
	SOC_DOUBLE_R_EXT_TLV("Headphone Analog Volume", CM7120_STO_HP_NG2_CTRL2,
			     CM7120_STO_HP_NG2_CTRL3, CM7120_G_HP_SFT, 34, 1,
			     snd_soc_get_volsw, cm7120_hp_vol_put, ng2_vol_tlv),

	/* DAC Digital Volume */
	SOC_DOUBLE_TLV("Headphone Volume",
		       CM7120_DAC1_DIG_VOL, /* 0x15,  65625 / 375 = 175 */
		       CM7120_L_VOL_SFT, CM7120_R_VOL_SFT, 175, 0,
		       dachp_vol_tlv),
	SOC_DOUBLE_TLV(
		"Speaker Left Channel Volume",
		CM7120_DSP_OB45_DIG_VOL,
		/* 0x0505, [30000 - (-17625)] / 375 = 127 */
		CM7120_L_VOL_SFT, CM7120_R_VOL_SFT, 127, 0, dac_vol_tlv),
	SOC_DOUBLE_TLV("Speaker Right Channel Volume",
		       CM7120_DSP_OB67_DIG_VOL, /* 0x0506 */
		       CM7120_L_VOL_SFT, CM7120_R_VOL_SFT, 127, 0,
		       dac_vol_tlv), /* max value, invert, tlv_array */

	/* IN Boost Control */
	SOC_SINGLE_TLV("IN1 Capture Volume", CM7120_BST12_CTRL, CM7120_BST1_SFT,
		       69, 0, bst_tlv),
	SOC_SINGLE_TLV("IN2 Capture Volume", CM7120_BST12_CTRL, CM7120_BST2_SFT,
		       69, 0, bst_tlv),
	SOC_SINGLE_TLV("IN3 Capture Volume", CM7120_BST34_CTRL, CM7120_BST3_SFT,
		       69, 0, bst_tlv),
	SOC_SINGLE_TLV("IN4 Capture Volume", CM7120_BST34_CTRL, CM7120_BST4_SFT,
		       69, 0, bst_tlv),

	/* ADC Digital Volume Control, stereo2 / 0x1c */
	SOC_DOUBLE("Microphone Capture Switch", CM7120_STO2_ADC_DIG_VOL,
		   CM7120_L_MUTE_SFT, CM7120_R_MUTE_SFT, 1, 1),

	SOC_DOUBLE_TLV("Microphone Capture Volume", CM7120_STO2_ADC_DIG_VOL,
		       CM7120_STO2_ADC_L_VOL_SFT, CM7120_STO2_ADC_R_VOL_SFT,
		       127, 0, adc_vol_tlv),

	/* ADC Boost Volume Control, adc boost gain / 0x20 */
	SOC_DOUBLE_TLV("Microphone Digital Boost Volume",
		       CM7120_ADC_BST_GAIN_CTRL1, CM7120_STO2_ADC_L_BST_SFT,
		       CM7120_STO2_ADC_R_BST_SFT, 3, 0, adc_bst_tlv),

	/* ADC1 to HP out */
	SOC_SINGLE_EXT("Microphone Monitor to HP out", MIC_MONITOR_ON_OFF, 0, 1,
		       0, cm7120_get_vu, cm7120_put_vu),

	/* SPK */
	SOC_SINGLE_EXT("SPK EQ Switch", SPK_POLAR_FLIP_ON_OFF, 0, 1, 0,
		       cm7120_get_vu, cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ L1 Flip Polarity of Low Freq Enable",
		       SPK_L1_POLAR_FLIP_LF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ L2 Flip Polarity of Low Freq Enable",
		       SPK_L2_POLAR_FLIP_LF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ R1 Flip Polarity of Low Freq Enable",
		       SPK_R1_POLAR_FLIP_LF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ R2 Flip Polarity of Low Freq Enable",
		       SPK_R2_POLAR_FLIP_LF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ L1 Flip Polarity of High Freq Enable",
		       SPK_L1_POLAR_FLIP_HF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ L2 Flip Polarity of High Freq Enable",
		       SPK_L2_POLAR_FLIP_HF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ R1 Flip Polarity of High Freq Enable",
		       SPK_R1_POLAR_FLIP_HF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ R2 Flip Polarity of High Freq Enable",
		       SPK_R2_POLAR_FLIP_HF, 0, 1, 0, cm7120_get_vu,
		       cm7120_put_vu),

	SOC_SINGLE_EXT("SPK EQ L1 Cut Off Freq", SPK_L1_CUT_OFF_FREQ, 0, 32767,
		       0,
		       cm7120_get_eq_freq, cm7120_put_eq_freq),
	SOC_SINGLE_EXT("SPK EQ L2 Cut Off Freq", SPK_L2_CUT_OFF_FREQ, 0, 32767,
		       0,
		       cm7120_get_eq_freq, cm7120_put_eq_freq),
	SOC_SINGLE_EXT("SPK EQ R1 Cut Off Freq", SPK_R1_CUT_OFF_FREQ, 0, 32767,
		       0,
		       cm7120_get_eq_freq, cm7120_put_eq_freq),
	SOC_SINGLE_EXT("SPK EQ R2 Cut Off Freq", SPK_R2_CUT_OFF_FREQ, 0, 32767,
		       0,
		       cm7120_get_eq_freq, cm7120_put_eq_freq),

	SOC_SINGLE_EXT("SPK TEST LR I2S34", SPK_TEST_I2S34, 0, 2, 0,
		       cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("SPK TEST L1L2 I2S3", SPK_TEST_I2S3L, 0, 2, 0,
		       cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT("SPK TEST R1R2 I2S4", SPK_TEST_I2S4R, 0, 2, 0,
		       cm7120_get_vu, cm7120_put_vu),

	SOC_SINGLE_EXT("MIC EQ Switch", MIC_EQ_ON_OFF, 0, 1, 0,
		       cm7120_get_vu, cm7120_put_vu),
	SOC_SINGLE_EXT_TLV("MIC EQ Pre Gain", MIC_EQ_PRE_GAIN, 0, 12, 0,
			   cm7120_get_eq_gain, cm7120_put_eq_gain, eq_pre_tlv),
};

static int cm7120_get_eq_freq(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	u8 idx;

	switch (reg) {
	case SPK_L1_CUT_OFF_FREQ:
	case SPK_L2_CUT_OFF_FREQ:
	case SPK_R1_CUT_OFF_FREQ:
	case SPK_R2_CUT_OFF_FREQ:
		idx = reg - SPK_L1_CUT_OFF_FREQ;
		ucontrol->value.integer.value[0] =
		    cm7120_codec->EQSPKParam[idx].CutOffFreq;
		dev_info(cm7120_codec->dev,
			 "%s: SPK_EQ idx[%d] CUT_OFF_FREQ get value = %ld\n",
			 __func__, idx, ucontrol->value.integer.value[0]);
		break;

	default:
		break;
	}

	return 0;
}

static int cm7120_put_eq_freq(struct snd_kcontrol *kcontrol,
		struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;

	int rc = 0;

	u8 idx;

	rc = wait_for_completion_timeout(&cm7120_codec->fw_download_complete,
					 FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		pr_err("%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	switch (reg) {
	case SPK_L1_CUT_OFF_FREQ:
	case SPK_L2_CUT_OFF_FREQ:
	case SPK_R1_CUT_OFF_FREQ:
	case SPK_R2_CUT_OFF_FREQ:
		idx = reg - SPK_L1_CUT_OFF_FREQ;
		cm7120_codec->EQSPKParam[idx].CutOffFreq =
		    ucontrol->value.integer.value[0];
		cm7120_set_eqspk_value(cm7120_codec,
				       &cm7120_codec->EQSPKParam[idx],
				       0x5FFC0038 + 4 * idx);
		break;

	default:
		break;
	}

	return 0;
}

static int cm7120_get_eq_gain(struct snd_kcontrol *kcontrol,
			      struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;

	switch (reg) {
	case MIC_EQ_PRE_GAIN:
		ucontrol->value.integer.value[0] =
		    (char)cm7120_codec->preGainMic;
		break;

	default:
		break;
	}

	return 0;
}

static int cm7120_put_eq_gain(struct snd_kcontrol *kcontrol,
			      struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	int rc = 0;

	rc = wait_for_completion_timeout(&cm7120_codec->fw_download_complete,
					 FW_DOWNLOAD_TIMEOUT);
	if (rc == 0) {
		pr_err("%s: Firmware download timed out!\n", __func__);
		return -ETIMEDOUT;
	}

	switch (reg) {
	case MIC_EQ_PRE_GAIN:
		cm7120_codec->preGainMic =
		    (char)ucontrol->value.integer.value[0];
		cm7120_update_eq_pregain_enable(cm7120_codec);
		break;

	default:
		break;
	}

	return 0;
}

/**
 * 1. Mute I2S3 or Mute I2S4
 *     0: unmute all
 *     1: mute i2s3 (and unmute i2s4)
 *     2: mute i2s4 (and unmute i2s3)
 *
 * 2. Mute Left channel or Mute Right channel of I2S3
 *     0: unmute all
 *     1: mute i2s3l1 (and unmute i2s3l2)
 *     2: mute i2s3l2 (and unmute i2s3l1)
 *
 * 3. Mute Left channel or Mute Right channel of I2S4
 *     0: unmute all
 *     1: mute i2s4r1 (and unmute i2s4r2)
 *     2: mute i2s4r2 (and unmute i2s4r1)
 */
static int cm7120_set_spktest_value(struct cm7120_priv *cm7120_codec,
				    char i2s34, char item)
{
	const u32 dspAddr = 0x5ffc0004;
	const char bitShift = 28;
	u32 dspValue = 0;
	u8 spkMuteValue = 0;
	int ret = 0;

	if (cm7120_codec->is_dsp_mode) {
		mutex_lock(&cm7120_codec->dsp_lock);
		cm7120_dsp_mode_i2c_read_mem(cm7120_codec->real_regmap, dspAddr,
					     &dspValue);
		mutex_unlock(&cm7120_codec->dsp_lock);
		spkMuteValue = 0xf & (dspValue >> bitShift);
	} else {
		pr_err("%s: Not in DSP mode!!!\n", __func__);
		return -EINVAL;
	}

	switch (i2s34) {
	case 0:
		if (item == 0)
			spkMuteValue = 0;
		else if (item == 1)
			spkMuteValue = 0x3;
		else if (item == 2)
			spkMuteValue = 0xc;
		else
			ret = -EINVAL;
		break;

	case 1:
		if (item == 0)
			spkMuteValue &= ~0x3;
		else if (item == 1) {
			spkMuteValue &= ~0x3;
			spkMuteValue |= 0x1;
		} else if (item == 2) {
			spkMuteValue &= ~0x3;
			spkMuteValue |= 0x2;
		} else
			ret = -EINVAL;
		break;

	case 2:
		if (item == 0) {
			spkMuteValue &= ~0xc;
		} else if (item == 1) {
			spkMuteValue &= ~0xc;
			spkMuteValue |= 0x4;
		} else if (item == 2) {
			spkMuteValue &= ~0xc;
			spkMuteValue |= 0x8;
		} else {
			ret = -EINVAL;
		}
		break;

	default:
		ret = -EINVAL;
	}

	if (ret == 0) {
		mutex_lock(&cm7120_codec->dsp_lock);
		dspValue &= ~(0xf << bitShift);
		dspValue |= (spkMuteValue << bitShift);
		pr_debug("%s: after dspValue = 0x%08x\n", __func__, dspValue);
		cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap,
					      dspAddr, (u8 *)&dspValue, 4);
		mutex_unlock(&cm7120_codec->dsp_lock);
	}

	if (ret != 0)
		pr_err("%s: return failed value = 0x%08x\n", __func__, ret);

	return ret;
}

static int cm7120_set_eqspk_value(struct cm7120_priv *cm7120_codec,
				  struct EQSpkParam *pEQSpkParam, u32 uAddr)
{
	u32 EQElement = 0;

	EQElement = pEQSpkParam->PolarFlipLF |
	    (pEQSpkParam->PolarFlipHF << 1) | (pEQSpkParam->CutOffFreq << 2);

	dev_info(cm7120_codec->dev, "%s --------------------------\n",
		 __func__);
	dev_info(cm7120_codec->dev, "%s PolarFlipLF = %d\n", __func__,
		 pEQSpkParam->PolarFlipLF);
	dev_info(cm7120_codec->dev, "%s PolarFlipHF = %d\n", __func__,
		 pEQSpkParam->PolarFlipHF);
	dev_info(cm7120_codec->dev, "%s CutOffFreq = %d\n", __func__,
		 pEQSpkParam->CutOffFreq);

	mutex_lock(&cm7120_codec->dsp_lock);
	cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap, uAddr,
				      (u8 *)&EQElement, 4);
	mutex_unlock(&cm7120_codec->dsp_lock);

	return 0;
}

static void cm7120_update_eq_pregain_enable(struct cm7120_priv *cm7120_codec)
{
	u32 EQElement = 0;

	EQElement = cm7120_codec->bEnableSpkPolarFlip |
			(cm7120_codec->bEnableMicEQ << 1) |
			(cm7120_codec->preGainMic << 18);
	dev_info(cm7120_codec->dev, "%s EQElement = 0x%08x\n", __func__,
		 EQElement);
	mutex_lock(&cm7120_codec->dsp_lock);
	cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap, 0x5FFC0020,
				      (u8 *)&EQElement, 4);
	mutex_unlock(&cm7120_codec->dsp_lock);
}

static int cm7120_put_vu(struct snd_kcontrol *kcontrol,
			 struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	u8 idx;

	wait_for_completion_timeout(&cm7120_codec->fw_download_complete,
				    FW_DOWNLOAD_TIMEOUT);

	switch (reg) {
	case SPK_POLAR_FLIP_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableSpkPolarFlip = false;
		else
			cm7120_codec->bEnableSpkPolarFlip = true;

		dev_info(cm7120_codec->dev,
			 "%s SPK_POLAR_FLIP_ON_OFF set Value = %ld\n",
			 __func__, ucontrol->value.integer.value[0]);
		cm7120_update_eq_pregain_enable(cm7120_codec);
		break;

	case SPK_L1_POLAR_FLIP_LF:
	case SPK_L2_POLAR_FLIP_LF:
	case SPK_R1_POLAR_FLIP_LF:
	case SPK_R2_POLAR_FLIP_LF:
		idx = reg - SPK_L1_POLAR_FLIP_LF;
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->EQSPKParam[idx].PolarFlipLF = 0;
		else
			cm7120_codec->EQSPKParam[idx].PolarFlipLF = 1;

		dev_info(cm7120_codec->dev,
			"%s: SPK_EQ idx[%d] POLAR_FLIP_LF enable = %ld\n",
			__func__, idx, ucontrol->value.integer.value[0]);
		cm7120_set_eqspk_value(cm7120_codec,
				       &cm7120_codec->EQSPKParam[idx],
				       0x5FFC0038 + 4 * idx);
		break;

	case SPK_L1_POLAR_FLIP_HF:
	case SPK_L2_POLAR_FLIP_HF:
	case SPK_R1_POLAR_FLIP_HF:
	case SPK_R2_POLAR_FLIP_HF:
		idx = reg - SPK_L1_POLAR_FLIP_HF;
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->EQSPKParam[idx].PolarFlipHF = 0;
		else
			cm7120_codec->EQSPKParam[idx].PolarFlipHF = 1;

		dev_info(cm7120_codec->dev,
			"%s: SPK_EQ idx[%d] POLAR_FLIP_HF enable = %ld\n",
			__func__, idx, ucontrol->value.integer.value[0]);
		cm7120_set_eqspk_value(cm7120_codec,
				       &cm7120_codec->EQSPKParam[idx],
				       0x5FFC0038 + 4 * idx);
		break;

	case MIC_EQ_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0)
			cm7120_codec->bEnableMicEQ = false;
		else
			cm7120_codec->bEnableMicEQ = true;

		cm7120_update_eq_pregain_enable(cm7120_codec);
		dev_info(cm7120_codec->dev,
			 "%s MIC_EQ_ON_OFF set Value = %ld\n", __func__,
			 ucontrol->value.integer.value[0]);

		break;

	case MIC_MONITOR_ON_OFF:
		if (ucontrol->value.integer.value[0] == 0) {
			dev_dbg(cm7120_codec->dev,
				"%s MIC_MONITOR_ON_OFF disable\n", __func__);
			cm7120_codec->bEnableMonitor = false;

			/* 0x46 */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_L,
					   CM7120_M_ADDA_MIXER1_L);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_R,
					   CM7120_M_ADDA_MIXER1_R);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_ADDA1_SEL_MASK, 0);

			/* 0x1c, stereo2 adc digital volume */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 8,
					   0xf << 8);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 0,
					   0xf << 0);

			/* SND_SOC_DAPM_POST_PMD: */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC1_HPL,
					   0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC2_HPR,
					   0);
			dev_dbg(component->dev, "HP gpio to low (fake)");

		} else {
			dev_dbg(cm7120_codec->dev,
				"%s MIC_MONITOR_ON_OFF enable\n", __func__);
			cm7120_codec->bEnableMonitor = true;

			/* 0x1c, stereo2_adc_mute set unmute */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL,
					   CM7120_L_MUTE, 0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL,
					   CM7120_R_MUTE, 0);

			/* 0x1c, stereo2 adc digital volume */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 8,
					   0xf << 8);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_STO2_ADC_DIG_VOL, 0x7f << 0,
					   0xf << 0);

			/* 0x46 */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_L, 0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_M_ADDA_MIXER1_R, 0);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_DAC1_MIXER_CTRL,
					   CM7120_ADDA1_SEL_MASK, 1);

			/* 0x20, adc boost gain control for stereo1 / stereo2 */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_ADC_BST_GAIN_CTRL1,
					   CM7120_STO2_ADC_L_BST_MASK,
					   0x1 << CM7120_STO2_ADC_L_BST_SFT);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_ADC_BST_GAIN_CTRL1,
					   CM7120_STO2_ADC_R_BST_MASK,
					   0x1 << CM7120_STO2_ADC_R_BST_SFT);

			/* SND_SOC_DAPM_POST_PMU: */
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC1_HPL,
					   CM7120_EN_DAC1_HPL);
			regmap_update_bits(cm7120_codec->virt_regmap,
					   CM7120_HP_OUT, CM7120_EN_DAC2_HPR,
					   CM7120_EN_DAC2_HPR);
			dev_dbg(component->dev, "HP gpio to high (fake)");
		}
		dev_dbg(cm7120_codec->dev,
			"%s MIC_MONITOR_ON_OFF set Value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case SPK_TEST_I2S34:
		cm7120_codec->i2s34 = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
			"%s: SPK_TEST_I2S34: %d\n", __func__,
			cm7120_codec->i2s34);
		cm7120_set_spktest_value(cm7120_codec, 0, cm7120_codec->i2s34);
		break;

	case SPK_TEST_I2S3L:
		cm7120_codec->i2s3l = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
			"%s: SPK_TEST_I2S3L: %d\n", __func__,
			cm7120_codec->i2s3l);
		cm7120_set_spktest_value(cm7120_codec, 1, cm7120_codec->i2s3l);
		break;

	case SPK_TEST_I2S4R:
		cm7120_codec->i2s4r = ucontrol->value.integer.value[0];
		dev_dbg(cm7120_codec->dev,
			"%s: SPK_TEST_I2S4R: %d\n", __func__,
			cm7120_codec->i2s4r);
		cm7120_set_spktest_value(cm7120_codec, 2, cm7120_codec->i2s4r);
		break;
	}

	return 0;
}

static int cm7120_get_vu(struct snd_kcontrol *kcontrol,
			 struct snd_ctl_elem_value *ucontrol)
{
	struct soc_mixer_control *mc =
		(struct soc_mixer_control *)kcontrol->private_value;
	struct snd_soc_component *component =
		snd_soc_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120_codec =
		snd_soc_component_get_drvdata(component);
	unsigned int reg = mc->reg;
	u8 idx;

	switch (reg) {
	case SPK_POLAR_FLIP_ON_OFF:
		if (cm7120_codec->bEnableSpkPolarFlip)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_info(cm7120_codec->dev,
			 "%s SPK_POLAR_FLIP_ON_OFF get value = %ld\n", __func__,
			 ucontrol->value.integer.value[0]);
		break;

	case SPK_L1_POLAR_FLIP_HF:
	case SPK_L2_POLAR_FLIP_HF:
	case SPK_R1_POLAR_FLIP_HF:
	case SPK_R2_POLAR_FLIP_HF:
		idx = reg - SPK_L1_POLAR_FLIP_HF;
		if (cm7120_codec->EQSPKParam[idx].PolarFlipHF)
			ucontrol->value.integer.value[0] = 1;
		else
			ucontrol->value.integer.value[0] = 0;
		dev_info(cm7120_codec->dev,
			 "%s: SPK_EQ idx[%d] POLAR_FLIP_HF get value = %ld\n",
			 __func__, idx, ucontrol->value.integer.value[0]);
		break;

	case MIC_MONITOR_ON_OFF:
		if (cm7120_codec->bEnableMonitor)
			ucontrol->value.integer.value[0] = true;
		else
			ucontrol->value.integer.value[0] = false;

		dev_dbg(cm7120_codec->dev,
			"%s MIC_MONITOR_ON_OFF get value = %ld\n", __func__,
			ucontrol->value.integer.value[0]);
		break;

	case SPK_TEST_I2S34:
		ucontrol->value.integer.value[0] = cm7120_codec->i2s34;
		dev_dbg(cm7120_codec->dev,
			"%s: SPK_TEST_I2S34: %d\n", __func__,
			cm7120_codec->i2s34);
		break;

	case SPK_TEST_I2S3L:
		ucontrol->value.integer.value[0] = cm7120_codec->i2s3l;
		dev_dbg(cm7120_codec->dev,
			"%s: SPK_TEST_I2S3L: %d\n", __func__,
			cm7120_codec->i2s3l);
		break;

	case SPK_TEST_I2S4R:
		ucontrol->value.integer.value[0] = cm7120_codec->i2s4r;
		dev_dbg(cm7120_codec->dev,
			"%s: SPK_TEST_I2S4R: %d\n", __func__,
			cm7120_codec->i2s4r);
		break;
	}
	return 0;
}

static int cm7120_hw_params(struct snd_pcm_substream *substream,
			    struct snd_pcm_hw_params *params,
			    struct snd_soc_dai *dai)
{
	struct snd_soc_component *component = dai->component;
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	unsigned int val_len = 0;

	cm7120->sampleRate = params_rate(params);

	if (cm7120->sampleRate != 48000)
		return -EINVAL;

	switch (params_format(params)) {
	case SNDRV_PCM_FORMAT_S16_LE:
		break;

	case SNDRV_PCM_FORMAT_S20_3LE:
		val_len |= CM7120_I2S_DL_20;
		break;

	case SNDRV_PCM_FORMAT_S24_LE:
		val_len |= CM7120_I2S_DL_24;
		break;

	default:
		return -EINVAL;
	}

	regmap_update_bits(cm7120->virt_regmap, CM7120_I2S2_SDP,
			   CM7120_I2S_DL_MASK, val_len);

	return 0;
}

static int
cm7120_microphone_in_enum_ext_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_component *component =
		snd_soc_dapm_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);

	ucontrol->value.integer.value[0] = cm7120->microphoneSrc;
	dev_info(cm7120->dev, "%s microphoneSrc = %d\n", __func__,
		 cm7120->microphoneSrc);

	return 0;
}

static int
cm7120_microphone_in_enum_ext_put(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_component *component =
		snd_soc_dapm_kcontrol_component(kcontrol);
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	int ret = 0;

	cm7120->microphoneSrc = ucontrol->value.integer.value[0];
	dev_info(cm7120->dev, "%s microphone Src select %d\n", __func__,
		 cm7120->microphoneSrc);
	switch (cm7120->microphoneSrc) {
		/* ADC1/2 */
	case 0:
		regmap_update_bits(cm7120->virt_regmap,
				   CM7120_STO2_ADC_MIXER_CTRL,
				   CM7120_SEL_STO2_ANA_ADC, 0);
		break;
		/* ADC3/4 */
	case 1:
		regmap_update_bits(cm7120->virt_regmap,
				   CM7120_STO2_ADC_MIXER_CTRL,
				   CM7120_SEL_STO2_ANA_ADC,
				   1 << CM7120_SEL_STO2_ANA_ADC_SFT);
		break;
	default:
		dev_err(cm7120->dev, "%s EINVAL\n", __func__);
		ret = -EINVAL;
		break;
	}
	return ret;
}

static int HP_dapm_power_event(struct snd_soc_dapm_widget *w,
			       struct snd_kcontrol *kcontrol, int event)
{
	struct snd_soc_component *component =
		snd_soc_dapm_to_component(w->dapm);
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);

	switch (event) {
	case SND_SOC_DAPM_POST_PMU:
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC1_HPL, CM7120_EN_DAC1_HPL);
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC2_HPR, CM7120_EN_DAC2_HPR);
		dev_info(component->dev, "HP gpio to high\n");
		break;
	case SND_SOC_DAPM_POST_PMD:
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC1_HPL, 0);
		regmap_update_bits(cm7120->virt_regmap, CM7120_HP_OUT,
				   CM7120_EN_DAC2_HPR, 0);
		dev_info(component->dev, "HP gpio to low\n");
		break;
	default:
		dev_err(component->dev,
			"Unhandled dapm widget event %d from %s\n", event,
			w->name);
	}
	return 0;
}

static int SPK_dapm_power_event(struct snd_soc_dapm_widget *w,
				struct snd_kcontrol *kcontrol, int event)
{
	struct snd_soc_component *component =
		snd_soc_dapm_to_component(w->dapm);

	switch (event) {
	case SND_SOC_DAPM_POST_PMU:
		dev_info(component->dev, "SPK gpio to high\n");
		break;
	case SND_SOC_DAPM_POST_PMD:
		dev_info(component->dev, "SPK gpio to low\n");
		break;
	default:
		dev_err(component->dev,
			"Unhandled dapm widget event %d from %s\n", event,
			w->name);
	}
	return 0;
}

/*Output Mixer*/
static const struct snd_kcontrol_new output_mix[] = {
	SOC_DAPM_SINGLE("HP Switch", SND_SOC_NOPM, 0, 1, 0),
	SOC_DAPM_SINGLE("SPK Switch", SND_SOC_NOPM, 0, 1, 0),
};

/* Playback Input Source */
static const char *const cm7120_adcin_src[] = { "ADC1/2", "ADC3/4" };

static SOC_ENUM_SINGLE_EXT_DECL(cm7120_microphone_in_enum, cm7120_adcin_src);

static const struct snd_kcontrol_new cm7120_microphone_in_mux =
	SOC_DAPM_ENUM_EXT("Microphone From", cm7120_microphone_in_enum,
			cm7120_microphone_in_enum_ext_get,
			cm7120_microphone_in_enum_ext_put);

static const struct snd_soc_dapm_widget cm7120_dapm_widgets[] = {
	SND_SOC_DAPM_OUTPUT("OUTL"),
	SND_SOC_DAPM_OUTPUT("OUTR"),
	SND_SOC_DAPM_INPUT("IN1"),
	SND_SOC_DAPM_INPUT("IN2"),
	SND_SOC_DAPM_INPUT("IN3"),
	SND_SOC_DAPM_INPUT("IN4"),

	SND_SOC_DAPM_ADC("ADC1/2", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_ADC("ADC3/4", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_DAC("DAC1", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_DAC("DAC2", NULL, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_PGA("DAC1PGA", CM7120_LOUT, 15, 1, NULL, 0),
	SND_SOC_DAPM_PGA("DAC2PGA", CM7120_LOUT, 7, 1, NULL, 0),
	SND_SOC_DAPM_OUT_DRV_E("HP Driver", SND_SOC_NOPM, 0, 0, NULL, 0,
			       HP_dapm_power_event,
			       SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),
	SND_SOC_DAPM_OUT_DRV_E("SPK Driver", SND_SOC_NOPM, 0, 0, NULL, 0,
			       SPK_dapm_power_event,
			       SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),

	SND_SOC_DAPM_MIXER("OUTPUT MIX", SND_SOC_NOPM, 0, 0, output_mix,
			   ARRAY_SIZE(output_mix)),
	SND_SOC_DAPM_MUX("Microphone From Mux", SND_SOC_NOPM, 0, 0,
			 &cm7120_microphone_in_mux),

	SND_SOC_DAPM_AIF_IN("AIF2RX", "AIF2 Playback", 0, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_AIF_OUT("AIF2TX", "AIF2 Capture", 0, SND_SOC_NOPM, 0, 0),
	SND_SOC_DAPM_MICBIAS("I2S3PWR", CM7120_PWR_DIG1, CM7120_PWR_I2S3_BIT,
			     0),
	SND_SOC_DAPM_MICBIAS("I2S4PWR", CM7120_PWR_DIG1, CM7120_PWR_I2S4_BIT,
			     0),

};

static const struct snd_soc_dapm_route cm7120_dapm_routes[] = {
	{ "ADC1/2", NULL, "IN1" },
	{ "ADC1/2", NULL, "IN2" },
	{ "ADC3/4", NULL, "IN3" },
	{ "ADC3/4", NULL, "IN4" },
	{ "Microphone From Mux", "ADC1/2", "ADC1/2" },
	{ "Microphone From Mux", "ADC3/4", "ADC3/4" },
	{ "DAC1PGA", NULL, "AIF2RX" },
	{ "DAC2PGA", NULL, "AIF2RX" },
	{ "I2S3PWR", NULL, "AIF2RX" },
	{ "I2S4PWR", NULL, "I2S3PWR" },
	{ "DAC1", NULL, "DAC1PGA" },
	{ "DAC2", NULL, "DAC2PGA" },
	{ "HP Driver", NULL, "DAC1" },
	{ "HP Driver", NULL, "DAC2" },
	{ "SPK Driver", NULL, "I2S4PWR" },
	{ "OUTPUT MIX", "HP Switch", "HP Driver" },
	{ "OUTPUT MIX", "SPK Switch", "SPK Driver" },
	{ "OUTL", NULL, "OUTPUT MIX" },
	{ "OUTR", NULL, "OUTPUT MIX" },
	{ "AIF2TX", NULL, "Microphone From Mux" },
};

static ssize_t cm7120_is_dsp_mode_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);

	return snprintf(buf, 3, "%c\n", cm7120->is_dsp_mode ? 'Y' : 'N');
}
static DEVICE_ATTR(is_dsp_mode, 0444, cm7120_is_dsp_mode_show, NULL);

static u32 param_parsing(char *buf, u32 Count, u32 *dwAddr, u32 *dwData)
{
	char *p = NULL, *ptr = NULL;
	char *Param[2] = { 0 };
	int err = 0;
	u32 dwIdx = 0, dwParamCount = 0;
	*dwAddr = 0;
	*dwData = 0;

	p = buf;
	do {
		for (; dwIdx < Count; dwIdx++) {
			ptr = strnchr(hextext, strlen(hextext), *p);
			if (ptr)
				break;
			p++;
		}

		if (dwIdx == Count)
			break;
		if (dwParamCount < 2)
			Param[dwParamCount] = p;

		dwParamCount++;
		for (; dwIdx < Count; dwIdx++) {
			ptr = strnchr(hextext, strlen(hextext), *p);
			if (ptr == NULL) {
				*p = 0;
				p++;
				dwIdx++;
				break;
			}
			*p = tolower(*p);
			p++;
		}
	} while (dwIdx < Count);

	if (Param[0]) {
		if (Param[0][0] == '0' && Param[0][1] == 'x')
			err = kstrtou32(Param[0], 16, dwAddr);
		else
			err = kstrtou32(Param[0], 10, dwAddr);

		if (err)
			return err;

		pr_debug("%s Param[0] = %s dwAddr = %d\n", __func__, Param[0],
			 *dwAddr);
	}

	if (Param[1]) {
		if (Param[1][0] == '0' && Param[1][1] == 'x')
			err = kstrtou32(Param[1], 16, dwData);
		else
			err = kstrtou32(Param[1], 10, dwData);

		if (err)
			return err;

		pr_debug("%s Param[1] = %s dwData = %d\n", __func__, Param[1],
			 *dwData);
	}

	return dwParamCount;
}

static ssize_t cm7120_Codec_Reg_Show(struct device *dev,
				     struct device_attribute *attr, char *buf)
{
	struct cm7120_priv *cm7120 = dev_get_drvdata(dev);
	u32 dwValue = 0;

	regmap_read(cm7120->virt_regmap, CodecAddr, &dwValue);

	dwValue = dwValue & 0xFFFF;
	return scnprintf(buf, PAGE_SIZE, "0x%04x\n", dwValue);
}

static ssize_t cm7120_Codec_Reg_Set(struct device *dev,
				    struct device_attribute *attr,
				    const char *buf, size_t count)
{
	struct cm7120_priv *cm7120 = dev_get_drvdata(dev);
	u32 dwAddr = 0, dwData = 0;
	u32 dwParamCount;

	dwParamCount = param_parsing((char *)buf, (u32)count, &dwAddr, &dwData);
	dwAddr = dwAddr & 0xFFFF;
	dwData = dwData & 0xFFFF;

	if (dwParamCount == 1)
		CodecAddr = dwAddr;
	else if (dwParamCount == 2) {
		CodecAddr = dwAddr;
		regmap_write(cm7120->virt_regmap, CodecAddr, dwData);
	}

	pr_debug("%s %s BufLen=%zu dwParamCount = %d\n", __func__, buf, count,
		 dwParamCount);

	return count;
}

static int cm7120_dsp_mode_i2c_read_mem(struct regmap *regmap, u32 uAddr,
					u32 *Data)
{
	u32 AddrRegL;
	u32 AddrRegH;
	u32 DataReg;
	int ret = -EIO;

	if (uAddr & 0x03)
		return ret;

	ret = 0;
	AddrRegL = uAddr & 0xffff;
	AddrRegH = uAddr >> 16;
	regmap_write(regmap, 0x01, AddrRegL);
	regmap_write(regmap, 0x02, AddrRegH);
	regmap_write(regmap, 0x00, 0x02);
	regmap_read(regmap, 0x03, &DataReg);
	*Data = DataReg & 0xFFFF;
	regmap_read(regmap, 0x04, &DataReg);
	*Data |= (DataReg & 0xFFFF) << 16;

	return ret;
}

static int cm7120_dsp_mode_i2c_write_mem(struct regmap *regmap, u32 uAddr,
					 u8 *Data, int len)
{
	int count, idx;
	u32 AddrRegL;
	u32 AddrRegH;
	u32 DataRegL;
	u32 DataRegH;
	int ret = 0;

	if (0 == (uAddr & 0x03)) {
		if (0 != (len & 0x03)) {
			count = len >> 2;
			for (idx = 0; idx < count; idx++) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = Data[2] | (Data[3] << 8);
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
				uAddr += 4;
				Data += 4;
			}
		} else {
			count = len >> 2;
			for (idx = 0; idx < count; idx++) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = Data[2] | (Data[3] << 8);
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
				uAddr += 4;
				Data += 4;
			}
			if (1 == (len & 0x03)) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0];
				DataRegH = 0;
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
			} else if (2 == (len & 0x03)) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = 0;
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
			} else if (3 == (len & 0x03)) {
				AddrRegL = uAddr & 0xffff;
				AddrRegH = uAddr >> 16;
				DataRegL = Data[0] | (Data[1] << 8);
				DataRegH = Data[2];
				regmap_write(regmap, 0x01, AddrRegL);
				regmap_write(regmap, 0x02, AddrRegH);
				regmap_write(regmap, 0x03, DataRegL);
				regmap_write(regmap, 0x04, DataRegH);
				regmap_write(regmap, 0x00, 0x03);
			}
		}
	} else
		ret = -EIO;

	return ret;
}

static ssize_t cm7120_Dsp_Mem_Show(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	struct cm7120_priv *cm7120 = dev_get_drvdata(dev);
	u32 dwValue = 0;

	if (cm7120->is_dsp_mode) {
		mutex_lock(&cm7120->dsp_lock);
		cm7120_dsp_mode_i2c_read_mem(cm7120->real_regmap, DspAddr,
					     &dwValue);
		mutex_unlock(&cm7120->dsp_lock);
	}

	return scnprintf(buf, PAGE_SIZE, "0x%08x\n", dwValue);
}

static ssize_t cm7120_Dsp_Mem_Set(struct device *dev,
				  struct device_attribute *attr,
				  const char *buf, size_t count)
{
	struct cm7120_priv *cm7120_codec = dev_get_drvdata(dev);
	u32 dwAddr = 0, dwData = 0;
	u32 dwParamCount;

	dwParamCount = param_parsing((char *)buf, (u32)count, &dwAddr, &dwData);

	if (dwParamCount == 1) {
		DspAddr = dwAddr;
	} else if (dwParamCount == 2) {
		DspAddr = dwAddr;
		if (cm7120_codec->is_dsp_mode) {
			mutex_lock(&cm7120_codec->dsp_lock);
			cm7120_dsp_mode_i2c_write_mem(cm7120_codec->real_regmap,
					DspAddr, (u8 *) &dwData, 4);
			mutex_unlock(&cm7120_codec->dsp_lock);
		}
	}

	pr_debug("%s %s BufLen=%zu dwParamCount = %d\n", __func__, buf,
		count, dwParamCount);

	return count;
}

static DEVICE_ATTR(cm7120codec, 0664, cm7120_Codec_Reg_Show,
		   cm7120_Codec_Reg_Set);
static DEVICE_ATTR(cm7120dsp, 0644, cm7120_Dsp_Mem_Show, cm7120_Dsp_Mem_Set);

static int cm7120_set_bias_level(struct snd_soc_component *component,
				 enum snd_soc_bias_level level)
{
	switch (level) {
	case SND_SOC_BIAS_ON:
		break;

	case SND_SOC_BIAS_PREPARE:
		break;

	case SND_SOC_BIAS_STANDBY:
		break;

	case SND_SOC_BIAS_OFF:
		break;

	default:
		break;
	}
	component->dapm.bias_level = level;

	return 0;
}

static int cm7120_probe(struct snd_soc_component *component)
{
	struct cm7120_priv *cm7120 = snd_soc_component_get_drvdata(component);
	int ret = 0;

	dev_info(cm7120->dev, "Codec driver version %s\n", VERSION);

	cm7120->component = component;

	/* enable clock */
	cm7120->mclk = clk_get(cm7120->dev, "cm7120_mclk");
	if (IS_ERR(cm7120->mclk)) {
		dev_err(cm7120->dev, "get CM7120 MCLK error, %p\n",
			PTR_ERR(cm7120->mclk));
		return PTR_ERR(cm7120->mclk);
	}

	ret = clk_prepare_enable(cm7120->mclk);
	if (ret < 0) {
		dev_err(cm7120->dev, "enable CM7120 MCLK error\n");
		return ret;
	}

	dev_info(cm7120->dev, "enable CM7120 MCLK success\n");
	msleep(20);

	mutex_init(&cm7120->dsp_lock);

	ret = device_create_file(component->dev, &dev_attr_cm7120codec);
	if (ret) {
		dev_info(component->dev, "error creating codec sysfs files\n");
		return ret;
	}

	ret = device_create_file(component->dev, &dev_attr_is_dsp_mode);
	if (ret != 0) {
		dev_err(component->dev,
			"Failed to create is_dsp_mode sysfs files: %d\n", ret);
		return ret;
	}

	cm7120_set_bias_level(component, SND_SOC_BIAS_OFF);

	ret = cm7120_download_firmware(cm7120);

	complete_all(&cm7120->fw_download_complete);

	pr_info("%s: finished.\n", __func__);

	return ret;
}

static void cm7120_remove(struct snd_soc_component *component)
{
	cm7120_set_bias_level(component, SND_SOC_BIAS_OFF);

	device_remove_file(component->dev, &dev_attr_cm7120dsp);
	device_remove_file(component->dev, &dev_attr_cm7120codec);
	device_remove_file(component->dev, &dev_attr_is_dsp_mode);
}

#ifdef CONFIG_PM
static int cm7120_suspend(struct snd_soc_component *component)
{
	return 0;
}

static int cm7120_resume(struct snd_soc_component *component)
{
	return 0;
}
#else
#define cm7120_suspend NULL
#define cm7120_resume NULL
#endif

static int cm7120_i2c_read(void *context, unsigned int reg, unsigned int *val)
{
	struct i2c_client *client = context;
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);

	if (cm7120->is_dsp_mode)
#ifndef DSP_MODE_USE_SPI
		cm7120_dsp_mode_i2c_read(cm7120, reg, val);
#else
		cm7120_spi_read(0x1800c000 + reg * 2, val, 2);
#endif
	else
		regmap_read(cm7120->real_regmap, reg, val);

	return 0;
}

static int cm7120_i2c_write(void *context, unsigned int reg, unsigned int val)
{
	struct i2c_client *client = context;
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);

	if (cm7120->is_dsp_mode)
#ifndef DSP_MODE_USE_SPI
		cm7120_dsp_mode_i2c_write(cm7120, reg, val);
#else
		cm7120_spi_write(0x1800c000 + reg * 2, val, 2);
#endif
	else
		regmap_write(cm7120->real_regmap, reg, val);

	return 0;
}

#define CM7120_STEREO_RATES SNDRV_PCM_RATE_48000
#define CM7120_FORMATS                                                         \
	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |                  \
	 SNDRV_PCM_FMTBIT_S24_LE)

struct snd_soc_dai_ops cm7120_aif_dai_ops = {
	.hw_params = cm7120_hw_params,
};

struct snd_soc_dai_driver cm7120_dai[] = {
	{
		.name = "cm7120-aif2",
		.id = CM7120_AIF2,
		.playback = {
			.stream_name = "AIF2 Playback",
			.channels_min = 1,
			.channels_max = 2,
			.rates = CM7120_STEREO_RATES,
			.formats = CM7120_FORMATS,
		},
		.capture = {
			.stream_name = "AIF2 Capture",
			.channels_min = 1,
			.channels_max = 2,
			.rates = CM7120_STEREO_RATES,
			.formats = CM7120_FORMATS,
		},
		.ops = &cm7120_aif_dai_ops,
		.symmetric_rates = 1,
	},
};

static struct snd_soc_component_driver soc_component_dev_cm7120 = {
	.name = "cm7120",
	.probe = cm7120_probe,
	.remove = cm7120_remove,
	.suspend = cm7120_suspend,
	.resume = cm7120_resume,
	.set_bias_level = cm7120_set_bias_level,
	.controls = cm7120_snd_controls,
	.num_controls = ARRAY_SIZE(cm7120_snd_controls),
	.dapm_widgets = cm7120_dapm_widgets,
	.num_dapm_widgets = ARRAY_SIZE(cm7120_dapm_widgets),
	.dapm_routes = cm7120_dapm_routes,
	.num_dapm_routes = ARRAY_SIZE(cm7120_dapm_routes),
};

static const struct regmap_config cm7120_regmap_physical = {
	.name = "physical",
	.reg_bits = 16,
	.val_bits = 16,

	.max_register = CM7120_DUMMY_REG_4,
	.readable_reg = cm7120_readable_register,

	.cache_type = REGCACHE_NONE,
};

static const struct regmap_config cm7120_regmap = {
	.reg_bits = 16,
	.val_bits = 16,

	.max_register = CM7120_DUMMY_REG_4,
	.volatile_reg = cm7120_volatile_register,
	.readable_reg = cm7120_readable_register,
	.reg_read = cm7120_i2c_read,
	.reg_write = cm7120_i2c_write,

	.cache_type = REGCACHE_RBTREE,
	.reg_defaults = cm7120_reg,
	.num_reg_defaults = ARRAY_SIZE(cm7120_reg),
};

static const struct i2c_device_id cm7120_i2c_id[] = {
	{ "cm7120", 1 /* CM7120 */ },
	{}
};
MODULE_DEVICE_TABLE(i2c, cm7120_i2c_id);

#if defined(CONFIG_OF)
static const struct of_device_id cm7120_of_match[] = {
	{.compatible = "C-Media,cm7120",},
	{},
};
MODULE_DEVICE_TABLE(of, cm7120_of_match);
#endif

static int cm7120_download_firmware(struct cm7120_priv *cm7120_codec)
{
	u32 version = 0;
	int ret = 0;

	dev_info(cm7120_codec->dev, "%s entry\n", __func__);

	ret = request_firmware(&cm7120_codec->fw, CM7120_FIRMWARE,
			       cm7120_codec->dev);
	if (ret) {
		dev_err(cm7120_codec->dev, "%s: request_firmware failed: %d\n",
			__func__, ret);
		return ret;
	}

	dev_info(cm7120_codec->dev,
		 "%s(): ready to parser, bin file size = %d\n", __func__,
		 cm7120_codec->fw->size);

	ret = cm7120_firmware_parsing(cm7120_codec,
				      (void *)cm7120_codec->fw->data,
				      cm7120_codec->fw->size);
	release_firmware(cm7120_codec->fw);
	if (ret) {
		dev_err(cm7120_codec->dev,
			"%s: cm7120_firmware_parsing failed: %d\n", __func__,
			ret);
		return ret;
	}

	msleep(30);

	/* trigger DSP FW run */
	/* bit-0 is 0 */
	regmap_update_bits(cm7120_codec->virt_regmap, CM7120_PWR_DSP, 0x1, 0x0);
	msleep(30);

	cm7120_dsp_mode_i2c_read_addr(cm7120_codec, 0x5FFC001C, &version);
	pr_info("%s (%d): DSP version = 0x%08x\n", __func__, __LINE__, version);

	return 0;
}

static int cm7120_write_firmware_romcode(struct cm7120_priv *cm7120,
					 u8 *binFile, int blockNum)
{
	u32 blockAddr;
	u32 blockSize;
	int i, ret;
	const int headerBlockInfo = 8;

	u8 *fwHeader = binFile + 0x1e000 + headerBlockInfo;
	u8 *fwData = binFile + 0x1e000 + headerBlockInfo + (8 * blockNum);

	/* multifunction SPI select */
	/* 0x00c1 */
	regmap_write(cm7120->virt_regmap, CM7120_MF_PIN_CTRL2, 0x1e01);

	for (i = 0; i < blockNum; i++) {
		blockAddr = *(fwHeader + (i * 8) + 0) << 0 |
			*(fwHeader + (i * 8) + 1) << 8 |
			*(fwHeader + (i * 8) + 2) << 16 |
			*(fwHeader + (i * 8) + 3) << 24;
		pr_info("block[%d] address = 0x%08x\n", i, blockAddr);

		blockSize = *(fwHeader + (i * 8) + 4) << 0 |
			*(fwHeader + (i * 8) + 5) << 8 |
			*(fwHeader + (i * 8) + 6) << 16 |
			*(fwHeader + (i * 8) + 7) << 24;
		pr_info("block[%d] size = 0x%08x\n", i, blockSize);

		ret = cm7120_spi_burst_write(blockAddr, fwData, blockSize);
		if (ret < 0) {
			pr_err("%s: cm7120_spi_burst_write() failed!!!\n",
			       __func__);
			return ret;
		}
		pr_info("block[%d] ---- write successfully ----\n", i);

		fwData += blockSize;
	}

	return 0;
}

static int cm7120_write_firmware_codec_cmd(struct cm7120_priv *cm7120,
					   u8 *ConfigData, int count)
{
	u16 uAddr;
	u16 uValue;
	u8 uRegDelay;

	int i;
	int ret = 0;

	pr_info("%s: register count = %d\n", __func__, count);

	for (i = 0; i < count; i++) {
		uAddr = ConfigData[i * 5 + 0] | ConfigData[i * 5 + 1] << 8;
		uValue = ConfigData[i * 5 + 2] | ConfigData[i * 5 + 3] << 8;
		uRegDelay = ConfigData[i * 5 + 4];

		ret = regmap_write(cm7120->virt_regmap, uAddr, uValue);
		if (ret < 0) {
			pr_err("%s: Codec Init Failed in I2C failed in Command (%d)\n",
					__func__, i);
			return ret;
		}

		if (uRegDelay >= 20)
			msleep(uRegDelay);
		else
			usleep_range(uRegDelay * 1000, uRegDelay * 1000 + 500);

		/* the last one i2c cmd is for enable DSP for flash load code */
		if ((i == 0) || (i == (count - 1)))
			pr_info("[%d]: uAddr = 0x%04x, uValue = 0x%04x, uDelay = 0x%02x\n",
				i, uAddr, uValue, uRegDelay);
	}

	return 0;
}

static int cm7120_firmware_parsing(struct cm7120_priv *cm7120,
				   void *FirmwareData, size_t len)
{
	u8 *fwData = FirmwareData;
	u32 regAddr = 0;

	int ret;
	int count;

	/* check header of block */
	/* offset [3:0] = 0x0a, 0x1c, 0x56, 0x79 */
	regAddr = 0x7A000;
	dev_info(cm7120->dev, "%s: Factory Register Setting: addr = 0x%08x\n",
		 __func__, regAddr);

	/* register number: 0x7A000 offset [5:4], little endian */
	count = *(fwData + regAddr + 4) | *(fwData + regAddr + 5) << 8;
	pr_info("register count = %d\n", count);

	/* offset [4:5] = register number count */
	/* offset [6:7] = checksum */
	/* offset [8:N] = register pair data */
	ret = cm7120_write_firmware_codec_cmd(cm7120, fwData + regAddr + 8,
					      count);

	if (ret == 0)
		cm7120->is_dsp_mode = true;

	/* Factory Hifi-3 Firmware / DSP code */
	regAddr = 0x1E000;
	dev_info(cm7120->dev,
		 "%s: Factory Hifi-3 Firmware / DSP code: addr = 0x%08x\n",
		 __func__, regAddr);

	/* block number: 0x1E000 offset [5:4], little endian */
	count = *(fwData + regAddr + 4) | *(fwData + regAddr + 5) << 8;
	pr_info("block number = %d\n", count);

	ret = cm7120_write_firmware_romcode(cm7120, fwData, count);

	pr_info("%s: cm7120_write_firmware_romcode() dsp load code successfully.\n",
			__func__);

	return 0;
}

static void cm7120_firmware_download_work(struct work_struct *work)
{
	struct cm7120_priv *cm7120_codec =
		container_of(work, struct cm7120_priv, fw_download_work);
	int ret = 0;

	dev_info(cm7120_codec->dev, "%s entry\n", __func__);

	ret = cm7120_download_firmware(cm7120_codec);

	complete_all(&cm7120_codec->fw_download_complete);
}
static int get_pin_control(struct cm7120_priv *cm7120)
{
	int rc = 0;

	if (!cm7120)
		return -EINVAL;

	cm7120->pinctrl = devm_pinctrl_get(cm7120->dev);
	if (IS_ERR_OR_NULL(cm7120->pinctrl)) {
		rc = PTR_ERR(cm7120->pinctrl);
		dev_err(cm7120->dev, "failed to get pinctrl, %d\n", rc);
		goto error;
	}

	cm7120->pin_default = pinctrl_lookup_state(cm7120->pinctrl, "default");
	if (IS_ERR_OR_NULL(cm7120->pin_default)) {
		rc = PTR_ERR(cm7120->pin_default);
		dev_err(cm7120->dev, "failed to get pinctrl default state\n");
		goto free_pinctrl;
	}
	rc = pinctrl_select_state(cm7120->pinctrl, cm7120->pin_default);
	if (rc) {
		dev_err(cm7120->dev, "failed to set pinctrl active, %d\n", rc);
		goto free_pinctrl;
	}
	return rc;

free_pinctrl:
	devm_pinctrl_put(cm7120->pinctrl);
error:
	return rc;
}

static int cm7120_i2c_probe(struct i2c_client *i2c,
			    const struct i2c_device_id *id)
{
	struct cm7120_priv *cm7120;
	int ret;

	dev_info(&i2c->dev, "%s entry\n", __func__);

	cm7120 =
		devm_kzalloc(&i2c->dev, sizeof(struct cm7120_priv), GFP_KERNEL);

	if (cm7120 == NULL)
		return -ENOMEM;

	cm7120->real_regmap =
		devm_regmap_init_i2c(i2c, &cm7120_regmap_physical);
	if (IS_ERR(cm7120->real_regmap)) {
		ret = PTR_ERR(cm7120->real_regmap);
		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
			ret);
		return ret;
	}
	cm7120->virt_regmap =
		devm_regmap_init(&i2c->dev, NULL, i2c, &cm7120_regmap);
	if (IS_ERR(cm7120->virt_regmap)) {
		ret = PTR_ERR(cm7120->virt_regmap);
		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
			ret);
		return ret;
	}
	cm7120->dev = &i2c->dev;
	i2c_set_clientdata(i2c, cm7120);

	/* regulator codec_1v8 */
	cm7120->codec_1v8 = regulator_get(cm7120->dev, "cm7120,codec_1v8");
	if (IS_ERR(cm7120->codec_1v8))
		dev_err(cm7120->dev, "codec_1v8 regulator_get error\n");

	ret = regulator_set_voltage(cm7120->codec_1v8, 1800000, 1800000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_1v8 set_voltage failed\n");

	ret = regulator_set_load(cm7120->codec_1v8, 300000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_1v8 set_load failed\n");

	ret = regulator_enable(cm7120->codec_1v8);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_1v8 regulator_enable failed\n");

	/* regulator codec_3v3 */
	cm7120->codec_3v3 = regulator_get(cm7120->dev, "cm7120,codec_3v3");
	if (IS_ERR(cm7120->codec_3v3))
		dev_err(cm7120->dev, "codec_3v3 regulator_get error\n");

	ret = regulator_set_voltage(cm7120->codec_3v3, 3300000, 3300000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_3v3 set_voltage failed\n");

	ret = regulator_set_load(cm7120->codec_3v3, 300000);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_3v3 set_load failed\n");

	ret = regulator_enable(cm7120->codec_3v3);
	if (ret < 0)
		dev_err(cm7120->dev, "codec_3v3 regulator_enable failed\n");

	ret = get_pin_control(cm7120);
	if (ret != 0) {
		dev_err(cm7120->dev, "Failed to get pin control\n");
		return ret;
	}

	regmap_read(cm7120->virt_regmap, CM7120_VENDOR_ID2, &ret);
	if (ret != CM7120_DEVICE_ID) {
		dev_err(&i2c->dev, "Device with ID register %x is not cm7120\n",
			ret);
		return -ENODEV;
	}

	mutex_init(&cm7120->dsp_lock);

	regmap_write(cm7120->real_regmap, CM7120_RESET, 0x10ec);

	/* firmware download */
	INIT_WORK(&cm7120->fw_download_work, cm7120_firmware_download_work);
	init_completion(&cm7120->fw_download_complete);
	usleep_range(10000, 15000);

	return snd_soc_register_component(&i2c->dev, &soc_component_dev_cm7120,
					  cm7120_dai, ARRAY_SIZE(cm7120_dai));
}

static int cm7120_i2c_remove(struct i2c_client *i2c)
{
	snd_soc_unregister_component(&i2c->dev);

	return 0;
}

void cm7120_i2c_shutdown(struct i2c_client *client)
{
	struct cm7120_priv *cm7120 = i2c_get_clientdata(client);
	struct snd_soc_component *component = cm7120->component;

	if (component != NULL)
		cm7120_set_bias_level(component, SND_SOC_BIAS_OFF);
}

struct i2c_driver cm7120_i2c_driver = {
	.driver = {
		.name = "cm7120",
		.of_match_table = cm7120_of_match,
	},
	.probe = cm7120_i2c_probe,
	.remove = cm7120_i2c_remove,
	.shutdown = cm7120_i2c_shutdown,
	.id_table = cm7120_i2c_id,
};
module_i2c_driver(cm7120_i2c_driver);

MODULE_DESCRIPTION("CM7120 CODEC driver");
MODULE_AUTHOR("Support <sales@cmedia.com.tw>");
MODULE_LICENSE("GPL v2");

// SPDX-License-Identifier: GPL-2.0-only

#include <linux/backlight.h>
#include <linux/device.h>
#include <linux/interrupt.h>
#include <linux/module.h>
#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/property.h>
#include <linux/spi/spi.h>

/* Compatible table name of the blu */
#define BLU_SPI_NODE_TABLE "oculus,seacliff-blu-spi"

/* Parameters of SPI devices */
#define BLU_SPI_MODE SPI_MODE_0
#define BLU_SPI_BITS_PER_WORD 8

/* Frames required to stablilize the BLU after power on */
#define STABLE_FRAME_COUNTS 10
/* Number of times of backlight matrix that needs to write via SPI */
#define NUMBER_OF_MUX 4

#define BL_NODE_NAME_SIZE 32

struct blu_device {
	const char *name;

	/* SPI device */
	struct spi_device *spi;

	/* Backlight device */
	struct backlight_device *bl_device;

	/* irq to trigger spi command transfer */
	int irq;
	/* frame counts since the blu powers on */
	u64 frame_counts;
	/* Backlight level, if 0 then disable irq */
	int backlight_level;
	int max_brightness;
	/* The arrray contains brightness info of 8 muxes */
	u8 *backlight_matrix;
	u32 mux_size;
};

/* Blu irq handler, transfer the SPI commands according to blu state */
static irqreturn_t blu_isr(int isr, void *spi_dev);

/*
 * Init messages to be transferred in SPI to BLU devices.
 * One time effort to copy BLU command to DMA.
 */
static void init_backlight_matrix(struct blu_device *blu);

/* Setup the sysnode for LED framework to control the backlight level */
static int blu_spi_panel_backlight_node_setup(struct blu_device *blu);
/* Update backlight level of the blu */
static void blu_spi_update_backlight(struct blu_device *blu, u32 bl_lvl);
/* Ops for backlight node */
static int blu_spi_backlight_device_update_status(struct backlight_device *bd);
static int blu_spi_backlight_device_get_brightness(struct backlight_device *bd);
static const struct backlight_ops blu_spi_backlight_device_ops = {
	.update_status = blu_spi_backlight_device_update_status,
	.get_brightness = blu_spi_backlight_device_get_brightness,
};

static int blu_spi_backlight_device_get_brightness(struct backlight_device *bd)
{
	return 0;
}

static int blu_spi_backlight_device_update_status(struct backlight_device *bd)
{
	int brightness;
	struct blu_device *blu = (struct blu_device *)dev_get_drvdata(&bd->dev);

	brightness = bd->props.brightness;

	if ((bd->props.power != FB_BLANK_UNBLANK) ||
			(bd->props.state & BL_CORE_FBBLANK) ||
			(bd->props.state & BL_CORE_SUSPENDED))
		brightness = 0;

	blu_spi_update_backlight(blu, brightness);

	return 0;
}

static int blu_spi_panel_backlight_node_setup(struct blu_device *blu)
{
	char bl_node_name[BL_NODE_NAME_SIZE];
	struct backlight_properties props;

	snprintf(bl_node_name, BL_NODE_NAME_SIZE,
			"panel-%s", blu->name);

	memset(&props, 0, sizeof(props));
	props.type = BACKLIGHT_PLATFORM;
	props.max_brightness = blu->max_brightness;
	props.power = FB_BLANK_UNBLANK;

	blu->bl_device = devm_backlight_device_register(
			&blu->spi->dev, bl_node_name, &blu->spi->dev, blu,
			&blu_spi_backlight_device_ops, &props);

	if (IS_ERR_OR_NULL(blu->bl_device)) {
		pr_err("%s: Failed to register backlight: %ld\n",
				    __func__, PTR_ERR(blu->bl_device));
		return -ENODEV;
	}

	return 0;
}

static void blu_spi_update_backlight(struct blu_device *blu, u32 bl_lvl)
{
	if (blu->backlight_level != bl_lvl) {
		if (blu->backlight_level == 0 && bl_lvl > 0)
			enable_irq(blu->irq);
		else if (bl_lvl == 0) {
			disable_irq(blu->irq);
			blu->frame_counts = 0;
		}

		blu->backlight_level = bl_lvl;
	}
}

static void init_backlight_matrix(struct blu_device *blu)
{
	/* Backlight matrix setting command, mux 1-8, can input double muxes together */
	const u8 input_matrix[] = {
		// MUX 1 & 2
		0x01, 0x01, 0x20, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00,
		0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE,
		// MUX 3 & 4
		0x01, 0x01, 0x20, 0x08, 0x20, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		// MUX 5 & 6
		0x01, 0x01, 0x20, 0x09, 0x40, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFF, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		// MUX 7 & 8
		0x01, 0x01, 0x20, 0x0A, 0x60, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFE,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE
	};

	blu->backlight_matrix = devm_kzalloc(&blu->spi->dev, sizeof(input_matrix), GFP_KERNEL | GFP_DMA);
	blu->mux_size = sizeof(input_matrix) / NUMBER_OF_MUX;
	memcpy(blu->backlight_matrix, input_matrix, sizeof(input_matrix));
}

static irqreturn_t blu_isr(int isr, void *blu_dev)
{
	/* SPI commands to enter/exit soft reset mode*/
	static const u8 blu_enter_reset_cmd[] = { 0x01, 0x00, 0x01, 0x00, 0x00, 0x00 };
	static const u8 blu_exit_reset_cmd[] = { 0x01, 0x00, 0x01, 0x00, 0x00, 0x01 };
	static const u8 blu_led_cmd[] = { 0x01, 0x00, 0x02, 0x00, 0x08, 0x06, 0xA0 };

	/* Global LED current setting command */
	struct blu_device *blu = (struct blu_device *)blu_dev;
	struct spi_device *spi = blu->spi;
	int mux = 0, ret = 0;

	if (blu->frame_counts == 0) {
		ret = spi_write(spi, blu_enter_reset_cmd, sizeof(blu_enter_reset_cmd));
		if (ret)
			dev_err(&spi->dev, "failed to enter soft reset mode, error %d\n", ret);

		ret = spi_write(spi, blu_led_cmd, sizeof(blu_led_cmd));
		if (ret)
			dev_err(&spi->dev, "failed to set LED current, errot %d\n", ret);

		ret = spi_write(spi, blu_exit_reset_cmd, sizeof(blu_exit_reset_cmd));
		if (ret)
			dev_err(&spi->dev, "failed to exit soft reset mode, error %d\n", ret);
	} else if (blu->frame_counts >= STABLE_FRAME_COUNTS) {
		for (mux = 0; mux < NUMBER_OF_MUX; ++mux) {
			ret = spi_write(spi, &(blu->backlight_matrix[blu->mux_size * mux]), blu->mux_size);
			if (ret)
				dev_err(&spi->dev, "failed to send backlight matrix, error %d\n", ret);
		}
	}

	++blu->frame_counts;

	return IRQ_HANDLED;
}

static int blu_spi_probe(struct spi_device *spi)
{
	struct blu_device *blu;
	int vsync_gpio;
	int ret = 0;

	spi->mode = BLU_SPI_MODE;
	spi->bits_per_word = BLU_SPI_BITS_PER_WORD;

	blu = devm_kzalloc(&spi->dev, sizeof(struct blu_device), GFP_KERNEL);
	if (!blu)
		return -ENOMEM;

	blu->spi = spi;

	ret = of_property_read_string(spi->dev.of_node, "oculus,blu-name", &blu->name);
	if (ret) {
		dev_err(&spi->dev, "%s: could not find oculus,blu-name property, ret=%d\n", __func__, ret);
		return ret;
	}
	dev_dbg(&spi->dev, "%s: initing blu %s\n", __func__, blu->name);

	if (of_property_read_u32(spi->dev.of_node, "oculus,blu-max-brightness", &blu->max_brightness))
		blu->max_brightness = 255;

	ret = blu_spi_panel_backlight_node_setup(blu);
	if (ret) {
		dev_err(&spi->dev, "%s: failed to setup backlight node, ret=%d\n", __func__, ret);
		return ret;
	}

	vsync_gpio = of_get_named_gpio(spi->dev.of_node, "oculus,blu-irq-gpio", 0);
	if (!gpio_is_valid(vsync_gpio)) {
		dev_err(&spi->dev, "%s: blu-irq-gpio %d is invalid\n", __func__, vsync_gpio);
		return -EINVAL;
	}

	ret = devm_gpio_request(&spi->dev, vsync_gpio, blu->name);
	if (ret) {
		dev_err(&spi->dev, "%s: failed to requeset gpio %d\n", __func__, vsync_gpio);
		return ret;
	}

	blu->irq = gpio_to_irq(vsync_gpio);
	if (blu->irq < 0) {
		dev_err(&spi->dev, "%s: failed to transfer gpio %d to irq\n",
				__func__, vsync_gpio);
		return ret;
	}

	dev_set_drvdata(&spi->dev, blu);

	init_backlight_matrix(blu);

	blu->frame_counts = 0;

	blu->backlight_level = blu->max_brightness;

	ret = devm_request_threaded_irq(&spi->dev,
			blu->irq, NULL, blu_isr,
			IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
			blu->name, blu);

	if (ret) {
		dev_err(&blu->spi->dev, "%s: failed to request wake IRQ of %s, ret %d\n",
				__func__, blu->name, ret);
		return ret;
	}

	return ret;
}

static int blu_spi_remove(struct spi_device *spi)
{
	struct blu_device *blu = (struct blu_device *)dev_get_drvdata(&spi->dev);

	if (blu->irq > 0) {
		disable_irq(blu->irq);
	}

	return 0;
}

static const struct of_device_id blu_spi_of_match_table[] = {
	{.compatible = BLU_SPI_NODE_TABLE,},
	{},
};
MODULE_DEVICE_TABLE(of, blu_spi_of_match_table);

static struct spi_driver blu_spi_driver = {
	.driver = {
		.name = "seacliff-blu-spi",
		.of_match_table = blu_spi_of_match_table,
	},
	.probe = blu_spi_probe,
	.remove = blu_spi_remove,
};
module_spi_driver(blu_spi_driver);

MODULE_DESCRIPTION("Seacliff panels BLU SPI driver");
MODULE_LICENSE("GPL v2");

// SPDX-License-Identifier: GPL-2.0-only

#include <linux/backlight.h>
#include <linux/device.h>
#include <linux/interrupt.h>
#include <linux/miscdevice.h>
#include <linux/module.h>
#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/property.h>
#include <linux/spi/spi.h>
#include <linux/uaccess.h>

#include "linux/seacliff_blu_spi.h"

/* Compatible table name of the blu */
#define BLU_SPI_NODE_TABLE "oculus,seacliff-blu-spi"

/* Parameters of SPI devices */
#define BLU_SPI_MODE SPI_MODE_0
#define BLU_SPI_BITS_PER_WORD 8

/* Frames required to stablilize the BLU after power on */
#define STABLE_FRAME_COUNTS 10
/* Number of times of backlight matrix that needs to write via SPI */
#define NUMBER_OF_MUX 4

#define BL_NODE_NAME_SIZE 32

/* keep track of the number of driver instances */
static int number_of_devices = 0;

struct blu_device {
	const char *name;

	/* SPI device */
	struct spi_device *spi;

	/* misc device for receiving the backlight matrix*/
	struct miscdevice misc;

	/* Backlight device */
	struct backlight_device *bl_device;

	/* irq to trigger spi command transfer */
	int irq;
	/* frame counts since the blu powers on */
	u64 frame_counts;
	/* Backlight level, if 0 then disable irq */
	int backlight_level;
	int max_brightness;
	/* The arrray contains brightness info of 8 muxes */
	u8 *backlight_matrix;
	u32 mux_size;
	u32 matrix_size;

	/* backlight matrix intermediate buffer */
	u8 *back_buffer;

	/* flag to control read/write to the temp buffer */
	atomic_t buffer_dirty;
};

/* Blu irq handler, transfer the SPI commands according to blu state */
static irqreturn_t blu_isr(int isr, void *spi_dev);

/*
 * Init messages to be transferred in SPI to BLU devices.
 * One time effort to copy BLU command to DMA.
 */
static void init_backlight_matrix(struct blu_device *blu);

/* Setup the sysnode for LED framework to control the backlight level */
static int blu_spi_panel_backlight_node_setup(struct blu_device *blu);
/* Update backlight level of the blu */
static void blu_spi_update_backlight(struct blu_device *blu, u32 bl_lvl);
/* Ops for backlight node */
static int blu_spi_backlight_device_update_status(struct backlight_device *bd);
static int blu_spi_backlight_device_get_brightness(struct backlight_device *bd);
static const struct backlight_ops blu_spi_backlight_device_ops = {
	.update_status = blu_spi_backlight_device_update_status,
	.get_brightness = blu_spi_backlight_device_get_brightness,
};

static int blu_spi_backlight_device_get_brightness(struct backlight_device *bd)
{
	return 0;
}

static int blu_spi_backlight_device_update_status(struct backlight_device *bd)
{
	int brightness;
	struct blu_device *blu = (struct blu_device *)dev_get_drvdata(&bd->dev);

	brightness = bd->props.brightness;

	if ((bd->props.power != FB_BLANK_UNBLANK) ||
			(bd->props.state & BL_CORE_FBBLANK) ||
			(bd->props.state & BL_CORE_SUSPENDED))
		brightness = 0;

	blu_spi_update_backlight(blu, brightness);

	return 0;
}

static int blu_spi_panel_backlight_node_setup(struct blu_device *blu)
{
	char bl_node_name[BL_NODE_NAME_SIZE];
	struct backlight_properties props;

	snprintf(bl_node_name, BL_NODE_NAME_SIZE,
			"panel-%s", blu->name);

	memset(&props, 0, sizeof(props));
	props.type = BACKLIGHT_PLATFORM;
	props.max_brightness = blu->max_brightness;
	props.power = FB_BLANK_UNBLANK;

	blu->bl_device = devm_backlight_device_register(
			&blu->spi->dev, bl_node_name, &blu->spi->dev, blu,
			&blu_spi_backlight_device_ops, &props);

	if (IS_ERR_OR_NULL(blu->bl_device)) {
		pr_err("%s: Failed to register backlight: %ld\n",
				    __func__, PTR_ERR(blu->bl_device));
		return -ENODEV;
	}

	return 0;
}

static void blu_spi_update_backlight(struct blu_device *blu, u32 bl_lvl)
{
	if (blu->backlight_level != bl_lvl) {
		if (blu->backlight_level == 0 && bl_lvl > 0)
			enable_irq(blu->irq);
		else if (bl_lvl == 0) {
			disable_irq(blu->irq);
			blu->frame_counts = 0;
		}

		blu->backlight_level = bl_lvl;
	}
}

static void init_backlight_matrix(struct blu_device *blu)
{
	/* Backlight matrix setting command, mux 1-8, can input double muxes together */
	const u8 input_matrix[] = {
		// MUX 1 & 2
		0x01, 0x01, 0x20, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00,
		0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE,
		// MUX 3 & 4
		0x01, 0x01, 0x20, 0x08, 0x20, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		// MUX 5 & 6
		0x01, 0x01, 0x20, 0x09, 0x40, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFF, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		// MUX 7 & 8
		0x01, 0x01, 0x20, 0x0A, 0x60, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFE,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE,
		0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F,
		0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE
	};

	blu->backlight_matrix = devm_kzalloc(&blu->spi->dev, sizeof(input_matrix), GFP_KERNEL | GFP_DMA);
	blu->mux_size = sizeof(input_matrix) / NUMBER_OF_MUX;
	blu->back_buffer = devm_kzalloc(&blu->spi->dev, sizeof(input_matrix), GFP_KERNEL | GFP_DMA);
	memcpy(blu->backlight_matrix, input_matrix, sizeof(input_matrix));
}

static void swap_buffers(u8 **buffer1, u8 **buffer2) {
	u8 *temp;
	temp = *buffer1;
	*buffer1 = *buffer2;
	*buffer2 = temp;
}

static irqreturn_t blu_isr(int isr, void *blu_dev)
{
	/* SPI commands to enter/exit soft reset mode*/
	static const u8 blu_enter_reset_cmd[] = { 0x01, 0x00, 0x01, 0x00, 0x00, 0x00 };
	static const u8 blu_exit_reset_cmd[] = { 0x01, 0x00, 0x01, 0x00, 0x00, 0x01 };
	static const u8 blu_led_cmd[] = { 0x01, 0x00, 0x02, 0x00, 0x08, 0x06, 0xA0 };

	/* Global LED current setting command */
	struct blu_device *blu = (struct blu_device *)blu_dev;
	struct spi_device *spi = blu->spi;
	int mux = 0, ret = 0;
	int old;

	/*
	 * BLU init requirement of hardware:
	 * frame [0]: enter soft reset mode and set up global LED current.
	 * frame [1, STABLE_FRAME_COUNTS1): wait of PLL signal to be stable.
	 * frame [STABLE_FRAME_COUNTS]: exit soft reset mode.
	 * frame (STABLE_FRAME_COUNTS, ): input backlight matrix.
	**/
	if (blu->frame_counts == 0) {
		ret = spi_write(spi, blu_enter_reset_cmd, sizeof(blu_enter_reset_cmd));
		if (ret)
			dev_err(&spi->dev, "failed to enter soft reset mode, error %d\n", ret);

		ret = spi_write(spi, blu_led_cmd, sizeof(blu_led_cmd));
		if (ret)
			dev_err(&spi->dev, "failed to set LED current, errot %d\n", ret);
	} else if (blu->frame_counts == STABLE_FRAME_COUNTS) {
		ret = spi_write(spi, blu_exit_reset_cmd, sizeof(blu_exit_reset_cmd));
		if (ret)
			dev_err(&spi->dev, "failed to exit soft reset mode, error %d\n", ret);
	} else {
		old = atomic_read(&blu->buffer_dirty);

		/* if the back buffer is dirty, get the new matrix */
		if (old)
			swap_buffers(&(blu->backlight_matrix), &(blu->back_buffer));

		for (mux = 0; mux < NUMBER_OF_MUX; ++mux) {
			ret = spi_write(spi, &(blu->backlight_matrix[blu->mux_size * mux]), blu->mux_size);
			if (ret)
				dev_err(&spi->dev, "failed to send backlight matrix, error %d\n", ret);
		}
		atomic_set(&blu->buffer_dirty, 0);
	}

	++blu->frame_counts;

	return IRQ_HANDLED;
}

static int blu_spi_open(struct inode *inode, struct file *file)
{
	if (!try_module_get(THIS_MODULE))
		return -ENODEV;

	return 0;
}

static int blu_spi_release(struct inode *inode, struct file *file)
{
	module_put(THIS_MODULE);

	return 0;
}

static int transfer_backlight_matrix(struct blu_device *blu,
		struct blu_spi_backlight_matrix __user *blm)
{
	int ret;
	struct blu_spi_backlight_matrix blu_matrix;
	int old;

	old = atomic_read(&blu->buffer_dirty);

	/* if the intermediate buffer is still dirty, don't update it */
	if (old) {
		dev_dbg(&blu->spi->dev, "Cannot update the backlight matrix, " \
			"temp buffer values are still dirty\n");
		return 0;
	}

	/* first get the struct from user space */
	ret = copy_from_user(&blu_matrix, blm, sizeof(blu_matrix));
	if (ret) {
		dev_err(&blu->spi->dev, "Failed to copy %d bytes from " \
			"backlight matrix struct\n", ret);
		return -EFAULT;
	}

	blu->matrix_size = blu_matrix.matrix_size;

	/* get the matrix from the struct and place in intermediate buffer */
	ret = copy_from_user(blu->back_buffer, blu_matrix.backlight_matrix,
			blu->matrix_size);
	if (ret) {
		dev_err(&blu->spi->dev, "Failed to copy %d bytes from " \
			"backlight matrix\n", ret);
		return -EFAULT;
	}

	/* set the buffer values to dirty */
	atomic_set(&blu->buffer_dirty, 1);

	return ret;
}

static long blu_spi_ioctl(struct file *file, unsigned int cmd,
		unsigned long arg)
{
	struct blu_device *blu = container_of(file->private_data,
		struct blu_device, misc);

	switch(cmd) {
		case BLU_SPI_SET_BACKLIGHT_IOCTL:
			return transfer_backlight_matrix(blu,
				(struct blu_spi_backlight_matrix *)arg);
		default:
			dev_err(&blu->spi->dev, "Unrecognized IOCTL %ul\n", cmd);
			return -EINVAL;
	}

	return 0;
}

static struct file_operations blu_spi_fops = {
	.owner = THIS_MODULE,
	.read = NULL,
	.write = NULL,
	.open = blu_spi_open,
	.release = blu_spi_release,
	.unlocked_ioctl = blu_spi_ioctl
};

static int blu_spi_probe(struct spi_device *spi)
{
	struct blu_device *blu;
	int vsync_gpio;
	int ret = 0;
	char device_name[8];

	spi->mode = BLU_SPI_MODE;
	spi->bits_per_word = BLU_SPI_BITS_PER_WORD;

	blu = devm_kzalloc(&spi->dev, sizeof(struct blu_device), GFP_KERNEL);
	if (!blu)
		return -ENOMEM;

	blu->spi = spi;

	atomic_set(&blu->buffer_dirty, 0);

	ret = of_property_read_string(spi->dev.of_node, "oculus,blu-name", &blu->name);
	if (ret) {
		dev_err(&spi->dev, "%s: could not find oculus,blu-name property, ret=%d\n", __func__, ret);
		return ret;
	}
	dev_dbg(&spi->dev, "%s: initing blu %s\n", __func__, blu->name);

	if (of_property_read_u32(spi->dev.of_node, "oculus,blu-max-brightness", &blu->max_brightness))
		blu->max_brightness = 255;

	ret = blu_spi_panel_backlight_node_setup(blu);
	if (ret) {
		dev_err(&spi->dev, "%s: failed to setup backlight node, ret=%d\n", __func__, ret);
		return ret;
	}

	snprintf(device_name, sizeof(device_name), "blu%d", number_of_devices++);

	/* misc device info */
	blu->misc.name = device_name;
	blu->misc.minor = MISC_DYNAMIC_MINOR;
	blu->misc.fops = &blu_spi_fops;

	/* register the misc device */
	ret = misc_register(&blu->misc);
	if (ret < 0) {
		dev_err(&spi->dev, "%s fails to register misc device, error %d",
			__func__, ret);
		return ret;
	}

	vsync_gpio = of_get_named_gpio(spi->dev.of_node, "oculus,blu-irq-gpio", 0);
	if (!gpio_is_valid(vsync_gpio)) {
		dev_err(&spi->dev, "%s: blu-irq-gpio %d is invalid\n", __func__, vsync_gpio);
		return -EINVAL;
	}

	ret = devm_gpio_request(&spi->dev, vsync_gpio, blu->name);
	if (ret) {
		dev_err(&spi->dev, "%s: failed to requeset gpio %d\n", __func__, vsync_gpio);
		return ret;
	}

	blu->irq = gpio_to_irq(vsync_gpio);
	if (blu->irq < 0) {
		dev_err(&spi->dev, "%s: failed to transfer gpio %d to irq\n",
				__func__, vsync_gpio);
		return ret;
	}

	dev_set_drvdata(&spi->dev, blu);

	init_backlight_matrix(blu);

	if (of_property_read_bool(spi->dev.of_node, "oculus,continuous-splash")) {
		blu->frame_counts = 0;
	} else {
		blu->frame_counts = STABLE_FRAME_COUNTS + 1;
	}

	blu->backlight_level = blu->max_brightness;

	ret = devm_request_threaded_irq(&spi->dev,
			blu->irq, NULL, blu_isr,
			IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
			blu->name, blu);

	if (ret) {
		dev_err(&blu->spi->dev, "%s: failed to request wake IRQ of %s, ret %d\n",
				__func__, blu->name, ret);
		return ret;
	}

	return ret;
}

static int blu_spi_remove(struct spi_device *spi)
{
	struct blu_device *blu = (struct blu_device *)dev_get_drvdata(&spi->dev);

	if (blu->irq > 0) {
		disable_irq(blu->irq);
	}

	/* unregister the misc device */
	misc_deregister(&blu->misc);

	return 0;
}

static const struct of_device_id blu_spi_of_match_table[] = {
	{.compatible = BLU_SPI_NODE_TABLE,},
	{},
};
MODULE_DEVICE_TABLE(of, blu_spi_of_match_table);

static struct spi_driver blu_spi_driver = {
	.driver = {
		.name = "seacliff-blu-spi",
		.of_match_table = blu_spi_of_match_table,
	},
	.probe = blu_spi_probe,
	.remove = blu_spi_remove,
};
module_spi_driver(blu_spi_driver);

MODULE_DESCRIPTION("Seacliff panels BLU SPI driver");
MODULE_LICENSE("GPL v2");
